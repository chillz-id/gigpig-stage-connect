{
  "name": "Humanitix \u2192 Supabase (Code-only) with Sessions",
  "nodes": [
    {
      "parameters": {
        "jsCode": "async function run() {\n  const humanitixApiKey = 'e1d1dd7f16c5e2ad034d89e2f2056d0684e7113d154476a6c59735a31ed78c91915e068534197c92e187ad0251c171fdf0bb0d7b99ee6cbc2cb62d5753a01f1e279cd316e5b64420b4264891f3332edac4b8404e400bf07e1f79f4e2ba0acf946c8c0b3c35963ea7a1c89e86c1ceb2';\n  const supabaseUrl = 'https://pdikjpfulhhpqpxzpgtu.supabase.co';\n  const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBkaWtqcGZ1bGhocHFweHpwZ3R1Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1MDI2Njg2MSwiZXhwIjoyMDY1ODQyODYxfQ.RS6RG0nbmxEqtO99dnpGnd7WV7C_uI0l_XJugKqOzPE';\n\n  if (!humanitixApiKey) {\n    throw new Error('Missing Humanitix API key.');\n  }\n  if (!supabaseUrl || !supabaseKey) {\n    throw new Error('Missing Supabase credentials.');\n  }\n\n  const getStaticData = () => {\n    if (typeof this.getWorkflowStaticData === 'function') {\n      return this.getWorkflowStaticData('global');\n    }\n    if (typeof $workflow !== 'undefined' && typeof $workflow.getStaticData === 'function') {\n      return $workflow.getStaticData('global');\n    }\n    return {};\n  };\n\n  const setStaticData = (value) => {\n    if (typeof this.getWorkflowStaticData === 'function') {\n      this.getWorkflowStaticData('global').lastSync = value;\n      return;\n    }\n    if (typeof $workflow !== 'undefined' && typeof $workflow.getStaticData === 'function') {\n      $workflow.getStaticData('global').lastSync = value;\n    }\n  };\n\n  const staticData = getStaticData();\n  const defaultSince = '2022-01-01T00:00:00Z';\n  const lastSync = staticData.lastSync || defaultSince;\n  const syncStartedAt = new Date().toISOString();\n\n  const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\n  const humanitixBase = 'https://api.humanitix.com/v1';\n  const pageSize = 100;\n  const interRequestDelayMs = 1500;\n\n  const fetchHumanitix = async ({ path, resultKey, label, query = {} }) => {\n    let page = 1;\n    const records = [];\n\n    while (true) {\n      const response = await this.helpers.httpRequest({\n        method: 'GET',\n        url: `${humanitixBase}${path}`,\n        headers: { 'X-API-Key': humanitixApiKey },\n        qs: { page, pageSize, ...query },\n        json: true,\n      });\n\n      const data = resultKey ? response?.[resultKey] : response?.data;\n      const batch = Array.isArray(data)\n        ? data\n        : Array.isArray(response)\n        ? response\n        : [];\n\n      if (!Array.isArray(batch)) {\n        throw new Error(`Unexpected response structure while fetching ${label || path}`);\n      }\n\n      records.push(...batch);\n\n      const hasMore =\n        response?.meta?.pagination?.hasMore ??\n        (batch.length === pageSize && !!response?.meta);\n\n      if (!hasMore) {\n        break;\n      }\n\n      page += 1;\n      await wait(interRequestDelayMs);\n    }\n\n    return records;\n  };\n\n  const cents = (value) =>\n    typeof value === 'number' && Number.isFinite(value)\n      ? Math.round(value * 100)\n      : 0;\n\n  const toIso = (value) => {\n    if (!value) return null;\n    const d = new Date(value);\n    return Number.isNaN(d.getTime()) ? null : d.toISOString();\n  };\n\n  const normalizeSessions = (event) => {\n    const sessionMap = new Map();\n\n    const register = (session, index, origin) => {\n      if (!session || typeof session !== 'object') return;\n\n      const candidateId =\n        session.session_id ||\n        session._id ||\n        session.id ||\n        session.sessionId ||\n        session.scheduleId ||\n        session.eventDateId ||\n        session.dateId;\n\n      const key =\n        candidateId || `${event._id || 'event'}-${origin}-${(index || 0) + 1}`;\n\n      if (!sessionMap.has(key)) {\n        sessionMap.set(key, { ...session, _id: candidateId || session._id || key });\n      }\n    };\n\n    const candidateArrays = [\n      ['sessions', event.sessions],\n      ['eventSessions', event.eventSessions],\n      ['multiDates', event.multiDates],\n      ['schedule', event.schedule],\n      ['timeslots', event.timeslots],\n    ];\n\n    candidateArrays.forEach(([origin, pool]) => {\n      if (!Array.isArray(pool)) return;\n      pool.forEach((session, index) => register(session, index, origin));\n    });\n\n    if (Array.isArray(event.dates)) {\n      event.dates.forEach((range, index) => {\n        if (!range || typeof range !== 'object') return;\n\n        const start =\n          range.startDateTime ||\n          range.startDate ||\n          range.start ||\n          (range.date && range.date.start) ||\n          null;\n        const end =\n          range.endDateTime ||\n          range.endDate ||\n          range.end ||\n          (range.date && range.date.end) ||\n          null;\n\n        const hydrated = {\n          ...range,\n          _id:\n            range._id ||\n            range.session_id ||\n            range.id ||\n            range.scheduleId ||\n            range.eventDateId ||\n            `${event._id || 'event'}-date-${index + 1}`,\n          name:\n            range.name ||\n            range.title ||\n            range.label ||\n            `${event.name || 'Session'} ${index + 1}`,\n          startDateTime: start,\n          endDateTime: end,\n          date: {\n            start,\n            end,\n            ...(range.date && typeof range.date === 'object' ? range.date : {}),\n          },\n          timezone:\n            range.timezone ||\n            range.timeZone ||\n            (range.date && range.date.timezone) ||\n            event.timezone ||\n            event.timeZone ||\n            null,\n        };\n\n        register(hydrated, index, 'dates');\n      });\n    }\n\n    return Array.from(sessionMap.values());\n  };\n\n  const supabaseRequest = async ({ table, rows }) => {\n    const validationErrors = rows\n      .map((row, index) => ({ index: index + 1, missing: [] }))\n      .map((item, idx) => {\n        const row = rows[idx];\n        if (!row.source) item.missing.push('source');\n        if (!row.source_id) item.missing.push('source_id');\n        return item;\n      })\n      .filter((item) => item.missing.length);\n\n    if (validationErrors.length) {\n      throw new Error(`Supabase payload validation failed: ${JSON.stringify(validationErrors)}`);\n    }\n\n    const chunkSize = 50;\n    console.log(`Upserting ${rows.length} rows into ${table}`);\n    for (let i = 0; i < rows.length; i += chunkSize) {\n      const chunk = rows.slice(i, i + chunkSize);\n      const response = await this.helpers.httpRequest({\n        method: 'POST',\n        url: `${supabaseUrl}/rest/v1/${table}?on_conflict=source,source_id`,\n        headers: {\n          apikey: supabaseKey,\n          Authorization: `Bearer ${supabaseKey}`,\n          'Content-Type': 'application/json',\n          Prefer: 'resolution=merge-duplicates,return=representation',\n        },\n        body: chunk,\n        json: true,\n        resolveWithFullResponse: true,\n        returnFullResponse: true,\n        simple: false,\n      });\n\n      if (response.status >= 400) {\n        console.error('Supabase error response:', response.data);\n        throw new Error(`Supabase ${table} upsert failed with status ${response.status}: ${JSON.stringify(response.data)}`);\n      }\n\n      await wait(500);\n    }\n  };\n\n  const upsertTable = async (table, rows) => {\n    if (!rows.length) return;\n\n    const chunkSize = 50;\n    console.log(`Upserting ${rows.length} rows into ${table}`);\n\n    for (let i = 0; i < rows.length; i += chunkSize) {\n      const chunk = rows.slice(i, i + chunkSize);\n      try {\n        const response = await this.helpers.httpRequest({\n          method: 'POST',\n          url: `${supabaseUrl}/rest/v1/${table}?on_conflict=source,source_id`,\n          headers: {\n            apikey: supabaseKey,\n            Authorization: `Bearer ${supabaseKey}`,\n            'Content-Type': 'application/json',\n            Prefer: 'resolution=merge-duplicates,return=representation',\n          },\n          body: chunk,\n          json: true,\n        });\n        await wait(500);\n      } catch (error) {\n        const status = error.response?.status;\n        const data = error.response?.data;\n        console.error(`Supabase upsert error for ${table}:`, status, data);\n        throw new Error(`Supabase upsert failed for ${table} with status ${status}. Response: ${JSON.stringify(data)}`);\n      }\n    }\n  };\n\n  const events = await fetchHumanitix({\n    path: '/events',\n    resultKey: 'events',\n    label: 'events',\n    query: { since: lastSync },\n  });\n\n  console.log(`Fetched ${events.length} events since ${lastSync}`);\n\n  const eventsPayload = [];\n  const sessionsPayload = [];\n  const ordersPayload = [];\n  const ticketsPayload = [];\n\n  for (const event of events) {\n    if (!event?._id) continue;\n\n    eventsPayload.push({\n      source: 'humanitix',\n      source_id: event._id,\n      name: event.name || '',\n      description: event.description || '',\n      slug: event.slug || '',\n      url: event.url || event.publicUrl || '',\n      start_date:\n        event.startDateTime ||\n        event.startDate ||\n        event.start ||\n        null,\n      end_date:\n        event.endDateTime ||\n        event.endDate ||\n        event.end ||\n        null,\n      timezone: event.timezone || event.timeZone || '',\n      status: event.status || event.state || null,\n      total_capacity:\n        event.totalCapacity ?? event.total_capacity ?? null,\n      public: Boolean(event.public),\n      published: Boolean(event.published),\n      venue_name:\n        event.eventLocation?.venueName ||\n        event.venue?.name ||\n        '',\n      venue_address:\n        event.eventLocation?.address ||\n        event.venue?.address ||\n        '',\n      venue_city:\n        event.eventLocation?.city || event.venue?.city || '',\n      venue_country:\n        event.eventLocation?.country ||\n        event.venue?.country ||\n        '',\n      created_at: toIso(event.createdAt),\n      updated_at: toIso(event.updatedAt),\n      raw: event,\n            });\n\n    const sessions = normalizeSessions(event);\n    sessions.forEach((session, index) => {\n      const sessionId =\n        session.session_id ||\n        session._id ||\n        session.id ||\n        `${event._id}-session-${index + 1}`;\n\n      sessionsPayload.push({\n        source: 'humanitix',\n        source_id: sessionId,\n        event_source_id: event._id,\n        name: session.name || session.title || event.name || null,\n        start_date:\n          session.startDateTime ||\n          session.startDate ||\n          session.start ||\n          session.date?.start ||\n          null,\n        end_date:\n          session.endDateTime ||\n          session.endDate ||\n          session.end ||\n          session.date?.end ||\n          null,\n        timezone:\n          session.timezone ||\n          session.timeZone ||\n          event.timezone ||\n          null,\n        venue_name:\n          session.venueName ||\n          session.venue?.name ||\n          event.eventLocation?.venueName ||\n          null,\n        created_at: toIso(session.createdAt),\n        updated_at: toIso(session.updatedAt),\n        raw: session,\n                  });\n    });\n\n    const orders = await fetchHumanitix({\n      path: `/events/${event._id}/orders`,\n      resultKey: 'orders',\n      label: `orders for ${event._id}`,\n      query: { since: lastSync },\n    });\n\n    orders.forEach((order) => {\n      ordersPayload.push({\n        source: 'humanitix',\n        source_id: order._id,\n        event_source_id: order.eventId || event._id,\n        session_source_id: order.eventDateId || null,\n        order_reference: order.reference || order._id,\n        status: order.status || null,\n        financial_status: order.financialStatus || null,\n        manual_order: Boolean(order.manualOrder),\n        sales_channel: order.salesChannel || null,\n        total_cents: cents(order.totals?.total),\n        subtotal_cents: cents(order.totals?.subtotal),\n        net_sales_cents: cents(order.totals?.netSales),\n        gross_sales_cents: cents(order.totals?.grossSales),\n        discounts_cents: cents(\n          order.totals?.discounts || order.totals?.discount\n        ),\n        taxes_cents: cents(order.totals?.taxes || order.totals?.tax),\n        humanitix_fee_cents: cents(order.totals?.humanitixFee),\n        booking_fee_cents: cents(order.totals?.bookingFee),\n        passed_on_fee_cents: cents(order.totals?.passedOnFee),\n        purchaser_email: order.email || null,\n        purchaser_name: `${order.firstName || ''} ${\n          order.lastName || ''\n        }`.trim() || null,\n        ordered_at: toIso(order.completedAt || order.createdAt),\n        updated_at: toIso(order.updatedAt),\n        additional_fields: order.additionalFields || null,\n        raw: order,\n                  });\n    });\n\n    const tickets = await fetchHumanitix({\n      path: `/events/${event._id}/tickets`,\n      resultKey: 'tickets',\n      label: `tickets for ${event._id}`,\n      query: { since: lastSync },\n    });\n\n    tickets.forEach((ticket) => {\n      const checkIn = ticket.checkIn || {};\n      const seating = ticket.seatingLocation || {};\n      const discounts = ticket.discounts || {};\n      const discountCode = discounts.discountCode || {};\n      const autoDiscount = discounts.autoDiscount || {};\n\n      ticketsPayload.push({\n        source: 'humanitix',\n        source_id: ticket._id,\n        event_source_id: ticket.eventId || event._id,\n        order_source_id: ticket.orderId || null,\n        session_source_id: ticket.eventDateId || null,\n        ticket_type_id: ticket.ticketTypeId || null,\n        ticket_type_name: ticket.ticketTypeName || null,\n        ticket_number: ticket.number || null,\n        first_name: ticket.firstName || null,\n        last_name: ticket.lastName || null,\n        organisation: ticket.organisation || null,\n        price_cents: cents(ticket.price),\n        net_price_cents: cents(ticket.netPrice),\n        total_cents: cents(ticket.total),\n        discount_cents: cents(ticket.discount),\n        taxes_cents: cents(ticket.taxes),\n        fee_cents: cents(ticket.fee),\n        passed_on_fee_cents: cents(ticket.passedOnFee),\n        absorbed_fee_cents: cents(ticket.absorbedFee),\n        dgr_donation_cents: cents(ticket.dgrDonation),\n        discount_code_used: discountCode.code || null,\n        discount_code_amount_cents: cents(discountCode.discountAmount),\n        auto_discount_amount_cents: cents(autoDiscount.discountAmount),\n        status: ticket.status || null,\n        sales_channel: ticket.salesChannel || null,\n        is_donation: Boolean(ticket.isDonation),\n        cancelled_at: toIso(ticket.cancelledAt),\n        checked_in: Boolean(checkIn.checkedIn),\n        check_in_status: checkIn.status || null,\n        check_in_date: toIso(checkIn.checkedInAt),\n        check_in_device: checkIn.device || null,\n        check_in_location: checkIn.location || null,\n        check_in_notes: checkIn.notes || null,\n        seating_map_id: seating.seatingMapId || null,\n        seating_name: seating.name || null,\n        seating_section: seating.section || null,\n        seating_table: seating.table || null,\n        seating_seat: seating.seat || null,\n        seating_note: seating.note || null,\n        barcode: ticket.qrCodeData?._id || ticket.customScanningCode || null,\n        qr_code_data: ticket.qrCodeData || null,\n        custom_scanning_code: ticket.customScanningCode || null,\n        access_code: ticket.accessCode || null,\n        swapped_from: ticket.swappedFrom || null,\n        swapped_to: ticket.swappedTo || null,\n        currency: ticket.currency || null,\n        order_name: ticket.orderName || null,\n        additional_fields: ticket.additionalFields || null,\n        raw: ticket,\n        created_at: toIso(ticket.createdAt),\n        updated_at: toIso(ticket.updatedAt),\n                  });\n    });\n\n    await wait(500);\n  }\n\n\n\n  await upsertTable('events_htx', eventsPayload);\n  await upsertTable('sessions_htx', sessionsPayload);\n  await upsertTable('orders_htx', ordersPayload);\n  await upsertTable('tickets_htx', ticketsPayload);\n   setStaticData(syncStartedAt);\n\n  console.log(\n    `Sync complete. Events: ${eventsPayload.length}, Sessions: ${sessionsPayload.length}, Orders: ${ordersPayload.length}, Tickets: ${ticketsPayload.length}`\n  );\n\n  return [\n    {\n      json: {\n        lastSyncUsed: lastSync,\n        syncedAt: syncStartedAt,\n        events: eventsPayload.length,\n        sessions: sessionsPayload.length,\n        orders: ordersPayload.length,\n        tickets: ticketsPayload.length,\n      },\n    },\n  ];\n}\n\nreturn run.call(this);\n"
      },
      "id": "7f6ba60e-1e65-478d-94ce-84ca6b0eee3d",
      "name": "Sync Humanitix to Supabase",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        288,
        0
      ]
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 10
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        64,
        0
      ],
      "id": "0e9726e4-e92b-47b4-9e76-704419fc8c22",
      "name": "Schedule Trigger"
    }
  ],
  "pinData": {},
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Sync Humanitix to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "timezone": "Australia/Sydney",
    "callerPolicy": "workflowsFromSameOwner"
  },
  "versionId": "a81034d4-a4be-45ca-afc5-3a9e83cf5d9a",
  "meta": {
    "instanceId": "f7982260359ec38ac1c22ac6f7afe7d220775ffc19f83939f161a55b37bcebf7"
  },
  "id": "vscIOyjsuXbZavSv",
  "tags": []
}