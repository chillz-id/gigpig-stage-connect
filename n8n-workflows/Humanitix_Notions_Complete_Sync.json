{
  "name": "Humanitix \u2192 Notion Complete Sync",
  "active": false,
  "nodes": [
    {
      "id": "schedule-trigger",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 2,
      "position": [
        260,
        300
      ],
      "parameters": {
        "rule": {
          "mode": "custom",
          "expression": "*/10 * * * *"
        }
      }
    },
    {
      "id": "sync-humanitix-notion",
      "name": "Sync Humanitix \u2192 Notion",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        560,
        300
      ],
      "parameters": {
        "jsCode": "/* Humanitix -> Notion sync code for n8n Code node */\nconst HUMANITIX_API_KEY = $env.HUMANITIX_API_KEY;\nconst NOTION_TOKEN = $env.NOTION_TOKEN;\nconst NOTION_VERSION = $env.NOTION_VERSION || '2022-06-28';\nconst NOTION_EVENTS_DB_ID = $env.NOTION_EVENTS_DB_ID;\nconst NOTION_SESSIONS_DB_ID = $env.NOTION_SESSIONS_DB_ID || null;\nconst NOTION_ORDERS_DB_ID = $env.NOTION_ORDERS_DB_ID;\nconst NOTION_TICKETS_DB_ID = $env.NOTION_TICKETS_DB_ID;\nconst NOTION_THROTTLE_MS = Number($env.NOTION_THROTTLE_MS || 350);\nconst HUMANITIX_PAGE_SIZE = Number($env.HUMANITIX_PAGE_SIZE || 100);\nconst NOTION_SYNC_DEBUG = ($env.NOTION_SYNC_DEBUG || '').toLowerCase();\nconst IS_DEBUG = NOTION_SYNC_DEBUG === 'true' || NOTION_SYNC_DEBUG === '1';\n\nconst ensureEnv = (value, label) => {\n  if (!value) {\n    throw new Error(`${label} missing. Add it to n8n environment.`);\n  }\n  return value;\n};\n\nensureEnv(HUMANITIX_API_KEY, 'HUMANITIX_API_KEY');\nensureEnv(NOTION_TOKEN, 'NOTION_TOKEN');\nensureEnv(NOTION_EVENTS_DB_ID, 'NOTION_EVENTS_DB_ID');\nensureEnv(NOTION_ORDERS_DB_ID, 'NOTION_ORDERS_DB_ID');\nensureEnv(NOTION_TICKETS_DB_ID, 'NOTION_TICKETS_DB_ID');\n\nconst notionHeaders = {\n  Authorization: `Bearer ${NOTION_TOKEN}`,\n  'Notion-Version': NOTION_VERSION,\n  'Content-Type': 'application/json',\n};\n\nconst wait = async (ms) => new Promise((resolve) => setTimeout(resolve, ms));\nconst throttle = async () => {\n  if (NOTION_THROTTLE_MS > 0) {\n    await wait(NOTION_THROTTLE_MS);\n  }\n};\n\nconst humanitixRequest = async (path, qs = {}) => {\n  return this.helpers.httpRequest({\n    method: 'GET',\n    url: `https://api.humanitix.com/v1${path}`,\n    qs,\n    json: true,\n    headers: {\n      'x-api-key': HUMANITIX_API_KEY,\n    },\n  });\n};\n\nconst notionRequest = async (options) => {\n  try {\n    const response = await this.helpers.httpRequest({\n      ...options,\n      headers: {\n        ...notionHeaders,\n        ...(options.headers || {}),\n      },\n      json: true,\n    });\n    await throttle();\n    return response;\n  } catch (error) {\n    const status = error?.statusCode || error?.response?.status || error?.httpCode;\n    const body = error?.response?.body || error?.error?.body || error?.context?.body;\n    let detail = '';\n    if (body) {\n      if (typeof body === 'string') {\n        detail = body;\n      } else {\n        try {\n          detail = JSON.stringify(body);\n        } catch (jsonErr) {\n          detail = '[unserializable response body]';\n        }\n      }\n    }\n    const method = options?.method || 'REQUEST';\n    const url = options?.url || '';\n    throw new Error(\n      `Notion API ${method} ${url} failed${status ? ` (${status})` : ''}${detail ? `: ${detail}` : ''}`\n    );\n  }\n};\n\nconst truncate = (value, length = 1900) => {\n  if (!value) return value;\n  const text = String(value);\n  return text.length > length ? `${text.substring(0, length)}\u2026` : text;\n};\n\nconst safeNumber = (value) => {\n  if (value === undefined || value === null) return undefined;\n  const num = Number(value);\n  return Number.isNaN(num) ? undefined : num;\n};\n\nconst safeDate = (value) => {\n  if (!value) return undefined;\n  const date = new Date(value);\n  if (Number.isNaN(date.getTime())) return undefined;\n  return date.toISOString();\n};\n\nconst extractList = (response, key) => {\n  if (!response) return [];\n  if (Array.isArray(response)) return response;\n  if (key && Array.isArray(response[key])) return response[key];\n  if (Array.isArray(response?.data)) return response.data;\n  return [];\n};\n\nconst getEventId = (event) => event?._id || event?.id || event?.eventId || null;\nconst getEventName = (event) => event?.name || event?.title || 'Untitled Event';\nconst getEventStatus = (event) => event?.status || event?.state || null;\nconst getEventStart = (event) => event?.startDateTime || event?.startDate || event?.start || event?.start_time || null;\nconst getEventEnd = (event) => event?.endDateTime || event?.endDate || event?.end || event?.end_time || null;\nconst getEventURL = (event) => event?.url || event?.eventUrl || event?.publicUrl || null;\nconst getEventVenue = (event) => event?.venue?.name || event?.venueName || event?.location || null;\nconst getEventTimezone = (event) => event?.timezone || event?.timeZone || null;\n\nconst extractSessions = (event) => {\n  const candidates = [event?.sessions, event?.eventSessions, event?.multiDates, event?.schedule, event?.timeslots];\n  for (const candidate of candidates) {\n    if (Array.isArray(candidate) && candidate.length > 0) return candidate;\n  }\n  return [];\n};\n\nconst getSessionId = (session, eventId, index) => session?._id || session?.id || `${eventId}-session-${index + 1}`;\nconst getSessionName = (session) => session?.name || session?.title || 'Session';\nconst getSessionStatus = (session) => session?.status || session?.state || null;\nconst getSessionStart = (session) =>\n  session?.startDateTime ||\n  session?.startDate ||\n  (session?.start && session?.startTime ? `${session.start}T${session.startTime}` : session?.start) ||\n  null;\nconst getSessionEnd = (session) =>\n  session?.endDateTime ||\n  session?.endDate ||\n  (session?.end && session?.endTime ? `${session.end}T${session.endTime}` : session?.end) ||\n  null;\n\nconst getOrderId = (order) => order?._id || order?.id || order?.orderId || null;\nconst getOrderStatus = (order) => order?.status || order?.financialStatus || null;\nconst getOrderDate = (order) => order?.completedAt || order?.createdAt || order?.purchaseDate || null;\nconst getCustomerName = (order) => {\n  const first = order?.firstName || order?.buyer?.firstName || '';\n  const last = order?.lastName || order?.buyer?.lastName || '';\n  const name = `${first} ${last}`.trim();\n  return name || order?.customerName || order?.buyer?.name || null;\n};\nconst getCustomerEmail = (order) => order?.email || order?.buyer?.email || null;\nconst getCustomerPhone = (order) => order?.mobile || order?.phone || order?.buyer?.phone || null;\n\nconst extractOrderTotals = (order) => {\n  const totals = order?.totals || order?.purchaseTotals || {};\n  return {\n    gross: safeNumber(totals?.grossSales || totals?.gross || totals?.amount),\n    net: safeNumber(totals?.netSales || totals?.net || totals?.netAmount),\n    fees: safeNumber(totals?.fees || totals?.totalFees),\n    discounts: safeNumber(totals?.discounts || order?.discountAmount),\n    discountCode: order?.discounts?.discountCode?.code || order?.discountCode || null,\n  };\n};\n\nconst extractTicketsFromOrder = (order) => {\n  const candidates = [order?.tickets, order?.ticketItems, order?.ticketTypes, order?.items];\n  for (const candidate of candidates) {\n    if (Array.isArray(candidate) && candidate.length > 0) return candidate;\n  }\n  return [];\n};\n\nconst getTicketId = (ticket, orderId, index) =>\n  ticket?._id || ticket?.id || ticket?.ticketId || ticket?.barcode || `${orderId}-ticket-${index + 1}`;\nconst getTicketName = (ticket) => ticket?.name || ticket?.ticketType?.name || ticket?.type || 'Ticket';\nconst getTicketStatus = (ticket) => ticket?.status || ticket?.state || null;\nconst getTicketQuantity = (ticket) => safeNumber(ticket?.quantity || ticket?.qty || 1);\nconst getTicketPrice = (ticket) => safeNumber(ticket?.price || ticket?.amount || ticket?.total || 0);\n\nconst schemaCache = new Map();\nconst missingPropertyWarnings = new Set();\n\nconst loadDatabaseSchema = async (databaseId) => {\n  if (!databaseId) return null;\n  if (schemaCache.has(databaseId)) {\n    return schemaCache.get(databaseId);\n  }\n  const schema = await notionRequest({\n    method: 'GET',\n    url: `https://api.notion.com/v1/databases/${databaseId}`,\n  });\n  schemaCache.set(databaseId, schema);\n  if (IS_DEBUG) {\n    const summary = Object.entries(schema.properties || {})\n      .map(([name, prop]) => `${name} (${prop.type})`)\n      .join(', ');\n    console.log(`Loaded Notion schema for ${databaseId}: ${summary}`);\n  }\n  return schema;\n};\n\nconst matchesType = (actual, expected) => {\n  if (!expected) return true;\n  if (Array.isArray(expected)) return expected.includes(actual);\n  return actual === expected;\n};\n\nconst resolveProperty = (schema, { env, defaultName, expectedType, optional = false, matchRelationTo }) => {\n  if (!schema) return null;\n  let propertyName = env && $env[env] ? $env[env] : defaultName;\n  let property = propertyName ? schema.properties?.[propertyName] : null;\n\n  if (!property && matchRelationTo) {\n    const relationEntry = Object.entries(schema.properties || {}).find(([, prop]) =>\n      prop.type === 'relation' && prop.relation?.database_id === matchRelationTo\n    );\n    if (relationEntry) {\n      [propertyName, property] = relationEntry;\n    }\n  }\n\n  if (!property) {\n    if (optional) {\n      const key = `${schema.id}:${propertyName || env || 'unresolved'}`;\n      if (!missingPropertyWarnings.has(key)) {\n        missingPropertyWarnings.add(key);\n        console.log(\n          `Skipping missing property ${propertyName || defaultName || env || 'unknown'} in database ${\n            schema.id\n          }`\n        );\n      }\n      return null;\n    }\n    const available = Object.entries(schema.properties || {})\n      .map(([name, prop]) => `${name} (${prop.type})`)\n      .join(', ');\n    throw new Error(\n      `Property ${propertyName || defaultName || env || 'unknown'} not found in database ${schema.id}. Available: ${available}`\n    );\n  }\n\n  if (!matchesType(property.type, expectedType)) {\n    if (optional) {\n      const key = `${schema.id}:${propertyName}:type`;\n      if (!missingPropertyWarnings.has(key)) {\n        missingPropertyWarnings.add(key);\n        console.log(\n          `Skipping property ${propertyName} in database ${schema.id} because type ${property.type} did not match expected ${expectedType}`\n        );\n      }\n      return null;\n    }\n    throw new Error(\n      `Property ${propertyName} in database ${schema.id} has type ${property.type}, expected ${expectedType}`\n    );\n  }\n\n  return { name: propertyName, type: property.type, schema: property };\n};\n\nconst getTitleProperty = (schema, envVar) => {\n  if (!schema) return null;\n  const overrideName = envVar && $env[envVar] ? $env[envVar] : null;\n  if (overrideName) {\n    const property = schema.properties?.[overrideName];\n    if (!property) {\n      throw new Error(`Title override ${overrideName} not found in database ${schema.id}`);\n    }\n    if (property.type !== 'title') {\n      throw new Error(`Property ${overrideName} in database ${schema.id} is not a title property`);\n    }\n    return { name: overrideName, type: 'title', schema: property };\n  }\n  const entry = Object.entries(schema.properties || {}).find(([, prop]) => prop.type === 'title');\n  if (!entry) {\n    throw new Error(`No title property found in database ${schema.id}`);\n  }\n  return { name: entry[0], type: 'title', schema: entry[1] };\n};\n\nconst buildPropertyValue = (property, value) => {\n  if (!property) return undefined;\n  if (value === undefined || value === null || value === '') return undefined;\n  switch (property.type) {\n    case 'title':\n      return { title: [{ text: { content: truncate(String(value), 2000) } }] };\n    case 'rich_text':\n      return { rich_text: [{ text: { content: truncate(String(value), 2000) } }] };\n    case 'url':\n      return { url: String(value) };\n    case 'email':\n      return { email: String(value) };\n    case 'phone_number':\n      return { phone_number: String(value) };\n    case 'number': {\n      const num = safeNumber(value);\n      return num === undefined ? undefined : { number: num };\n    }\n    case 'date': {\n      if (typeof value === 'object' && value.start) {\n        return { date: value };\n      }\n      const iso = safeDate(value);\n      return iso ? { date: { start: iso } } : undefined;\n    }\n    case 'select':\n      return { select: { name: truncate(String(value), 100) } };\n    case 'status':\n      return { status: { name: truncate(String(value), 100) } };\n    case 'multi_select': {\n      const values = Array.isArray(value) ? value : [value];\n      const options = values\n        .map((option) => (option ? { name: truncate(String(option), 100) } : null))\n        .filter(Boolean);\n      return options.length ? { multi_select: options } : undefined;\n    }\n    case 'relation': {\n      const ids = Array.isArray(value) ? value : [value];\n      const relation = ids\n        .map((id) => (id ? { id } : null))\n        .filter(Boolean);\n      return relation.length ? { relation } : undefined;\n    }\n    default:\n      return undefined;\n  }\n};\n\nconst setProperty = (properties, property, value) => {\n  if (!property) return;\n  const propertyValue = buildPropertyValue(property, value);\n  if (propertyValue !== undefined) {\n    properties[property.name] = propertyValue;\n  }\n};\n\nconst buildUniqueFilter = (property, value) => {\n  if (!property) throw new Error('Unique property metadata missing');\n  const stringValue = value === undefined || value === null ? '' : String(value);\n  switch (property.type) {\n    case 'title':\n      return { property: property.name, title: { equals: stringValue } };\n    case 'rich_text':\n      return { property: property.name, rich_text: { equals: stringValue } };\n    case 'number': {\n      const num = safeNumber(value);\n      if (num === undefined) {\n        throw new Error(`Unique property ${property.name} expected a numeric value`);\n      }\n      return { property: property.name, number: { equals: num } };\n    }\n    case 'url':\n      return { property: property.name, url: { equals: stringValue } };\n    case 'email':\n      return { property: property.name, email: { equals: stringValue } };\n    case 'phone_number':\n      return { property: property.name, phone_number: { equals: stringValue } };\n    case 'select':\n      return { property: property.name, select: { equals: stringValue } };\n    case 'status':\n      return { property: property.name, status: { equals: stringValue } };\n    default:\n      throw new Error(`Unsupported unique property type ${property.type} for ${property.name}`);\n  }\n};\n\nconst upsertNotionPage = async (databaseId, uniqueProperty, uniqueValue, properties) => {\n  if (!uniqueProperty) {\n    throw new Error(`Cannot upsert into ${databaseId} without a unique property`);\n  }\n  if (uniqueValue === undefined || uniqueValue === null || uniqueValue === '') {\n    throw new Error(`Cannot upsert into ${databaseId}: missing unique value for ${uniqueProperty.name}`);\n  }\n\n  const filter = buildUniqueFilter(uniqueProperty, uniqueValue);\n  const queryResponse = await notionRequest({\n    method: 'POST',\n    url: `https://api.notion.com/v1/databases/${databaseId}/query`,\n    body: {\n      filter,\n      page_size: 1,\n    },\n  });\n\n  const existing = queryResponse.results?.[0];\n  if (existing) {\n    await notionRequest({\n      method: 'PATCH',\n      url: `https://api.notion.com/v1/pages/${existing.id}`,\n      body: { properties },\n    });\n    return existing.id;\n  }\n\n  const created = await notionRequest({\n    method: 'POST',\n    url: 'https://api.notion.com/v1/pages',\n    body: {\n      parent: { database_id: databaseId },\n      properties,\n    },\n  });\n  return created.id;\n};\n\nconst prepareEventsConfig = async () => {\n  const schema = await loadDatabaseSchema(NOTION_EVENTS_DB_ID);\n  const title = getTitleProperty(schema, 'NOTION_EVENTS_TITLE_PROP');\n  const eventName = resolveProperty(schema, {\n    env: 'NOTION_EVENTS_NAME_PROP',\n    defaultName: 'Event Name',\n    expectedType: ['title', 'rich_text'],\n    optional: true,\n  });\n  const status = resolveProperty(schema, {\n    env: 'NOTION_EVENTS_STATUS_PROP',\n    defaultName: 'Status',\n    expectedType: ['select', 'status'],\n    optional: true,\n  });\n  const start = resolveProperty(schema, {\n    env: 'NOTION_EVENTS_START_PROP',\n    defaultName: 'Start Date',\n    expectedType: 'date',\n    optional: true,\n  });\n  const end = resolveProperty(schema, {\n    env: 'NOTION_EVENTS_END_PROP',\n    defaultName: 'End Date',\n    expectedType: 'date',\n    optional: true,\n  });\n  const url = resolveProperty(schema, {\n    env: 'NOTION_EVENTS_URL_PROP',\n    defaultName: 'URL',\n    expectedType: 'url',\n    optional: true,\n  });\n  const venue = resolveProperty(schema, {\n    env: 'NOTION_EVENTS_VENUE_PROP',\n    defaultName: 'Venue Name',\n    expectedType: ['rich_text', 'title'],\n    optional: true,\n  });\n  const timezone = resolveProperty(schema, {\n    env: 'NOTION_EVENTS_TIMEZONE_PROP',\n    defaultName: 'Timezone',\n    expectedType: ['rich_text', 'title'],\n    optional: true,\n  });\n  return { schema, title, eventName, status, start, end, url, venue, timezone };\n};\n\nconst prepareSessionsConfig = async (eventsConfig) => {\n  if (!NOTION_SESSIONS_DB_ID) return null;\n  const schema = await loadDatabaseSchema(NOTION_SESSIONS_DB_ID);\n  const title = getTitleProperty(schema, 'NOTION_SESSIONS_TITLE_PROP');\n  const displayName = resolveProperty(schema, {\n    env: 'NOTION_SESSIONS_NAME_PROP',\n    defaultName: 'Session Name',\n    expectedType: ['rich_text', 'title'],\n    optional: true,\n  });\n  const sessionIdProp = resolveProperty(schema, {\n    env: 'NOTION_SESSIONS_ID_PROP',\n    defaultName: 'Session ID',\n    expectedType: ['rich_text', 'title'],\n    optional: true,\n  });\n  const start = resolveProperty(schema, {\n    env: 'NOTION_SESSIONS_START_PROP',\n    defaultName: 'Start Date',\n    expectedType: 'date',\n    optional: true,\n  });\n  const end = resolveProperty(schema, {\n    env: 'NOTION_SESSIONS_END_PROP',\n    defaultName: 'End Date',\n    expectedType: 'date',\n    optional: true,\n  });\n  const status = resolveProperty(schema, {\n    env: 'NOTION_SESSIONS_STATUS_PROP',\n    defaultName: 'Status',\n    expectedType: ['select', 'status'],\n    optional: true,\n  });\n  const eventRelation = resolveProperty(schema, {\n    env: 'NOTION_SESSIONS_EVENT_PROP',\n    matchRelationTo: eventsConfig?.schema?.id,\n    expectedType: 'relation',\n    optional: true,\n  });\n  return { schema, title, displayName, sessionIdProp, start, end, status, eventRelation };\n};\n\nconst prepareOrdersConfig = async (eventsConfig) => {\n  const schema = await loadDatabaseSchema(NOTION_ORDERS_DB_ID);\n  const title = getTitleProperty(schema, 'NOTION_ORDERS_TITLE_PROP');\n  const status = resolveProperty(schema, {\n    env: 'NOTION_ORDERS_STATUS_PROP',\n    defaultName: 'Status',\n    expectedType: ['select', 'status'],\n    optional: true,\n  });\n  const eventRelation = resolveProperty(schema, {\n    env: 'NOTION_ORDERS_EVENT_PROP',\n    matchRelationTo: eventsConfig?.schema?.id,\n    expectedType: 'relation',\n    optional: true,\n  });\n  const customerName = resolveProperty(schema, {\n    env: 'NOTION_ORDERS_CUSTOMER_PROP',\n    defaultName: 'Customer Name',\n    expectedType: ['rich_text', 'title'],\n    optional: true,\n  });\n  const email = resolveProperty(schema, {\n    env: 'NOTION_ORDERS_EMAIL_PROP',\n    defaultName: 'Email',\n    expectedType: 'email',\n    optional: true,\n  });\n  const phone = resolveProperty(schema, {\n    env: 'NOTION_ORDERS_PHONE_PROP',\n    defaultName: 'Phone',\n    expectedType: 'phone_number',\n    optional: true,\n  });\n  const gross = resolveProperty(schema, {\n    env: 'NOTION_ORDERS_GROSS_PROP',\n    defaultName: 'Gross Amount',\n    expectedType: 'number',\n    optional: true,\n  });\n  const net = resolveProperty(schema, {\n    env: 'NOTION_ORDERS_NET_PROP',\n    defaultName: 'Net Amount',\n    expectedType: 'number',\n    optional: true,\n  });\n  const fees = resolveProperty(schema, {\n    env: 'NOTION_ORDERS_FEES_PROP',\n    defaultName: 'Fees',\n    expectedType: 'number',\n    optional: true,\n  });\n  const discountAmount = resolveProperty(schema, {\n    env: 'NOTION_ORDERS_DISCOUNT_PROP',\n    defaultName: 'Discount Amount',\n    expectedType: 'number',\n    optional: true,\n  });\n  const discountCode = resolveProperty(schema, {\n    env: 'NOTION_ORDERS_CODE_PROP',\n    defaultName: 'Discount Code',\n    expectedType: ['rich_text', 'select'],\n    optional: true,\n  });\n  const orderDate = resolveProperty(schema, {\n    env: 'NOTION_ORDERS_DATE_PROP',\n    defaultName: 'Order Date',\n    expectedType: 'date',\n    optional: true,\n  });\n  const paymentMethod = resolveProperty(schema, {\n    env: 'NOTION_ORDERS_PAYMENT_PROP',\n    defaultName: 'Payment Method',\n    expectedType: ['rich_text', 'select'],\n    optional: true,\n  });\n  return {\n    schema,\n    title,\n    status,\n    eventRelation,\n    customerName,\n    email,\n    phone,\n    gross,\n    net,\n    fees,\n    discountAmount,\n    discountCode,\n    orderDate,\n    paymentMethod,\n  };\n};\n\nconst prepareTicketsConfig = async (eventsConfig, ordersConfig) => {\n  const schema = await loadDatabaseSchema(NOTION_TICKETS_DB_ID);\n  const title = getTitleProperty(schema, 'NOTION_TICKETS_TITLE_PROP');\n  const eventRelation = resolveProperty(schema, {\n    env: 'NOTION_TICKETS_EVENT_PROP',\n    matchRelationTo: eventsConfig?.schema?.id,\n    expectedType: 'relation',\n    optional: true,\n  });\n  const orderRelation = resolveProperty(schema, {\n    env: 'NOTION_TICKETS_ORDER_PROP',\n    matchRelationTo: ordersConfig?.schema?.id,\n    expectedType: 'relation',\n    optional: true,\n  });\n  const ticketType = resolveProperty(schema, {\n    env: 'NOTION_TICKETS_TYPE_PROP',\n    defaultName: 'Ticket Type',\n    expectedType: ['rich_text', 'select'],\n    optional: true,\n  });\n  const status = resolveProperty(schema, {\n    env: 'NOTION_TICKETS_STATUS_PROP',\n    defaultName: 'Status',\n    expectedType: ['select', 'status'],\n    optional: true,\n  });\n  const quantity = resolveProperty(schema, {\n    env: 'NOTION_TICKETS_QUANTITY_PROP',\n    defaultName: 'Quantity',\n    expectedType: 'number',\n    optional: true,\n  });\n  const price = resolveProperty(schema, {\n    env: 'NOTION_TICKETS_PRICE_PROP',\n    defaultName: 'Price',\n    expectedType: 'number',\n    optional: true,\n  });\n  const barcode = resolveProperty(schema, {\n    env: 'NOTION_TICKETS_BARCODE_PROP',\n    defaultName: 'Barcode',\n    expectedType: ['rich_text', 'title'],\n    optional: true,\n  });\n  return {\n    schema,\n    title,\n    eventRelation,\n    orderRelation,\n    ticketType,\n    status,\n    quantity,\n    price,\n    barcode,\n  };\n};\n\nconst eventsConfig = await prepareEventsConfig();\nconst sessionsConfig = await prepareSessionsConfig(eventsConfig);\nconst ordersConfig = await prepareOrdersConfig(eventsConfig);\nconst ticketsConfig = await prepareTicketsConfig(eventsConfig, ordersConfig);\n\nconst buildEventProperties = (event) => {\n  const properties = {};\n  const eventId = getEventId(event);\n  const eventName = getEventName(event);\n  const status = getEventStatus(event);\n  const start = safeDate(getEventStart(event));\n  const end = safeDate(getEventEnd(event));\n  const url = getEventURL(event);\n  const venue = getEventVenue(event);\n  const timezone = getEventTimezone(event);\n\n  setProperty(properties, eventsConfig.title, eventId || eventName);\n  setProperty(properties, eventsConfig.eventName, eventName);\n  setProperty(properties, eventsConfig.status, status);\n  setProperty(properties, eventsConfig.start, start);\n  setProperty(properties, eventsConfig.end, end);\n  setProperty(properties, eventsConfig.url, url);\n  setProperty(properties, eventsConfig.venue, venue);\n  setProperty(properties, eventsConfig.timezone, timezone);\n\n  return properties;\n};\n\nconst buildSessionProperties = (session, sessionId, eventPageId) => {\n  if (!sessionsConfig) return null;\n  const properties = {};\n  const name = getSessionName(session);\n  const status = getSessionStatus(session);\n  const start = safeDate(getSessionStart(session));\n  const end = safeDate(getSessionEnd(session));\n\n  setProperty(properties, sessionsConfig.title, sessionId);\n  setProperty(properties, sessionsConfig.displayName, name);\n  setProperty(properties, sessionsConfig.sessionIdProp, sessionId);\n  setProperty(properties, sessionsConfig.status, status);\n  setProperty(properties, sessionsConfig.start, start);\n  setProperty(properties, sessionsConfig.end, end);\n  setProperty(properties, sessionsConfig.eventRelation, eventPageId ? [eventPageId] : undefined);\n\n  return properties;\n};\n\nconst buildOrderProperties = (order, eventPageId) => {\n  const properties = {};\n  const orderId = getOrderId(order);\n  const status = getOrderStatus(order);\n  const orderDate = safeDate(getOrderDate(order));\n  const customerName = getCustomerName(order);\n  const customerEmail = getCustomerEmail(order);\n  const customerPhone = getCustomerPhone(order);\n  const totals = extractOrderTotals(order);\n\n  setProperty(properties, ordersConfig.title, orderId);\n  setProperty(properties, ordersConfig.status, status);\n  setProperty(properties, ordersConfig.eventRelation, eventPageId ? [eventPageId] : undefined);\n  setProperty(properties, ordersConfig.customerName, customerName);\n  setProperty(properties, ordersConfig.email, customerEmail);\n  setProperty(properties, ordersConfig.phone, customerPhone);\n  setProperty(properties, ordersConfig.orderDate, orderDate);\n  setProperty(properties, ordersConfig.gross, totals.gross);\n  setProperty(properties, ordersConfig.net, totals.net);\n  setProperty(properties, ordersConfig.fees, totals.fees);\n  setProperty(properties, ordersConfig.discountAmount, totals.discounts);\n  setProperty(properties, ordersConfig.discountCode, totals.discountCode);\n  setProperty(properties, ordersConfig.paymentMethod, order?.paymentMethod);\n\n  return properties;\n};\n\nconst buildTicketProperties = (ticket, ticketId, eventPageId, orderPageId) => {\n  const properties = {};\n  const name = getTicketName(ticket);\n  const status = getTicketStatus(ticket);\n  const quantity = getTicketQuantity(ticket);\n  const price = getTicketPrice(ticket);\n\n  setProperty(properties, ticketsConfig.title, ticketId || name);\n  setProperty(properties, ticketsConfig.ticketType, ticket?.ticketType?.name || ticket?.type || name);\n  setProperty(properties, ticketsConfig.status, status);\n  setProperty(properties, ticketsConfig.quantity, quantity);\n  setProperty(properties, ticketsConfig.price, price);\n  setProperty(properties, ticketsConfig.barcode, ticket?.barcode);\n  setProperty(properties, ticketsConfig.eventRelation, eventPageId ? [eventPageId] : undefined);\n  setProperty(properties, ticketsConfig.orderRelation, orderPageId ? [orderPageId] : undefined);\n\n  return properties;\n};\n\nconst summary = {\n  eventsProcessed: 0,\n  sessionsProcessed: 0,\n  ordersProcessed: 0,\n  ticketsProcessed: 0,\n  errors: [],\n};\n\nlet page = 1;\nlet hasMoreEvents = true;\n\nwhile (hasMoreEvents) {\n  let eventsResponse;\n  try {\n    eventsResponse = await humanitixRequest('/events', { page, pageSize: HUMANITIX_PAGE_SIZE });\n  } catch (error) {\n    summary.errors.push(`Failed to fetch events page ${page}: ${error.message || error}`);\n    break;\n  }\n\n  const events = extractList(eventsResponse, 'events');\n  if (!events.length) {\n    break;\n  }\n\n  for (const event of events) {\n    const eventId = getEventId(event);\n    if (!eventId) {\n      summary.errors.push('Skipped event without ID');\n      continue;\n    }\n\n    if (IS_DEBUG) {\n      console.log(`Processing event ${eventId}`);\n    }\n\n    let detailedEvent = event;\n    try {\n      detailedEvent = await humanitixRequest(`/events/${eventId}`);\n    } catch (error) {\n      summary.errors.push(`Failed to fetch detail for event ${eventId}: ${error.message || error}`);\n    }\n\n    let eventPageId;\n    try {\n      const properties = buildEventProperties(detailedEvent);\n      eventPageId = await upsertNotionPage(\n        NOTION_EVENTS_DB_ID,\n        eventsConfig.title,\n        getEventId(detailedEvent) || getEventName(detailedEvent),\n        properties\n      );\n      summary.eventsProcessed += 1;\n    } catch (error) {\n      summary.errors.push(`Notion upsert failed for event ${eventId}: ${error.message || error}`);\n      continue;\n    }\n\n    if (sessionsConfig) {\n      const sessions = extractSessions(detailedEvent);\n      for (let index = 0; index < sessions.length; index++) {\n        const session = sessions[index];\n        const sessionId = getSessionId(session, eventId, index);\n        if (!sessionId) continue;\n        try {\n          const properties = buildSessionProperties(session, sessionId, eventPageId);\n          if (!properties) continue;\n          await upsertNotionPage(\n            NOTION_SESSIONS_DB_ID,\n            sessionsConfig.title,\n            sessionId,\n            properties\n          );\n          summary.sessionsProcessed += 1;\n        } catch (error) {\n          summary.errors.push(`Notion upsert failed for session ${sessionId}: ${error.message || error}`);\n        }\n      }\n    }\n\n    const orders = [];\n    let ordersPage = 1;\n    let hasMoreOrders = true;\n\n    while (hasMoreOrders) {\n      let orderResponse;\n      try {\n        orderResponse = await humanitixRequest(`/events/${eventId}/orders`, {\n          page: ordersPage,\n          pageSize: HUMANITIX_PAGE_SIZE,\n        });\n      } catch (error) {\n        summary.errors.push(`Failed to fetch orders for event ${eventId} page ${ordersPage}: ${error.message || error}`);\n        break;\n      }\n\n      const pageOrders = extractList(orderResponse, 'orders');\n      if (!pageOrders.length) {\n        hasMoreOrders = false;\n      } else {\n        orders.push(...pageOrders);\n        ordersPage += 1;\n        const more = Boolean(orderResponse?.pagination?.has_next_page) || pageOrders.length === HUMANITIX_PAGE_SIZE;\n        hasMoreOrders = more;\n      }\n\n      if (ordersPage > 100) {\n        summary.errors.push(`Stopping order pagination for event ${eventId} after 100 pages`);\n        break;\n      }\n    }\n\n    for (const order of orders) {\n      const orderId = getOrderId(order);\n      if (!orderId) {\n        summary.errors.push(`Skipped order without ID for event ${eventId}`);\n        continue;\n      }\n\n      let orderPageId;\n      try {\n        const properties = buildOrderProperties(order, eventPageId);\n        orderPageId = await upsertNotionPage(\n          NOTION_ORDERS_DB_ID,\n          ordersConfig.title,\n          orderId,\n          properties\n        );\n        summary.ordersProcessed += 1;\n      } catch (error) {\n        summary.errors.push(`Notion upsert failed for order ${orderId}: ${error.message || error}`);\n        continue;\n      }\n\n      const orderTickets = extractTicketsFromOrder(order);\n      for (let index = 0; index < orderTickets.length; index++) {\n        const ticket = orderTickets[index];\n        const ticketId = getTicketId(ticket, orderId, index);\n        if (!ticketId) continue;\n        try {\n          const properties = buildTicketProperties(ticket, ticketId, eventPageId, orderPageId);\n          await upsertNotionPage(\n            NOTION_TICKETS_DB_ID,\n            ticketsConfig.title,\n            ticketId,\n            properties\n          );\n          summary.ticketsProcessed += 1;\n        } catch (error) {\n          summary.errors.push(`Notion upsert failed for order ticket ${ticketId}: ${error.message || error}`);\n        }\n      }\n    }\n\n    try {\n      const eventTicketsResponse = await humanitixRequest(`/events/${eventId}/tickets`, {\n        pageSize: HUMANITIX_PAGE_SIZE,\n      });\n      const eventTickets = extractList(eventTicketsResponse, 'tickets');\n      for (let index = 0; index < eventTickets.length; index++) {\n        const ticket = eventTickets[index];\n        const ticketId = getTicketId(ticket, `${eventId}-event`, index);\n        if (!ticketId) continue;\n        try {\n          const properties = buildTicketProperties(ticket, ticketId, eventPageId, null);\n          await upsertNotionPage(\n            NOTION_TICKETS_DB_ID,\n            ticketsConfig.title,\n            ticketId,\n            properties\n          );\n          summary.ticketsProcessed += 1;\n        } catch (error) {\n          summary.errors.push(`Notion upsert failed for event ticket ${ticketId}: ${error.message || error}`);\n        }\n      }\n    } catch (error) {\n      summary.errors.push(`Failed to fetch event-level tickets for ${eventId}: ${error.message || error}`);\n    }\n  }\n\n  const moreEvents = Boolean(eventsResponse?.pagination?.has_next_page) || events.length === HUMANITIX_PAGE_SIZE;\n  hasMoreEvents = moreEvents;\n  page += 1;\n\n  if (page > 100) {\n    summary.errors.push('Stopping event pagination after 100 pages');\n    break;\n  }\n}\n\nreturn [{ json: summary }];\n"
      }
    }
  ],
  "connections": {
    "schedule-trigger": {
      "main": [
        [
          {
            "node": "Sync Humanitix \u2192 Notion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "regular"
  }
}