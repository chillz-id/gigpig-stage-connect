{
  "name": "Eventbrite Webhook (Complete - All Events)",
  "nodes": [
    {
      "parameters": {
        "path": "eventbrite/complete",
        "httpMethod": "POST",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "webhook-trigger-complete",
      "name": "Eventbrite Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        240,
        300
      ],
      "webhookId": "eventbrite-webhook-complete"
    },
    {
      "parameters": {
        "jsCode": "async function run() {\n  const readEnv = async (key) => {\n    if (typeof $env !== 'undefined' && $env && Object.prototype.hasOwnProperty.call($env, key)) {\n      const value = $env[key];\n      if (value !== undefined && value !== null && String(value).trim() !== '') {\n        return String(value).trim();\n      }\n    }\n    if (typeof process !== 'undefined' && process.env && Object.prototype.hasOwnProperty.call(process.env, key)) {\n      const value = process.env[key];\n      if (value !== undefined && value !== null && String(value).trim() !== '') {\n        return String(value).trim();\n      }\n    }\n    return '';\n  };\n\n  const FALLBACK_EVENTBRITE_TOKEN = 'KPGTS46ZFV2ECF7QUZKE';\n  const FALLBACK_EVENTBRITE_ORG_ID = '276710097137';\n  const FALLBACK_SUPABASE_URL = 'https://pdikjpfulhhpqpxzpgtu.supabase.co';\n  const FALLBACK_SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBkaWtqcGZ1bGhocHFweHpwZ3R1Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1MDI2Njg2MSwiZXhwIjoyMDY1ODQyODYxfQ.RS6RG0nbmxEqtO99dnpGnd7WV7C_uI0l_XJugKqOzPE';\n\n  const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\n  const requestWithRetry = async (options, attempt = 0) => {\n    try {\n      return await this.helpers.httpRequest({ ...options, json: true });\n    } catch (error) {\n      const status = Number(error.statusCode ?? error.response?.status ?? error.response?.statusCode ?? error.code ?? 0);\n      const isRetryable = [408, 429, 500, 502, 503, 504].includes(status);\n      if (attempt < 4 && isRetryable) {\n        const delay = Math.min(2000 * (attempt + 1), 10000);\n        await sleep(delay);\n        return requestWithRetry(options, attempt + 1);\n      }\n      throw error;\n    }\n  };\n\n  const loadEventbriteToken = async () => {\n    const envKeys = ['EVENTBRITE_PRIVATE_TOKEN', 'EVENTBRITE_OAUTH_TOKEN', 'EVENTBRITE_API_KEY', 'EVENTBRITE_TOKEN'];\n    for (const envKey of envKeys) {\n      const value = await readEnv(envKey);\n      if (value) {\n        return value;\n      }\n    }\n\n    const credentialCandidates = ['eventbriteApi', 'eventbriteOAuth2Api', 'eventbriteOAuth2', 'httpHeaderAuth'];\n    for (const name of credentialCandidates) {\n      try {\n        const creds = await this.getCredentials(name);\n        if (!creds) continue;\n        const candidate = creds.accessToken ?? creds.apiKey ?? creds.token ?? creds.headerValue ?? creds.key ?? null;\n        if (candidate && String(candidate).trim() !== '') {\n          return String(candidate).trim();\n        }\n      } catch (error) {\n        const message = error?.message ?? '';\n        if (!/not set/i.test(message) && !/does not exist/i.test(message)) {\n          console.warn('Eventbrite credential ' + name + ' lookup failed:', message || error);\n        }\n      }\n    }\n\n    if (FALLBACK_EVENTBRITE_TOKEN) {\n      const fallback = String(FALLBACK_EVENTBRITE_TOKEN).trim();\n      if (fallback) {\n        console.warn('Using fallback Eventbrite token from workflow.');\n        return fallback;\n      }\n    }\n\n    throw new Error('Missing Eventbrite credentials (set EVENTBRITE_API_KEY or attach an Eventbrite credential in n8n).');\n  };\n\n    const loadSupabaseConfig = async () => {\n    let url = await readEnv('SUPABASE_URL');\n    if (!url) {\n      url = await readEnv('SUPABASE_REST_URL');\n    }\n    let key = await readEnv('SUPABASE_SERVICE_ROLE_KEY');\n    if (!key) {\n      key = await readEnv('SUPABASE_SERVICE_KEY');\n    }\n\n    if (!url || !key) {\n      const credentialCandidates = ['supabaseApi', 'supabaseDatabase', 'supabaseServiceRole', 'httpHeaderAuth'];\n      for (const name of credentialCandidates) {\n        try {\n          const creds = await this.getCredentials(name);\n          if (!creds) continue;\n          if (!url) {\n            const candidateUrl = creds.url ?? creds.host ?? creds.restUrl ?? creds.restApiUrl ?? creds.endpoint ?? creds.baseUrl ?? '';\n            if (candidateUrl && String(candidateUrl).trim() !== '') {\n              url = String(candidateUrl).trim();\n            }\n          }\n          if (!key) {\n            const candidateKey = creds.serviceRoleKey ?? creds.apiKey ?? creds.serviceRoleSecret ?? creds.token ?? creds.key ?? creds.headerValue ?? '';\n            if (candidateKey && String(candidateKey).trim() !== '') {\n              key = String(candidateKey).trim();\n            }\n          }\n          if (url && key) {\n            break;\n          }\n        } catch (error) {\n          const message = error?.message ?? '';\n          if (!/not set/i.test(message) && !/does not exist/i.test(message)) {\n            console.warn('Supabase credential ' + name + ' lookup failed:', message || error);\n          }\n        }\n      }\n    }\n\n    if (!url && FALLBACK_SUPABASE_URL) {\n      url = FALLBACK_SUPABASE_URL;\n      console.warn('Using fallback Supabase URL from workflow.');\n    }\n    if (!key && FALLBACK_SUPABASE_KEY) {\n      key = FALLBACK_SUPABASE_KEY;\n      console.warn('Using fallback Supabase key from workflow.');\n    }\n\n    if (!url || !key) {\n      throw new Error('Missing Supabase credentials (set SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY in n8n or attach a Supabase credential).');\n    }\n\n    return {\n      url: String(url).trim().replace(/\\/$/, ''),\n      key: String(key).trim(),\n    };\n  };\n\n  const parseCents = (value) => {\n    if (value === undefined || value === null || value === '') return null;\n    const num = Number(value);\n    if (Number.isNaN(num)) {\n      const parsed = Number.parseFloat(String(value));\n      if (Number.isNaN(parsed)) return null;\n      return Math.round(parsed);\n    }\n    return Math.round(num);\n  };\n\n  const centsOrZero = (value) => {\n    const result = parseCents(value);\n    return result === null ? 0 : result;\n  };\n\n  const toIso = (value) => {\n    if (!value) return null;\n    const date = new Date(value);\n    if (Number.isNaN(date.getTime())) return null;\n    return date.toISOString();\n  };\n\n  const mapOrderRecord = (order, ingestedAt) => {\n    if (!order?.id) return null;\n    const costs = order.costs ?? {};\n    const gross = parseCents(costs.gross?.value);\n    const fees = centsOrZero(costs.eventbrite_fee?.value) + centsOrZero(costs.payment_fee?.value);\n    const taxes = centsOrZero(costs.tax?.value);\n    const net = gross === null ? null : Math.max(gross - fees - taxes, 0);\n    const base = parseCents(costs.base_price?.value);\n    const discount = parseCents(costs.discount?.value);\n    const currency = costs.gross?.currency ?? costs.base_price?.currency ?? null;\n    const fallbackPurchaserName = [order.first_name, order.last_name]\n      .filter(Boolean)\n      .join(' ')\n      .trim();\n    const purchaserNameRaw = order.name ?? (fallbackPurchaserName.length ? fallbackPurchaserName : null);\n    const purchaserName = purchaserNameRaw && purchaserNameRaw.length ? purchaserNameRaw : null;\n    const eventId = order.event_id ?? order.event?.id ?? null;\n\n    return {\n      source: 'eventbrite',\n      source_id: order.id,\n      event_source_id: eventId,\n      session_source_id: eventId,\n      status: order.status ?? null,\n      financial_status: order.payment_status ?? order.status ?? null,\n      total_cents: gross,\n      subtotal_cents: base,\n      net_sales_cents: net,\n      gross_sales_cents: gross,\n      discounts_cents: discount,\n      taxes_cents: taxes,\n      fees_cents: fees || null,\n      purchaser_email: order.email ?? order.profile?.email ?? null,\n      purchaser_name: purchaserName,\n      ordered_at: toIso(order.created),\n      updated_at: toIso(order.changed),\n      currency,\n      additional_fields: Array.isArray(order.attendees) && order.attendees.length ? order.attendees : null,\n      raw: order,\n      ingested_at: ingestedAt,\n      updated_at_api: toIso(order.changed),\n    };\n  };\n\n  const normalizeStatus = (attendee) => {\n    if (!attendee) return null;\n    if (attendee.checked_in === true) return 'checked_in';\n    if (attendee.cancelled) return 'cancelled';\n    if (attendee.refunded) return 'refunded';\n    return attendee.status ?? null;\n  };\n\n  const mapAttendeeRecord = (attendee, ingestedAt) => {\n    if (!attendee?.id) return null;\n    const costs = attendee.costs ?? {};\n    const gross = parseCents(costs.gross?.value);\n    const base = parseCents(costs.base_price?.value);\n    const taxes = parseCents(costs.tax?.value);\n    const fees = centsOrZero(costs.eventbrite_fee?.value) + centsOrZero(costs.payment_fee?.value);\n    const discount = parseCents(costs.discount?.value);\n    const passed = parseCents(costs.passed_on_fee?.value);\n    const absorbed = parseCents(costs.absorbed_fee?.value);\n    const donation = parseCents(costs.donation?.value ?? costs.dgr_donation?.value);\n    const currency = costs.gross?.currency ?? costs.base_price?.currency ?? null;\n    const profile = attendee.profile ?? {};\n    const eventId = attendee.event_id ?? attendee.event?.id ?? null;\n    const profileNameParts = typeof profile.name === 'string' ? profile.name.trim().split(/\\s+/) : [];\n    const fallbackFirstName = profileNameParts.length ? profileNameParts[0] : null;\n    const fallbackLastNamePart = profileNameParts.length > 1 ? profileNameParts.slice(1).join(' ').trim() : null;\n\n    return {\n      source: 'eventbrite',\n      source_id: attendee.id,\n      order_source_id: attendee.order_id ?? null,\n      event_source_id: eventId,\n      session_source_id: eventId,\n      ticket_type_id: attendee.ticket_class_id ?? null,\n      ticket_type_name: attendee.ticket_class_name ?? null,\n      status: normalizeStatus(attendee),\n      total_cents: gross,\n      net_price_cents: base,\n      price_cents: base,\n      discount_cents: discount,\n      taxes_cents: taxes,\n      fee_cents: fees || null,\n      passed_on_fee_cents: passed,\n      absorbed_fee_cents: absorbed,\n      dgr_donation_cents: donation,\n      currency,\n      first_name: profile.first_name ?? (fallbackFirstName ?? null),\n      last_name: profile.last_name ?? (fallbackLastNamePart ?? null),\n      email: profile.email ?? attendee.email ?? null,\n      created_at: toIso(attendee.created),\n      updated_at: toIso(attendee.changed),\n      raw: attendee,\n      ingested_at: ingestedAt,\n      updated_at_api: toIso(attendee.changed),\n    };\n  };\n\n  const upsertSupabaseRows = async (supabase, table, rows) => {\n    const payload = rows.filter(Boolean);\n    if (!payload.length) return;\n    await requestWithRetry({\n      method: 'POST',\n      url: `${supabase.url}/rest/v1/${table}?on_conflict=source_id`,\n      headers: {\n        apikey: supabase.key,\n        Authorization: `Bearer ${supabase.key}`,\n        'Content-Type': 'application/json',\n        Prefer: 'resolution=merge-duplicates',\n      },\n      body: payload,\n    });\n  };\n\n  const fetchOrder = async (token, url, fallbackOrderId) => {\n    let endpoint = url ?? '';\n    if (!endpoint && fallbackOrderId) {\n      endpoint = `https://www.eventbriteapi.com/v3/orders/${fallbackOrderId}/`;\n    }\n    if (!endpoint) {\n      throw new Error('Unable to resolve Eventbrite order API URL.');\n    }\n    return requestWithRetry({\n      method: 'GET',\n      url: endpoint,\n      qs: { expand: 'attendees,attendees.profile,attendees.costs,attendees.promotional_code,event,event.ticket_classes,event.venue,event.category,event.subcategory,event.format,event.organizer' },\n      headers: {\n        Authorization: `Bearer ${token}`,\n        'Content-Type': 'application/json',\n      },\n    });\n  };\n\n  const fetchAttendee = async (token, url, attendeeId, eventId) => {\n    let endpoint = url ?? '';\n    if (!endpoint && attendeeId && eventId) {\n      endpoint = `https://www.eventbriteapi.com/v3/events/${eventId}/attendees/${attendeeId}/`;\n    }\n    if (!endpoint) {\n      throw new Error('Unable to resolve Eventbrite attendee API URL.');\n    }\n    return requestWithRetry({\n      method: 'GET',\n      url: endpoint,\n      qs: { expand: 'profile,costs,promotional_code,event,event.ticket_classes,event.venue' },\n      headers: {\n        Authorization: `Bearer ${token}`,\n        'Content-Type': 'application/json',\n      },\n    });\n  };\n\n  const fetchEvent = async (token, url, fallbackEventId) => {\n    let endpoint = url ?? '';\n    if (!endpoint && fallbackEventId) {\n      endpoint = `https://www.eventbriteapi.com/v3/events/${fallbackEventId}/`;\n    }\n    if (!endpoint) {\n      throw new Error('Unable to resolve Eventbrite event API URL.');\n    }\n    return requestWithRetry({\n      method: 'GET',\n      url: endpoint,\n      qs: { expand: 'ticket_classes,venue,category,subcategory,format,organizer,series' },\n      headers: {\n        Authorization: `Bearer ${token}`,\n        'Content-Type': 'application/json',\n      },\n    });\n  };\n\n  const fetchEventOrders = async (token, eventId) => {\n    if (!eventId) return [];\n    try {\n      const response = await requestWithRetry({\n        method: 'GET',\n        url: `https://www.eventbriteapi.com/v3/events/${eventId}/orders/`,\n        qs: { expand: 'attendees,attendees.profile,attendees.costs,event,event.ticket_classes,event.venue,event.category,event.format' },\n        headers: {\n          Authorization: `Bearer ${token}`,\n          'Content-Type': 'application/json',\n        },\n      });\n      return response.orders ?? [];\n    } catch (error) {\n      console.warn(`Failed to fetch orders for event ${eventId}:`, error.message);\n      return [];\n    }\n  };\n\n  // ========================================\n  // EVENT HANDLERS\n  // ========================================\n\n  const handleOrderEvent = async (token, supabase, payload, ingestedAt) => {\n    const order = await fetchOrder(token, payload.api_url, payload.resource?.order_id ?? payload.order_id ?? payload.id ?? null);\n    const orderRecord = mapOrderRecord(order, ingestedAt);\n    const attendeeRecords = Array.isArray(order.attendees)\n      ? order.attendees.map((att) => mapAttendeeRecord(att, ingestedAt)).filter(Boolean)\n      : [];\n\n    await upsertSupabaseRows(supabase, 'orders_eventbrite', orderRecord ? [orderRecord] : []);\n    if (attendeeRecords.length) {\n      await upsertSupabaseRows(supabase, 'tickets_eventbrite', attendeeRecords);\n    }\n\n    return {\n      processedOrders: orderRecord ? 1 : 0,\n      processedTickets: attendeeRecords.length,\n      eventName: order.event?.name?.text ?? null,\n      eventStart: order.event?.start?.utc ?? null,\n      venueName: order.event?.venue?.name ?? null,\n      eventCategory: order.event?.category?.name ?? null,\n      eventFormat: order.event?.format?.name ?? null,\n      ticketClassCount: Array.isArray(order.event?.ticket_classes) ? order.event.ticket_classes.length : 0,\n      rawEventData: order.event,\n    };\n  };\n\n  const handleAttendeeEvent = async (token, supabase, payload, ingestedAt) => {\n    const attendee = await fetchAttendee(\n      token,\n      payload.api_url,\n      payload.resource?.attendee_id ?? payload.attendee_id ?? payload.id ?? null,\n      payload.resource?.event_id ?? payload.event_id ?? payload.config?.event_id ?? null,\n    );\n\n    const attendeeRecord = mapAttendeeRecord(attendee, ingestedAt);\n    if (attendeeRecord) {\n      await upsertSupabaseRows(supabase, 'tickets_eventbrite', [attendeeRecord]);\n    }\n\n    const result = {\n      processedOrders: 0,\n      processedTickets: attendeeRecord ? 1 : 0,\n    };\n\n    // Also refresh the parent order\n    if (attendee.order_id) {\n      try {\n        const order = await fetchOrder(token, null, attendee.order_id);\n        const orderRecord = mapOrderRecord(order, ingestedAt);\n        const ticketRecords = Array.isArray(order.attendees)\n          ? order.attendees.map((att) => mapAttendeeRecord(att, ingestedAt)).filter(Boolean)\n          : [];\n\n        await upsertSupabaseRows(supabase, 'orders_eventbrite', orderRecord ? [orderRecord] : []);\n        if (ticketRecords.length) {\n          await upsertSupabaseRows(supabase, 'tickets_eventbrite', ticketRecords);\n        }\n\n        result.processedOrders = orderRecord ? 1 : 0;\n        result.processedTickets += ticketRecords.length;\n        result.eventName = order.event?.name?.text ?? null;\n        result.eventStart = order.event?.start?.utc ?? null;\n        result.venueName = order.event?.venue?.name ?? null;\n        result.rawEventData = order.event;\n      } catch (error) {\n        result.orderRefreshError = error.message ?? String(error);\n      }\n    }\n\n    return result;\n  };\n\n  const handleEventUpdate = async (token, supabase, payload, ingestedAt) => {\n    const eventId = payload.resource?.event_id ?? payload.event_id ?? payload.id ?? null;\n    const event = await fetchEvent(token, payload.api_url, eventId);\n    \n    // Fetch all orders for this event and update them with latest event data\n    const orders = await fetchEventOrders(token, event.id);\n    \n    const orderRecords = orders.map((order) => mapOrderRecord(order, ingestedAt)).filter(Boolean);\n    const ticketRecords = orders\n      .flatMap((order) => Array.isArray(order.attendees) ? order.attendees : [])\n      .map((att) => mapAttendeeRecord(att, ingestedAt))\n      .filter(Boolean);\n\n    if (orderRecords.length) {\n      await upsertSupabaseRows(supabase, 'orders_eventbrite', orderRecords);\n    }\n    if (ticketRecords.length) {\n      await upsertSupabaseRows(supabase, 'tickets_eventbrite', ticketRecords);\n    }\n\n    return {\n      processedOrders: orderRecords.length,\n      processedTickets: ticketRecords.length,\n      eventId: event.id,\n      eventName: event.name?.text ?? null,\n      eventStatus: event.status ?? null,\n      venueName: event.venue?.name ?? null,\n      ticketClassCount: Array.isArray(event.ticket_classes) ? event.ticket_classes.length : 0,\n      rawEventData: event,\n    };\n  };\n\n  const handleTicketClassUpdate = async (token, supabase, payload, ingestedAt) => {\n    // Extract event ID from API URL (format: /v3/events/{event_id}/ticket_classes/{tc_id}/)\n    const apiUrl = payload.api_url ?? '';\n    const eventIdMatch = apiUrl.match(/events\\/(\\d+)\\//)?.[1];\n    const eventId = eventIdMatch ?? payload.resource?.event_id ?? payload.event_id ?? null;\n    \n    if (!eventId) {\n      return {\n        processedOrders: 0,\n        processedTickets: 0,\n        skipped: true,\n        reason: 'no_event_id',\n      };\n    }\n\n    // Fetch complete event with ticket classes\n    const event = await fetchEvent(token, null, eventId);\n    \n    // Fetch all orders for this event to update with latest ticket class data\n    const orders = await fetchEventOrders(token, eventId);\n    \n    const orderRecords = orders.map((order) => mapOrderRecord(order, ingestedAt)).filter(Boolean);\n    const ticketRecords = orders\n      .flatMap((order) => Array.isArray(order.attendees) ? order.attendees : [])\n      .map((att) => mapAttendeeRecord(att, ingestedAt))\n      .filter(Boolean);\n\n    if (orderRecords.length) {\n      await upsertSupabaseRows(supabase, 'orders_eventbrite', orderRecords);\n    }\n    if (ticketRecords.length) {\n      await upsertSupabaseRows(supabase, 'tickets_eventbrite', ticketRecords);\n    }\n\n    return {\n      processedOrders: orderRecords.length,\n      processedTickets: ticketRecords.length,\n      eventId,\n      eventName: event.name?.text ?? null,\n      ticketClassCount: Array.isArray(event.ticket_classes) ? event.ticket_classes.length : 0,\n      rawEventData: event,\n      rawTicketClasses: event.ticket_classes,\n    };\n  };\n\n  const handleVenueUpdate = async (token, supabase, payload, ingestedAt) => {\n    // Venue updates don't have a direct way to find associated events\n    // Just capture the venue data for logging\n    try {\n      const venue = await requestWithRetry({\n        method: 'GET',\n        url: payload.api_url,\n        headers: {\n          Authorization: `Bearer ${token}`,\n          'Content-Type': 'application/json',\n        },\n      });\n\n      return {\n        processedOrders: 0,\n        processedTickets: 0,\n        venueId: venue.id ?? null,\n        venueName: venue.name ?? null,\n        rawVenueData: venue,\n        note: 'Venue data captured - associated orders will update on next event/order webhook',\n      };\n    } catch (error) {\n      return {\n        processedOrders: 0,\n        processedTickets: 0,\n        error: error.message ?? String(error),\n      };\n    }\n  };\n\n  const handleOrganizerUpdate = async (token, supabase, payload, ingestedAt) => {\n    // Organizer updates - just capture for logging\n    try {\n      const organizer = await requestWithRetry({\n        method: 'GET',\n        url: payload.api_url,\n        headers: {\n          Authorization: `Bearer ${token}`,\n          'Content-Type': 'application/json',\n        },\n      });\n\n      return {\n        processedOrders: 0,\n        processedTickets: 0,\n        organizerId: organizer.id ?? null,\n        organizerName: organizer.name ?? null,\n        rawOrganizerData: organizer,\n        note: 'Organizer data captured - associated orders will update on next event/order webhook',\n      };\n    } catch (error) {\n      return {\n        processedOrders: 0,\n        processedTickets: 0,\n        error: error.message ?? String(error),\n      };\n    }\n  };\n\n  // ========================================\n  // MAIN EXECUTION\n  // ========================================\n\n  const payload = $json.body ?? $json;\n  if (!payload) {\n    throw new Error('Webhook payload is empty.');\n  }\n\n  const action = String(payload.config?.action ?? payload.action ?? '').toLowerCase();\n  const ingestedAt = new Date().toISOString();\n  \n  const summary = {\n    action,\n    apiUrl: payload.api_url ?? null,\n    webhookTimestamp: new Date().toISOString(),\n    completeVersion: true,\n    expandedFields: 'ALL (order, event, attendee, ticket_class, venue, organizer)',\n  };\n\n  const eventbriteToken = await loadEventbriteToken();\n  const supabase = await loadSupabaseConfig();\n\n  // Route to appropriate handler based on event type\n  const eventType = action.split('.')[0];\n  let handlerResult = {};\n\n  try {\n    switch (eventType) {\n      case 'order':\n        handlerResult = await handleOrderEvent(eventbriteToken, supabase, payload, ingestedAt);\n        break;\n      \n      case 'attendee':\n      case 'barcode':\n        handlerResult = await handleAttendeeEvent(eventbriteToken, supabase, payload, ingestedAt);\n        break;\n      \n      case 'event':\n        handlerResult = await handleEventUpdate(eventbriteToken, supabase, payload, ingestedAt);\n        break;\n      \n      case 'ticket_class':\n        handlerResult = await handleTicketClassUpdate(eventbriteToken, supabase, payload, ingestedAt);\n        break;\n      \n      case 'venue':\n        handlerResult = await handleVenueUpdate(eventbriteToken, supabase, payload, ingestedAt);\n        break;\n      \n      case 'organizer':\n        handlerResult = await handleOrganizerUpdate(eventbriteToken, supabase, payload, ingestedAt);\n        break;\n      \n      default:\n        handlerResult = {\n          processedOrders: 0,\n          processedTickets: 0,\n          skipped: true,\n          reason: `unknown_event_type: ${eventType}`,\n        };\n    }\n  } catch (error) {\n    handlerResult = {\n      processedOrders: 0,\n      processedTickets: 0,\n      error: error.message ?? String(error),\n      stack: error.stack,\n    };\n  }\n\n  return [{ json: { ...summary, ...handlerResult } }];\n}\n\nreturn run.call(this);"
      },
      "id": "process-webhook-complete",
      "name": "Process Webhook (All Events)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        300
      ],
      "notesInFlow": true,
      "notes": "COMPLETE VERSION - Processes ALL webhook event types:\n\n✅ order.* → Updates orders + tickets with full event data\n✅ attendee.* / barcode.* → Updates tickets + refreshes parent order\n✅ event.* → Fetches all orders for event, updates with latest event data\n✅ ticket_class.* → Fetches event + all orders, updates with latest ticket class data\n✅ venue.* → Captures venue data (orders update on next event webhook)\n✅ organizer.* → Captures organizer data\n\nMaximum data expansion on all requests.\nStores everything in orders_eventbrite.raw and tickets_eventbrite.raw"
    }
  ],
  "connections": {
    "Eventbrite Webhook": {
      "main": [
        [
          {
            "node": "Process Webhook (All Events)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "complete-all-events-v1",
  "meta": {
    "instanceId": "complete-eventbrite-webhook"
  },
  "tags": []
}
