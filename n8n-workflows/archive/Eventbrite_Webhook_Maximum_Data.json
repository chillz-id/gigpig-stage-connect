{
  "name": "Eventbrite Webhook (Maximum Data)",
  "nodes": [
    {
      "parameters": {
        "path": "eventbrite/webhook-max-data",
        "httpMethod": "POST",
        "responseMode": "onReceived",
        "options": {}
      },
      "id": "webhook-trigger-max",
      "name": "Eventbrite Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        240,
        300
      ],
      "webhookId": "eventbrite-webhook-max-data"
    },
    {
      "parameters": {
        "jsCode": "async function run() {\n  const readEnv = async (key) => {\n    if (typeof $env !== 'undefined' && $env && Object.prototype.hasOwnProperty.call($env, key)) {\n      const value = $env[key];\n      if (value !== undefined && value !== null && String(value).trim() !== '') {\n        return String(value).trim();\n      }\n    }\n    if (typeof process !== 'undefined' && process.env && Object.prototype.hasOwnProperty.call(process.env, key)) {\n      const value = process.env[key];\n      if (value !== undefined && value !== null && String(value).trim() !== '') {\n        return String(value).trim();\n      }\n    }\n    return '';\n  };\n\n  const FALLBACK_EVENTBRITE_TOKEN = 'KPGTS46ZFV2ECF7QUZKE';\n  const FALLBACK_EVENTBRITE_ORG_ID = '276710097137';\n  const FALLBACK_SUPABASE_URL = 'https://pdikjpfulhhpqpxzpgtu.supabase.co';\n  const FALLBACK_SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBkaWtqcGZ1bGhocHFweHpwZ3R1Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1MDI2Njg2MSwiZXhwIjoyMDY1ODQyODYxfQ.RS6RG0nbmxEqtO99dnpGnd7WV7C_uI0l_XJugKqOzPE';\n\n  const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\n  const requestWithRetry = async (options, attempt = 0) => {\n    try {\n      return await this.helpers.httpRequest({ ...options, json: true });\n    } catch (error) {\n      const status = Number(error.statusCode ?? error.response?.status ?? error.response?.statusCode ?? error.code ?? 0);\n      const isRetryable = [408, 429, 500, 502, 503, 504].includes(status);\n      if (attempt < 4 && isRetryable) {\n        const delay = Math.min(2000 * (attempt + 1), 10000);\n        await sleep(delay);\n        return requestWithRetry(options, attempt + 1);\n      }\n      throw error;\n    }\n  };\n\n  const loadEventbriteToken = async () => {\n    const envKeys = ['EVENTBRITE_PRIVATE_TOKEN', 'EVENTBRITE_OAUTH_TOKEN', 'EVENTBRITE_API_KEY', 'EVENTBRITE_TOKEN'];\n    for (const envKey of envKeys) {\n      const value = await readEnv(envKey);\n      if (value) {\n        return value;\n      }\n    }\n\n    const credentialCandidates = ['eventbriteApi', 'eventbriteOAuth2Api', 'eventbriteOAuth2', 'httpHeaderAuth'];\n    for (const name of credentialCandidates) {\n      try {\n        const creds = await this.getCredentials(name);\n        if (!creds) continue;\n        const candidate = creds.accessToken ?? creds.apiKey ?? creds.token ?? creds.headerValue ?? creds.key ?? null;\n        if (candidate && String(candidate).trim() !== '') {\n          return String(candidate).trim();\n        }\n      } catch (error) {\n        const message = error?.message ?? '';\n        if (!/not set/i.test(message) && !/does not exist/i.test(message)) {\n          console.warn('Eventbrite credential ' + name + ' lookup failed:', message || error);\n        }\n      }\n    }\n\n    if (FALLBACK_EVENTBRITE_TOKEN) {\n      const fallback = String(FALLBACK_EVENTBRITE_TOKEN).trim();\n      if (fallback) {\n        console.warn('Using fallback Eventbrite token from workflow.');\n        return fallback;\n      }\n    }\n\n    throw new Error('Missing Eventbrite credentials (set EVENTBRITE_API_KEY or attach an Eventbrite credential in n8n).');\n  };\n\n    const loadSupabaseConfig = async () => {\n    let url = await readEnv('SUPABASE_URL');\n    if (!url) {\n      url = await readEnv('SUPABASE_REST_URL');\n    }\n    let key = await readEnv('SUPABASE_SERVICE_ROLE_KEY');\n    if (!key) {\n      key = await readEnv('SUPABASE_SERVICE_KEY');\n    }\n\n    if (!url || !key) {\n      const credentialCandidates = ['supabaseApi', 'supabaseDatabase', 'supabaseServiceRole', 'httpHeaderAuth'];\n      for (const name of credentialCandidates) {\n        try {\n          const creds = await this.getCredentials(name);\n          if (!creds) continue;\n          if (!url) {\n            const candidateUrl = creds.url ?? creds.host ?? creds.restUrl ?? creds.restApiUrl ?? creds.endpoint ?? creds.baseUrl ?? '';\n            if (candidateUrl && String(candidateUrl).trim() !== '') {\n              url = String(candidateUrl).trim();\n            }\n          }\n          if (!key) {\n            const candidateKey = creds.serviceRoleKey ?? creds.apiKey ?? creds.serviceRoleSecret ?? creds.token ?? creds.key ?? creds.headerValue ?? '';\n            if (candidateKey && String(candidateKey).trim() !== '') {\n              key = String(candidateKey).trim();\n            }\n          }\n          if (url && key) {\n            break;\n          }\n        } catch (error) {\n          const message = error?.message ?? '';\n          if (!/not set/i.test(message) && !/does not exist/i.test(message)) {\n            console.warn('Supabase credential ' + name + ' lookup failed:', message || error);\n          }\n        }\n      }\n    }\n\n    if (!url && FALLBACK_SUPABASE_URL) {\n      url = FALLBACK_SUPABASE_URL;\n      console.warn('Using fallback Supabase URL from workflow.');\n    }\n    if (!key && FALLBACK_SUPABASE_KEY) {\n      key = FALLBACK_SUPABASE_KEY;\n      console.warn('Using fallback Supabase key from workflow.');\n    }\n\n    if (!url || !key) {\n      throw new Error('Missing Supabase credentials (set SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY in n8n or attach a Supabase credential).');\n    }\n\n    return {\n      url: String(url).trim().replace(/\\/$/, ''),\n      key: String(key).trim(),\n    };\n  };\n\n  const parseCents = (value) => {\n    if (value === undefined || value === null || value === '') return null;\n    const num = Number(value);\n    if (Number.isNaN(num)) {\n      const parsed = Number.parseFloat(String(value));\n      if (Number.isNaN(parsed)) return null;\n      return Math.round(parsed);\n    }\n    return Math.round(num);\n  };\n\n  const centsOrZero = (value) => {\n    const result = parseCents(value);\n    return result === null ? 0 : result;\n  };\n\n  const toIso = (value) => {\n    if (!value) return null;\n    const date = new Date(value);\n    if (Number.isNaN(date.getTime())) return null;\n    return date.toISOString();\n  };\n\n  const mapOrderRecord = (order, ingestedAt) => {\n    if (!order?.id) return null;\n    const costs = order.costs ?? {};\n    const gross = parseCents(costs.gross?.value);\n    const fees = centsOrZero(costs.eventbrite_fee?.value) + centsOrZero(costs.payment_fee?.value);\n    const taxes = centsOrZero(costs.tax?.value);\n    const net = gross === null ? null : Math.max(gross - fees - taxes, 0);\n    const base = parseCents(costs.base_price?.value);\n    const discount = parseCents(costs.discount?.value);\n    const currency = costs.gross?.currency ?? costs.base_price?.currency ?? null;\n    const fallbackPurchaserName = [order.first_name, order.last_name]\n      .filter(Boolean)\n      .join(' ')\n      .trim();\n    const purchaserNameRaw = order.name ?? (fallbackPurchaserName.length ? fallbackPurchaserName : null);\n    const purchaserName = purchaserNameRaw && purchaserNameRaw.length ? purchaserNameRaw : null;\n    const eventId = order.event_id ?? order.event?.id ?? null;\n\n    return {\n      source: 'eventbrite',\n      source_id: order.id,\n      event_source_id: eventId,\n      session_source_id: eventId,\n      status: order.status ?? null,\n      financial_status: order.payment_status ?? order.status ?? null,\n      total_cents: gross,\n      subtotal_cents: base,\n      net_sales_cents: net,\n      gross_sales_cents: gross,\n      discounts_cents: discount,\n      taxes_cents: taxes,\n      fees_cents: fees || null,\n      purchaser_email: order.email ?? order.profile?.email ?? null,\n      purchaser_name: purchaserName,\n      ordered_at: toIso(order.created),\n      updated_at: toIso(order.changed),\n      currency,\n      additional_fields: Array.isArray(order.attendees) && order.attendees.length ? order.attendees : null,\n      raw: order,\n      ingested_at: ingestedAt,\n      updated_at_api: toIso(order.changed),\n    };\n  };\n\n  const normalizeStatus = (attendee) => {\n    if (!attendee) return null;\n    if (attendee.checked_in === true) return 'checked_in';\n    if (attendee.cancelled) return 'cancelled';\n    if (attendee.refunded) return 'refunded';\n    return attendee.status ?? null;\n  };\n\n  const mapAttendeeRecord = (attendee, ingestedAt) => {\n    if (!attendee?.id) return null;\n    const costs = attendee.costs ?? {};\n    const gross = parseCents(costs.gross?.value);\n    const base = parseCents(costs.base_price?.value);\n    const taxes = parseCents(costs.tax?.value);\n    const fees = centsOrZero(costs.eventbrite_fee?.value) + centsOrZero(costs.payment_fee?.value);\n    const discount = parseCents(costs.discount?.value);\n    const passed = parseCents(costs.passed_on_fee?.value);\n    const absorbed = parseCents(costs.absorbed_fee?.value);\n    const donation = parseCents(costs.donation?.value ?? costs.dgr_donation?.value);\n    const currency = costs.gross?.currency ?? costs.base_price?.currency ?? null;\n    const profile = attendee.profile ?? {};\n    const eventId = attendee.event_id ?? attendee.event?.id ?? null;\n    const profileNameParts = typeof profile.name === 'string' ? profile.name.trim().split(/\\s+/) : [];\n    const fallbackFirstName = profileNameParts.length ? profileNameParts[0] : null;\n    const fallbackLastNamePart = profileNameParts.length > 1 ? profileNameParts.slice(1).join(' ').trim() : null;\n\n    return {\n      source: 'eventbrite',\n      source_id: attendee.id,\n      order_source_id: attendee.order_id ?? null,\n      event_source_id: eventId,\n      session_source_id: eventId,\n      ticket_type_id: attendee.ticket_class_id ?? null,\n      ticket_type_name: attendee.ticket_class_name ?? null,\n      status: normalizeStatus(attendee),\n      total_cents: gross,\n      net_price_cents: base,\n      price_cents: base,\n      discount_cents: discount,\n      taxes_cents: taxes,\n      fee_cents: fees || null,\n      passed_on_fee_cents: passed,\n      absorbed_fee_cents: absorbed,\n      dgr_donation_cents: donation,\n      currency,\n      first_name: profile.first_name ?? (fallbackFirstName ?? null),\n      last_name: profile.last_name ?? (fallbackLastNamePart ?? null),\n      email: profile.email ?? attendee.email ?? null,\n      created_at: toIso(attendee.created),\n      updated_at: toIso(attendee.changed),\n      raw: attendee,\n      ingested_at: ingestedAt,\n      updated_at_api: toIso(attendee.changed),\n    };\n  };\n\n  const upsertSupabaseRows = async (supabase, table, rows) => {\n    const payload = rows.filter(Boolean);\n    if (!payload.length) return;\n    await requestWithRetry({\n      method: 'POST',\n      url: `${supabase.url}/rest/v1/${table}?on_conflict=source_id`,\n      headers: {\n        apikey: supabase.key,\n        Authorization: `Bearer ${supabase.key}`,\n        'Content-Type': 'application/json',\n        Prefer: 'resolution=merge-duplicates',\n      },\n      body: payload,\n    });\n  };\n\n  const fetchOrder = async (token, url, fallbackOrderId) => {\n    let endpoint = url ?? '';\n    if (!endpoint && fallbackOrderId) {\n      endpoint = `https://www.eventbriteapi.com/v3/orders/${fallbackOrderId}/`;\n    }\n    if (!endpoint) {\n      throw new Error('Unable to resolve Eventbrite order API URL.');\n    }\n    return requestWithRetry({\n      method: 'GET',\n      url: endpoint,\n      qs: { expand: 'attendees,attendees.profile,attendees.costs,attendees.promotional_code,event,event.ticket_classes,event.venue,event.category,event.subcategory,event.format' },\n      headers: {\n        Authorization: `Bearer ${token}`,\n        'Content-Type': 'application/json',\n      },\n    });\n  };\n\n  const fetchAttendee = async (token, url, attendeeId, eventId) => {\n    let endpoint = url ?? '';\n    if (!endpoint && attendeeId && eventId) {\n      endpoint = `https://www.eventbriteapi.com/v3/events/${eventId}/attendees/${attendeeId}/`;\n    }\n    if (!endpoint) {\n      throw new Error('Unable to resolve Eventbrite attendee API URL.');\n    }\n    return requestWithRetry({\n      method: 'GET',\n      url: endpoint,\n      qs: { expand: 'profile,costs,promotional_code,event' },\n      headers: {\n        Authorization: `Bearer ${token}`,\n        'Content-Type': 'application/json',\n      },\n    });\n  };\n\n  const payload = $json.body ?? $json;\n  if (!payload) {\n    throw new Error('Webhook payload is empty.');\n  }\n\n  const action = String(payload.config?.action ?? payload.action ?? '').toLowerCase();\n  const ingestedAt = new Date().toISOString();\n  const summary = {\n    action,\n    apiUrl: payload.api_url ?? null,\n    processedOrders: 0,\n    processedTickets: 0,\n    skipped: false,\n    maximumDataVersion: true,\n    expandedFields: 'attendees,attendees.profile,attendees.costs,attendees.promotional_code,event,event.ticket_classes,event.venue,event.category,event.subcategory,event.format',\n  };\n\n  const isOrderEvent = action.startsWith('order.');\n  const isAttendeeEvent = action.startsWith('attendee.') || action.startsWith('barcode.');\n\n  if (!isOrderEvent && !isAttendeeEvent) {\n    summary.skipped = true;\n    return [{ json: summary }];\n  }\n\n  const eventbriteToken = await loadEventbriteToken();\n  const supabase = await loadSupabaseConfig();\n\n  if (isOrderEvent) {\n    const order = await fetchOrder(eventbriteToken, payload.api_url, payload.resource?.order_id ?? payload.order_id ?? payload.id ?? null);\n    const orderRecord = mapOrderRecord(order, ingestedAt);\n    const attendeeRecords = Array.isArray(order.attendees)\n      ? order.attendees.map((att) => mapAttendeeRecord(att, ingestedAt)).filter(Boolean)\n      : [];\n\n    await upsertSupabaseRows(supabase, 'orders_eventbrite', orderRecord ? [orderRecord] : []);\n    if (attendeeRecords.length) {\n      await upsertSupabaseRows(supabase, 'tickets_eventbrite', attendeeRecords);\n    }\n\n    summary.processedOrders = orderRecord ? 1 : 0;\n    summary.processedTickets = attendeeRecords.length;\n    summary.eventName = order.event?.name?.text ?? null;\n    summary.eventStart = order.event?.start?.utc ?? null;\n    summary.venueName = order.event?.venue?.name ?? null;\n    summary.eventCategory = order.event?.category?.name ?? null;\n    summary.eventFormat = order.event?.format?.name ?? null;\n    summary.ticketClassCount = Array.isArray(order.event?.ticket_classes) ? order.event.ticket_classes.length : 0;\n    return [{ json: summary }];\n  }\n\n  const attendee = await fetchAttendee(\n    eventbriteToken,\n    payload.api_url,\n    payload.resource?.attendee_id ?? payload.attendee_id ?? payload.id ?? null,\n    payload.resource?.event_id ?? payload.event_id ?? payload.config?.event_id ?? null,\n  );\n\n  const attendeeRecord = mapAttendeeRecord(attendee, ingestedAt);\n  if (attendeeRecord) {\n    await upsertSupabaseRows(supabase, 'tickets_eventbrite', [attendeeRecord]);\n    summary.processedTickets += 1;\n  }\n\n  if (attendee.order_id) {\n    try {\n      const order = await fetchOrder(eventbriteToken, null, attendee.order_id);\n      const orderRecord = mapOrderRecord(order, ingestedAt);\n      const ticketRecords = Array.isArray(order.attendees)\n        ? order.attendees.map((att) => mapAttendeeRecord(att, ingestedAt)).filter(Boolean)\n        : [];\n\n      await upsertSupabaseRows(supabase, 'orders_eventbrite', orderRecord ? [orderRecord] : []);\n      if (ticketRecords.length) {\n        await upsertSupabaseRows(supabase, 'tickets_eventbrite', ticketRecords);\n      }\n\n      summary.processedOrders = orderRecord ? 1 : 0;\n      summary.processedTickets += ticketRecords.length;\n      summary.eventName = order.event?.name?.text ?? null;\n      summary.eventStart = order.event?.start?.utc ?? null;\n      summary.venueName = order.event?.venue?.name ?? null;\n      summary.eventCategory = order.event?.category?.name ?? null;\n      summary.eventFormat = order.event?.format?.name ?? null;\n      summary.ticketClassCount = Array.isArray(order.event?.ticket_classes) ? order.event.ticket_classes.length : 0;\n    } catch (error) {\n      summary.orderRefreshError = error.message ?? String(error);\n    }\n  }\n\n  return [{ json: summary }];\n}\n\nreturn run.call(this);"
      },
      "id": "process-webhook-max",
      "name": "Process Webhook (Maximum Data)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        460,
        300
      ],
      "notesInFlow": true,
      "notes": "MAXIMUM DATA VERSION\n\nExpands ALL available fields:\n- attendees + profile + costs + promo codes\n- event + venue + category + subcategory + format + ticket_classes\n\nStores everything in orders_eventbrite.raw and tickets_eventbrite.raw"
    }
  ],
  "connections": {
    "Eventbrite Webhook": {
      "main": [
        [
          {
            "node": "Process Webhook (Maximum Data)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "max-data-webhook-v1",
  "meta": {
    "instanceId": "max-eventbrite-webhook"
  },
  "tags": []
}
