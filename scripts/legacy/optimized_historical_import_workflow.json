[
  {
    "createdAt": "2025-08-22T07:48:55.464Z",
    "updatedAt": "2025-08-22T07:48:55.464Z",
    "id": "OptimizedHistoricalImport",
    "name": "Humanitix Optimized Historical Import",
    "active": false,
    "isArchived": false,
    "nodes": [
      {
        "parameters": {},
        "id": "manual-trigger",
        "name": "Manual Trigger",
        "type": "n8n-nodes-base.manualTrigger",
        "typeVersion": 1,
        "position": [
          240,
          300
        ]
      },
      {
        "parameters": {
          "jsCode": "// Initialize historical import with date range parameters\nconst now = new Date();\n\n// Default: Import last 2 years of data (configurable)\nconst defaultStartDate = new Date(now.getFullYear() - 2, 0, 1); // Jan 1, 2 years ago\nconst defaultEndDate = now;\n\n// Allow override via manual input (for testing specific ranges)\nconst startDate = $input.params?.startDate ? new Date($input.params.startDate) : defaultStartDate;\nconst endDate = $input.params?.endDate ? new Date($input.params.endDate) : defaultEndDate;\n\nconsole.log(`ðŸ“… Historical import range: ${startDate.toDateString()} to ${endDate.toDateString()}`);\n\n// Initialize progress tracking\nconst progressKey = 'historicalImportProgress';\nlet processedEvents = [];\n\ntry {\n  processedEvents = $workflow.staticData[progressKey] || [];\n} catch (e) {\n  console.log('First run - initializing progress tracking');\n}\n\nconsole.log(`ðŸ“Š Previously processed events: ${processedEvents.length}`);\n\nreturn [{\n  json: {\n    startDate: startDate.toISOString(),\n    endDate: endDate.toISOString(),\n    processedEvents: processedEvents,\n    currentBatch: 1,\n    batchSize: 25, // Process 25 events at a time\n    totalProcessed: 0,\n    totalImported: 0\n  }\n}];"
        },
        "id": "init-historical",
        "name": "Initialize Historical Import",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          460,
          300
        ]
      },
      {
        "parameters": {
          "method": "GET",
          "url": "https://api.humanitix.com/v1/events",
          "sendQuery": true,
          "queryParameters": {
            "parameters": [
              {
                "name": "page",
                "value": "1"
              },
              {
                "name": "pageSize",
                "value": "100"
              }
            ]
          },
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "x-api-key",
                "value": "{{HUMANITIX_API_KEY}}"
              }
            ]
          }
        },
        "id": "fetch-all-events",
        "name": "Fetch All Events",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.1,
        "position": [
          680,
          300
        ]
      },
      {
        "parameters": {
          "jsCode": "// Smart event filtering for historical import\nconst eventsResponse = $input.first().json;\nconst { startDate, endDate, processedEvents, batchSize } = $('Initialize Historical Import').first().json;\nconst events = eventsResponse.events || [];\n\nconsole.log(`ðŸ“‹ Received ${events.length} total events from API`);\n\nconst startDateTime = new Date(startDate);\nconst endDateTime = new Date(endDate);\n\n// Filter events by date range and processing status\nconst targetEvents = events.filter(event => {\n  // Skip if already processed\n  if (processedEvents.includes(event._id)) {\n    return false;\n  }\n  \n  // Check if event falls within date range\n  const eventDate = new Date(event.startDate);\n  const eventEndDate = event.endDate ? new Date(event.endDate) : eventDate;\n  \n  // Include if event overlaps with our date range\n  return (eventDate >= startDateTime && eventDate <= endDateTime) ||\n         (eventEndDate >= startDateTime && eventEndDate <= endDateTime) ||\n         (eventDate <= startDateTime && eventEndDate >= endDateTime);\n});\n\nconsole.log(`ðŸŽ¯ Filtered to ${targetEvents.length} events in date range (not yet processed)`);\n\n// Take first batch for processing\nconst batchEvents = targetEvents.slice(0, batchSize);\nconsole.log(`ðŸ“¦ Processing batch of ${batchEvents.length} events`);\n\nif (batchEvents.length === 0) {\n  console.log('âœ… All events in date range have been processed!');\n  return [];\n}\n\nreturn batchEvents.map(event => ({\n  json: {\n    eventId: event._id,\n    eventName: event.name,\n    eventStartDate: event.startDate,\n    eventEndDate: event.endDate || event.startDate,\n    importStartTime: new Date().toISOString()\n  }\n}));"
        },
        "id": "filter-historical-events",
        "name": "Filter Historical Events",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          900,
          300
        ]
      },
      {
        "parameters": {
          "method": "GET",
          "url": "=https://api.humanitix.com/v1/events/{{ $json.eventId }}/orders",
          "sendQuery": true,
          "queryParameters": {
            "parameters": [
              {
                "name": "page",
                "value": "1"
              },
              {
                "name": "pageSize",
                "value": "100"
              }
            ]
          },
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "x-api-key",
                "value": "{{HUMANITIX_API_KEY}}"
              }
            ]
          }
        },
        "id": "fetch-historical-orders",
        "name": "Fetch Historical Orders",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.1,
        "position": [
          1120,
          300
        ]
      },
      {
        "parameters": {
          "jsCode": "// Bulk duplicate checking - much more efficient than individual queries\nconst ordersResponse = $input.first().json;\nconst orders = ordersResponse.orders || [];\nconst eventData = $('Filter Historical Events').item($runIndex).json;\n\nif (orders.length === 0) {\n  console.log(`âšª No orders found for ${eventData.eventName}`);\n  return [];\n}\n\nconsole.log(`ðŸ“Š Event: ${eventData.eventName} - ${orders.length} total orders`);\n\n// Extract all order IDs for bulk duplicate check\nconst orderIds = orders.map(order => order._id);\n\nconsole.log(`ðŸ” Checking for duplicates among ${orderIds.length} orders...`);\n\n// Return orders with their IDs for the next bulk check\nreturn orders.map(order => ({\n  json: {\n    orderData: order,\n    eventData: {\n      _id: eventData.eventId,\n      name: eventData.eventName,\n      startDate: eventData.eventStartDate,\n      endDate: eventData.eventEndDate\n    },\n    orderId: order._id,\n    needsDuplicateCheck: true\n  }\n}));"
        },
        "id": "prepare-bulk-check",
        "name": "Prepare Bulk Duplicate Check",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1340,
          300
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://api.notion.com/v1/databases/1374745b-8cbe-804b-87a2-ec93b3385e01/query",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Authorization",
                "value": "Bearer {{NOTION_API_KEY}}"
              },
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Notion-Version",
                "value": "2022-06-28"
              }
            ]
          },
          "sendBody": true,
          "bodyContentType": "json",
          "jsonBody": "={{ JSON.stringify({ page_size: 100 }) }}",
          "options": {
            "response": {
              "response": {
                "neverError": true
              }
            }
          }
        },
        "id": "bulk-duplicate-check",
        "name": "Bulk Duplicate Check",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.1,
        "position": [
          1560,
          300
        ]
      },
      {
        "parameters": {
          "jsCode": "// Filter out duplicates using bulk check results\nconst existingEntries = $input.first().json.results || [];\nconst ordersToCheck = $('Prepare Bulk Duplicate Check').all();\n\nconsole.log(`ðŸ“‹ Existing entries in Notion: ${existingEntries.length}`);\nconsole.log(`ðŸ” Orders to check: ${ordersToCheck.length}`);\n\n// Create set of existing Order IDs for fast lookup\nconst existingOrderIds = new Set();\nexistingEntries.forEach(entry => {\n  const orderId = entry.properties['Order ID']?.rich_text?.[0]?.text?.content;\n  if (orderId) {\n    existingOrderIds.add(orderId);\n  }\n});\n\nconsole.log(`ðŸ“Š Found ${existingOrderIds.size} existing order IDs in Notion`);\n\n// Filter out duplicates\nconst newOrders = ordersToCheck.filter(item => {\n  const orderId = item.json.orderId;\n  const isDuplicate = existingOrderIds.has(orderId);\n  \n  if (isDuplicate) {\n    console.log(`â­ï¸ Skipping duplicate: ${orderId}`);\n  }\n  \n  return !isDuplicate;\n});\n\nconsole.log(`âœ… Found ${newOrders.length} new orders to import`);\n\nif (newOrders.length === 0) {\n  return [];\n}\n\nreturn newOrders;"
        },
        "id": "filter-duplicates",
        "name": "Filter Duplicates",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          1780,
          300
        ]
      },
      {
        "parameters": {
          "jsCode": "// Transform historical orders with CORRECT FINANCIAL FIELDS\nconst { orderData, eventData } = $json;\n\nconsole.log(`ðŸ”„ Processing historical order: ${orderData.firstName} ${orderData.lastName} (${orderData._id})`);\n\ntry {\n  const orderId = orderData._id || 'unknown-' + Date.now();\n  const eventId = eventData._id || 'unknown-event';\n  \n  // Safe customer name extraction\n  let customerName = 'Anonymous';\n  try {\n    const firstName = orderData.firstName || '';\n    const lastName = orderData.lastName || '';\n    customerName = `${firstName} ${lastName}`.trim() || 'Anonymous';\n  } catch (e) {\n    customerName = 'Anonymous';\n  }\n  \n  const email = orderData.email || \"no-email@example.com\";\n  const phone = orderData.mobile || orderData.phone || null;\n  \n  // CORRECT FINANCIAL FIELDS - Use proper data sources\n  let grossSales = 0;\n  let netSales = 0;\n  let discountAmount = 0;\n  let discountCode = '';\n  \n  try {\n    // Use grossSales for Total Amount (original price before discount)\n    grossSales = parseFloat(orderData.totals?.grossSales || orderData.purchaseTotals?.grossSales || 0);\n    if (isNaN(grossSales)) grossSales = 0;\n    \n    // Use netSales for Net Sales (amount after discount)\n    netSales = parseFloat(orderData.totals?.netSales || orderData.purchaseTotals?.netSales || 0);\n    if (isNaN(netSales)) netSales = 0;\n    \n    // Extract discount information\n    discountCode = orderData.discounts?.discountCode?.code || '';\n    discountAmount = parseFloat(orderData.discounts?.discountCode?.discountAmount || orderData.totals?.discounts || 0);\n    if (isNaN(discountAmount)) discountAmount = 0;\n    \n    console.log(`ðŸ’° Financial - Gross: ${grossSales}, Net: ${netSales}, Discount: ${discountCode} (${discountAmount})`);\n    \n  } catch (e) {\n    console.error('âš ï¸ Error extracting financial data:', e.message);\n  }\n  \n  // Safe date extraction\n  let eventDate = new Date().toISOString();\n  try {\n    eventDate = eventData.startDate || new Date().toISOString();\n  } catch (e) {\n    eventDate = new Date().toISOString();\n  }\n  \n  let orderDate = new Date().toISOString();\n  try {\n    orderDate = orderData.completedAt || orderData.createdAt || new Date().toISOString();\n  } catch (e) {\n    orderDate = new Date().toISOString();\n  }\n  \n  const status = orderData.status || orderData.financialStatus || \"completed\";\n  const ticketTypes = 'General Admission';\n  const eventName = eventData.name || 'Unknown Event';\n  \n  // Create the Notion entry with CORRECT field mappings\n  const notionEntry = {\n    parent: {\n      database_id: '1374745b-8cbe-804b-87a2-ec93b3385e01'\n    },\n    properties: {\n      \"Name\": {\n        title: [{ text: { content: customerName } }]\n      },\n      \"Email\": {\n        email: email\n      },\n      \"Event Name\": {\n        rich_text: [{ text: { content: eventName } }]\n      },\n      \"Event ID\": {\n        rich_text: [{ text: { content: eventId } }]\n      },\n      \"Event Date & Time\": {\n        date: { start: eventDate }\n      },\n      \"Order ID\": {\n        rich_text: [{ text: { content: orderId } }]\n      },\n      // FIXED: Use gross sales for Total Amount (original price)\n      \"Total Amount\": {\n        number: grossSales\n      },\n      // NEW: Add Net Sales field\n      \"Net Sales\": {\n        number: netSales\n      },\n      // NEW: Add Discount Code field\n      \"Discount Code\": {\n        rich_text: [{ text: { content: discountCode } }]\n      },\n      // NEW: Add Discount Amount field\n      \"Discount Amount\": {\n        number: discountAmount\n      },\n      \"Quantity\": {\n        number: 1\n      },\n      \"Ticket Type\": {\n        rich_text: [{ text: { content: ticketTypes } }]\n      },\n      \"Payment Status\": {\n        rich_text: [{ text: { content: status } }]\n      },\n      \"Order Date\": {\n        date: { start: orderDate }\n      },\n      \"Ticketing Partner\": {\n        select: { name: \"Humanitix\" }\n      },\n      \"Created At\": {\n        date: { start: new Date().toISOString() }\n      },\n      \"Updated At\": {\n        date: { start: new Date().toISOString() }\n      }\n    }\n  };\n  \n  // Add phone if available\n  if (phone) {\n    notionEntry.properties[\"Mobile\"] = {\n      phone_number: phone\n    };\n  }\n  \n  console.log(`âœ… Historical entry prepared for: ${customerName} (Gross: $${grossSales}, Net: $${netSales})`);\n  return [{ json: notionEntry }];\n  \n} catch (error) {\n  console.error('âŒ Error in historical transform:', error.message);\n  return [];\n}"
        },
        "id": "transform-historical",
        "name": "Transform Historical Order",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2000,
          300
        ]
      },
      {
        "parameters": {
          "method": "POST",
          "url": "https://api.notion.com/v1/pages",
          "sendHeaders": true,
          "headerParameters": {
            "parameters": [
              {
                "name": "Authorization",
                "value": "Bearer {{NOTION_API_KEY}}"
              },
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "Notion-Version",
                "value": "2022-06-28"
              }
            ]
          },
          "sendBody": true,
          "bodyContentType": "json",
          "jsonBody": "={{ $json }}",
          "options": {
            "response": {
              "response": {
                "neverError": true
              }
            }
          }
        },
        "id": "import-to-notion",
        "name": "Import to Notion",
        "type": "n8n-nodes-base.httpRequest",
        "typeVersion": 4.1,
        "position": [
          2220,
          300
        ]
      },
      {
        "parameters": {
          "jsCode": "// Track progress and prepare for next batch\nconst importResults = $input.all();\nconst eventData = $('Filter Historical Events').all();\n\nconsole.log(`ðŸ“Š Batch completed: ${importResults.length} orders processed`);\n\n// Count successes and failures\nlet successCount = 0;\nlet failureCount = 0;\n\nimportResults.forEach(result => {\n  if (result.json.id) {\n    successCount++;\n  } else {\n    failureCount++;\n  }\n});\n\n// Update progress tracking\nconst progressKey = 'historicalImportProgress';\nlet processedEvents = $workflow.staticData[progressKey] || [];\n\n// Add all events from this batch to processed list\neventData.forEach(event => {\n  if (!processedEvents.includes(event.json.eventId)) {\n    processedEvents.push(event.json.eventId);\n  }\n});\n\n$workflow.staticData[progressKey] = processedEvents;\n\nconsole.log(`âœ… Historical import batch results:`);\nconsole.log(`   Successfully imported: ${successCount} orders`);\nconsole.log(`   Failed imports: ${failureCount} orders`);\nconsole.log(`   Total events processed so far: ${processedEvents.length}`);\n\n// Check if more batches are needed\nconst initData = $('Initialize Historical Import').first().json;\nconst hasMoreEvents = eventData.length === initData.batchSize;\n\nreturn [{\n  json: {\n    batchCompleted: true,\n    successCount: successCount,\n    failureCount: failureCount,\n    totalEventsProcessed: processedEvents.length,\n    hasMoreBatches: hasMoreEvents,\n    nextBatchRecommended: hasMoreEvents,\n    timestamp: new Date().toISOString()\n  }\n}];"
        },
        "id": "track-progress",
        "name": "Track Progress",
        "type": "n8n-nodes-base.code",
        "typeVersion": 2,
        "position": [
          2440,
          300
        ]
      }
    ],
    "connections": {
      "Manual Trigger": {
        "main": [
          [
            {
              "node": "Initialize Historical Import",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Initialize Historical Import": {
        "main": [
          [
            {
              "node": "Fetch All Events",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch All Events": {
        "main": [
          [
            {
              "node": "Filter Historical Events",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Filter Historical Events": {
        "main": [
          [
            {
              "node": "Fetch Historical Orders",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Fetch Historical Orders": {
        "main": [
          [
            {
              "node": "Prepare Bulk Duplicate Check",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Prepare Bulk Duplicate Check": {
        "main": [
          [
            {
              "node": "Bulk Duplicate Check",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Bulk Duplicate Check": {
        "main": [
          [
            {
              "node": "Filter Duplicates",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Filter Duplicates": {
        "main": [
          [
            {
              "node": "Transform Historical Order",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Transform Historical Order": {
        "main": [
          [
            {
              "node": "Import to Notion",
              "type": "main",
              "index": 0
            }
          ]
        ]
      },
      "Import to Notion": {
        "main": [
          [
            {
              "node": "Track Progress",
              "type": "main",
              "index": 0
            }
          ]
        ]
      }
    },
    "settings": {
      "executionOrder": "v1"
    },
    "staticData": {},
    "meta": {
      "instanceId": "e3a1c1c4e2a4f1b2c3d4e5f6a7b8c9d0"
    },
    "pinData": {},
    "versionId": "optimized-historical-v1",
    "triggerCount": 0,
    "tags": []
  }
]