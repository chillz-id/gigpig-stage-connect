{
  "name": "Humanitix â†’ Supabase (Code-only) with Sessions for Combined $$$",
  "nodes": [
    {
      "parameters": {
        "jsCode": "async function run() {\n  const readEnvFile = async (key) => {\n    try {\n      const { execSync } = require('child_process');\n      const envPath = '/home/node/.n8n/.env';\n      const result = execSync(`grep '^${key}=' ${envPath} || true`, { encoding: 'utf8' });\n      const match = result.match(new RegExp(`^${key}=(.+)$`, 'm'));\n      return match ? match[1].trim() : '';\n    } catch (error) {\n      console.warn(`Failed to read .env file for ${key}:`, error.message);\n      return '';\n    }\n  };\n\n  const readEnv = async (key) => {\n    if (typeof $env !== 'undefined' && $env && Object.prototype.hasOwnProperty.call($env, key)) {\n      return String($env[key] ?? '');\n    }\n    if (typeof process !== 'undefined' && process.env && Object.prototype.hasOwnProperty.call(process.env, key)) {\n      return String(process.env[key] ?? '');\n    }\n    return await readEnvFile(key);\n  };\n\n  let humanitixApiKey = (await readEnv('HUMANITIX_API_KEY')).trim();\n  let supabaseUrl = (await readEnv('SUPABASE_URL')).trim().replace(/\\/$/, '');\n  let supabaseKey = (await readEnv('SUPABASE_SERVICE_ROLE_KEY')).trim();\n\n  const fallbackHumanitixApiKey = 'e1d1dd7f16c5e2ad034d89e2f2056d0684e7113d154476a6c59735a31ed78c91915e068534197c92e187ad0251c171fdf0bb0d7b99ee6cbc2cb62d5753a01f1e279cd316e5b64420b4264891f3332edac4b8404e400bf07e1f79f4e2ba0acf946c8c0b3c35963ea7a1c89e86c1ceb2';\n  const fallbackSupabaseUrl = 'https://pdikjpfulhhpqpxzpgtu.supabase.co';\n  const fallbackSupabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBkaWtqcGZ1bGhocHFweHpwZ3R1Iiwicm9sZSI6InNlcnZpY2Vfcm9sZSIsImlhdCI6MTc1MDI2Njg2MSwiZXhwIjoyMDY1ODQyODYxfQ.RS6RG0nbmxEqtO99dnpGnd7WV7C_uI0l_XJugKqOzPE';\n\n  if (!humanitixApiKey && fallbackHumanitixApiKey) {\n    humanitixApiKey = fallbackHumanitixApiKey.trim();\n  }\n  if (!supabaseUrl && fallbackSupabaseUrl) {\n    supabaseUrl = fallbackSupabaseUrl.trim().replace(/\\/$/, '');\n  }\n  if (!supabaseKey && fallbackSupabaseKey) {\n    supabaseKey = fallbackSupabaseKey.trim();\n  }\n\n  if (!supabaseKey) {\n    supabaseKey = (await readEnv('SUPABASE_SERVICE_KEY')).trim();\n  }\n\n  if (!supabaseUrl || !supabaseKey) {\n    try {\n      const supabaseCreds = await this.getCredentials('supabaseApi');\n      if (supabaseCreds) {\n        const credUrl =\n          supabaseCreds.host ||\n          supabaseCreds.url ||\n          supabaseCreds.restUrl ||\n          supabaseCreds.restApiUrl ||\n          '';\n        const credKey =\n          supabaseCreds.serviceRoleKey ||\n          supabaseCreds.serviceRoleSecret ||\n          supabaseCreds.apiKey ||\n          supabaseCreds.token ||\n          '';\n\n        if (!supabaseUrl && credUrl) {\n          supabaseUrl = String(credUrl).trim().replace(/\\/$/, '');\n          console.log('Supabase URL loaded from credentials.');\n        }\n        if (!supabaseKey && credKey) {\n          supabaseKey = String(credKey).trim();\n          console.log('Supabase service role key loaded from credentials.');\n        }\n      }\n    } catch (credError) {\n      if (!supabaseUrl || !supabaseKey) {\n        console.warn('Supabase credentials not attached; continuing to rely on environment variables.', credError?.message || credError);\n      }\n    }\n  }\n\n  if (!humanitixApiKey) {\n    const credentialAttempts = ['humanitixApi', 'httpHeaderAuth'];\n\n    for (const credName of credentialAttempts) {\n      try {\n        const creds = await this.getCredentials(credName);\n        if (!creds) continue;\n\n        const candidate =\n          creds.apiKey ||\n          creds.token ||\n          creds.key ||\n          creds.headerValue ||\n          creds.accessToken ||\n          (Array.isArray(creds.headers)\n            ? creds.headers.find((item) => item?.name?.toLowerCase().includes('key'))?.value\n            : '');\n\n        if (candidate) {\n          humanitixApiKey = String(candidate).trim();\n          console.log(`Humanitix API key loaded from credentials (${credName}).`);\n          break;\n        }\n      } catch (credError) {\n        if (credError?.message && !/No credential data/.test(credError.message)) {\n          console.warn(`Humanitix credential lookup for ${credName} failed:`, credError.message);\n        }\n      }\n    }\n  }\n\n  if (!humanitixApiKey) {\n    throw new Error('Missing Humanitix API key (set HUMANITIX_API_KEY or attach the Humanitix credential).');\n  }\n  if (!supabaseUrl) {\n    throw new Error('Missing Supabase URL (set SUPABASE_URL or attach the Supabase credential).');\n  }\n\n  if (!/^https?:\\/\\//i.test(supabaseUrl)) {\n    throw new Error(`Invalid Supabase URL: ${supabaseUrl}`);\n  }\n  if (!supabaseKey) {\n    throw new Error('Missing Supabase service role key (set SUPABASE_SERVICE_ROLE_KEY or attach the Supabase credential).');\n  }\n\n\n  const getStaticData = () => {\n    if (typeof this.getWorkflowStaticData === 'function') {\n      return this.getWorkflowStaticData('global');\n    }\n    if (typeof $workflow !== 'undefined' && typeof $workflow.getStaticData === 'function') {\n      return $workflow.getStaticData('global');\n    }\n    return {};\n  };\n\n  const setStaticData = (value) => {\n    if (typeof this.getWorkflowStaticData === 'function') {\n      this.getWorkflowStaticData('global').lastSync = value;\n      return;\n    }\n    if (typeof $workflow !== 'undefined' && typeof $workflow.getStaticData === 'function') {\n      $workflow.getStaticData('global').lastSync = value;\n    }\n  };\n\n  const staticData = getStaticData();\n  const defaultSince = '2022-01-01T00:00:00Z';\n  const lastSync = staticData.lastSync || defaultSince;\n  const syncStartedAt = new Date().toISOString();\n\n  const wait = (ms) => new Promise((resolve) => setTimeout(resolve, ms));\n\n  const humanitixBase = 'https://api.humanitix.com/v1';\n  const pageSize = 100;\n  const interRequestDelayMs = 1500;\n\n  const fetchHumanitix = async ({ path, resultKey, label, query = {} }) => {\n    let page = 1;\n    const records = [];\n\n    while (true) {\n      const response = await this.helpers.httpRequest({\n        method: 'GET',\n        url: `${humanitixBase}${path}`,\n        headers: { 'X-API-Key': humanitixApiKey },\n        qs: { page, pageSize, ...query },\n        json: true,\n      });\n\n      const data = resultKey ? response?.[resultKey] : response?.data;\n      const batch = Array.isArray(data)\n        ? data\n        : Array.isArray(response)\n        ? response\n        : [];\n\n      if (!Array.isArray(batch)) {\n        throw new Error(`Unexpected response structure while fetching ${label || path}`);\n      }\n\n      records.push(...batch);\n\n      const hasMore =\n        response?.meta?.pagination?.hasMore ??\n        (batch.length === pageSize);\n\n      if (!hasMore) {\n        break;\n      }\n\n      page += 1;\n      await wait(interRequestDelayMs);\n    }\n\n    return records;\n  };\n\n  const cents = (value) =>\n    typeof value === 'number' && Number.isFinite(value)\n      ? Math.round(value * 100)\n      : 0;\n\n  const toIso = (value) => {\n    if (!value) return null;\n    const d = new Date(value);\n    return Number.isNaN(d.getTime()) ? null : d.toISOString();\n  };\n\n  const boolOrNull = (value) =>\n    value === undefined || value === null ? null : Boolean(value);\n\n  const normalizeSessions = (event) => {\n    const sessionMap = new Map();\n\n    const register = (session, index, origin) => {\n      if (!session || typeof session !== 'object') return;\n\n      const candidateId =\n        session.session_id ||\n        session._id ||\n        session.id ||\n        session.sessionId ||\n        session.scheduleId ||\n        session.eventDateId ||\n        session.dateId;\n\n      const key =\n        candidateId || `${event._id || 'event'}-${origin}-${(index || 0) + 1}`;\n\n      if (!sessionMap.has(key)) {\n        sessionMap.set(key, { ...session, _id: candidateId || session._id || key });\n      }\n    };\n\n    const candidateArrays = [\n      ['sessions', event.sessions],\n      ['eventSessions', event.eventSessions],\n      ['multiDates', event.multiDates],\n      ['schedule', event.schedule],\n      ['timeslots', event.timeslots],\n    ];\n\n    candidateArrays.forEach(([origin, pool]) => {\n      if (!Array.isArray(pool)) return;\n      pool.forEach((session, index) => register(session, index, origin));\n    });\n\n    if (Array.isArray(event.dates)) {\n      event.dates.forEach((range, index) => {\n        if (!range || typeof range !== 'object') return;\n\n        const start =\n          range.startDateTime ||\n          range.startDate ||\n          range.start ||\n          (range.date && range.date.start) ||\n          null;\n        const end =\n          range.endDateTime ||\n          range.endDate ||\n          range.end ||\n          (range.date && range.date.end) ||\n          null;\n\n        const hydrated = {\n          ...range,\n          _id:\n            range._id ||\n            range.session_id ||\n            range.id ||\n            range.scheduleId ||\n            range.eventDateId ||\n            `${event._id || 'event'}-date-${index + 1}`,\n          name:\n            range.name ||\n            range.title ||\n            event.name ||\n            'Session',\n          startDateTime: start,\n          endDateTime: end,\n        };\n\n        register(hydrated, index, 'dates');\n      });\n    }\n\n    return Array.from(sessionMap.values());\n  };\n\n  const supabaseRequest = async ({ table, rows }) => {\n    const validationErrors = rows\n      .map((row, index) => ({ index: index + 1, missing: [] }))\n      .map((item, idx) => {\n        const row = rows[idx];\n        if (!row.source) item.missing.push('source');\n        if (!row.source_id) item.missing.push('source_id');\n        return item;\n      })\n      .filter((item) => item.missing.length);\n\n    if (validationErrors.length) {\n      throw new Error(`Supabase payload validation failed: ${JSON.stringify(validationErrors)}`);\n    }\n\n    const chunkSize = 50;\n    console.log(`Upserting ${rows.length} rows into ${table}`);\n    for (let i = 0; i < rows.length; i += chunkSize) {\n      const chunk = rows.slice(i, i + chunkSize);\n      const response = await this.helpers.httpRequest({\n        method: 'POST',\n        url: `${supabaseUrl}/rest/v1/${table}?on_conflict=source,source_id`,\n        headers: {\n          apikey: supabaseKey,\n          Authorization: `Bearer ${supabaseKey}`,\n          'Content-Type': 'application/json',\n          Prefer: 'resolution=merge-duplicates,return=representation',\n        },\n        body: chunk,\n        json: true,\n        resolveWithFullResponse: true,\n        returnFullResponse: true,\n        simple: false,\n      });\n\n      if (response.status >= 400) {\n        console.error('Supabase error response:', response.data);\n        throw new Error(`Supabase ${table} upsert failed with status ${response.status}: ${JSON.stringify(response.data)}`);\n      }\n\n      await wait(500);\n    }\n  };\n\n  const upsertTable = async (table, rows) => {\n    if (!rows.length) return;\n\n    const chunkSize = 50;\n    console.log(`Upserting ${rows.length} rows into ${table}`);\n\n    for (let i = 0; i < rows.length; i += chunkSize) {\n      const chunk = rows.slice(i, i + chunkSize);\n      try {\n        await this.helpers.httpRequest({\n          method: 'POST',\n          url: `${supabaseUrl}/rest/v1/${table}?on_conflict=source,source_id`,\n          headers: {\n            apikey: supabaseKey,\n            Authorization: `Bearer ${supabaseKey}`,\n            'Content-Type': 'application/json',\n            Prefer: 'resolution=merge-duplicates,return=representation',\n          },\n          body: chunk,\n          json: true,\n        });\n        await wait(500);\n      } catch (error) {\n        const status = error.response?.status ?? error.status ?? error.code ?? 'unknown';\n        const data = error.response?.data ?? error.message ?? null;\n        const body = error.response?.body ?? null;\n        const identifiers = Array.isArray(chunk) ? chunk.map((row) => row?.source_id ?? row?.id ?? null) : null;\n        console.error(`Supabase upsert error for ${table}:`, { status, data, message: error.message, code: error.code, body, identifiers });\n        throw new Error(`Supabase upsert failed for ${table} with status ${status}. Response: ${JSON.stringify(data ?? body)}`);\n      }\n    }\n  };\n\n  const upsertSessionSources = async (rows) => {\n    if (!rows.length) return;\n\n    const chunkSize = 100;\n    for (let i = 0; i < rows.length; i += chunkSize) {\n      const chunk = rows.slice(i, i + chunkSize);\n      try {\n        await this.helpers.httpRequest({\n          method: 'POST',\n          url: `${supabaseUrl}/rest/v1/session_sources?on_conflict=source,source_session_id`,\n          headers: {\n            apikey: supabaseKey,\n            Authorization: `Bearer ${supabaseKey}`,\n            'Content-Type': 'application/json',\n            Prefer: 'resolution=merge-duplicates,return=representation',\n          },\n          body: chunk,\n          json: true,\n        });\n        await wait(200);\n      } catch (error) {\n        const status = error.response?.status ?? error.status ?? error.code ?? 'unknown';\n        const data = error.response?.data ?? error.message ?? null;\n        const body = error.response?.body ?? null;\n        throw new Error(`Supabase upsert failed for session_sources with status ${status}. Response: ${JSON.stringify(data ?? body)}`);\n      }\n    }\n  };\n\n  const events = await fetchHumanitix({\n    path: '/events',\n    resultKey: 'events',\n    label: 'events',\n    query: { since: lastSync },\n  });\n\n  console.log(`Fetched ${events.length} events since ${lastSync}`);\n\n  const eventsPayload = [];\n  const sessionsPayload = [];\n  const sessionSourcesPayload = [];\n  const ordersPayload = [];\n  const ticketsPayload = [];\n\n  for (const event of events) {\n    if (!event?._id) continue;\n\n    const eventCurrency = event.currency || event.defaultCurrency || event.financialCurrency || null;\n\n    eventsPayload.push({\n      source: 'humanitix',\n      source_id: event._id,\n      name: event.name || '',\n      description: event.description || event.summary || '',\n      slug: event.slug || event.identifier || '',\n      url: event.url || event.publicUrl || event.eventUrl || '',\n      start_date:\n        event.startDateTime ||\n        event.startDate ||\n        event.start ||\n        event.eventStart ||\n        null,\n      end_date:\n        event.endDateTime ||\n        event.endDate ||\n        event.end ||\n        event.eventEnd ||\n        null,\n      timezone: event.timezone || event.timeZone || event.eventLocation?.timezone || event.eventLocation?.timeZone || '',\n      status: event.status || event.state || event.visibility || null,\n      total_capacity:\n        event.totalCapacity ?? event.total_capacity ?? event.capacity ?? null,\n      public: boolOrNull(event.public),\n      published: boolOrNull(event.published),\n      venue_name:\n        event.eventLocation?.venueName ||\n        event.venueName ||\n        event.venue?.name ||\n        null,\n      venue_address:\n        event.eventLocation?.address ||\n        event.address ||\n        event.venue?.address ||\n        null,\n      venue_city:\n        event.eventLocation?.city ||\n        event.city ||\n        event.venue?.city ||\n        null,\n      venue_country:\n        event.eventLocation?.country ||\n        event.country ||\n        event.venue?.country ||\n        null,\n      currency: eventCurrency,\n      created_at: toIso(event.createdAt),\n      updated_at: toIso(event.updatedAt),\n      ingested_at: syncStartedAt,\n      updated_at_api: toIso(event.updatedAt || event.modifiedAt || event.lastUpdated),\n      raw: event || {},\n    });\n\n    const sessions = normalizeSessions(event);\n    sessions.forEach((session, index) => {\n      const sessionId =\n        session.session_id ||\n        session._id ||\n        session.id ||\n        session.sessionId ||\n        session.scheduleId ||\n        session.eventDateId ||\n        `${event._id}-session-${index + 1}`;\n\n      sessionsPayload.push({\n        source: 'humanitix',\n        source_id: sessionId,\n        event_source_id: event._id,\n        name: session.name || session.title || event.name || null,\n        start_date:\n          session.startDateTime ||\n          session.startDate ||\n          session.start ||\n          session.date?.start ||\n          null,\n        end_date:\n          session.endDateTime ||\n          session.endDate ||\n          session.end ||\n          session.date?.end ||\n          null,\n        timezone:\n          session.timezone ||\n          session.timeZone ||\n          event.timezone ||\n          event.timeZone ||\n          null,\n        venue_name:\n          session.venueName ||\n          session.venue?.name ||\n          event.eventLocation?.venueName ||\n          null,\n        created_at: toIso(session.createdAt),\n        updated_at: toIso(session.updatedAt),\n        ingested_at: syncStartedAt,\n        updated_at_api: toIso(session.updatedAt || session.modifiedAt || session.lastUpdated),\n        raw: session || {},\n      });\n\n      sessionSourcesPayload.push({\n        canonical_source: 'humanitix',\n        canonical_session_source_id: sessionId,\n        source: 'humanitix',\n        source_session_id: sessionId,\n        source_event_id: event._id,\n      });\n    });\n\n    const orders = await fetchHumanitix({\n      path: `/events/${event._id}/orders`,\n      resultKey: 'orders',\n      label: `orders for ${event._id}`,\n      query: { since: lastSync },\n    });\n\n    orders.forEach((order) => {\n      const totals = order.totals || {};\n      const purchaseTotals = order.purchaseTotals || order.purchase_totals || {};\n      const totalDonations = order.donationTotals || order.donations || {};\n      const marketing = order.marketing || {};\n\n      const firstName = order.firstName || order.purchaserFirstName || null;\n      const lastName = order.lastName || order.purchaserLastName || null;\n      const purchaserName = `${firstName || ''} ${lastName || ''}`.trim() || null;\n\n      ordersPayload.push({\n        source: 'humanitix',\n        source_id: order._id,\n        user_id: order.userId || order.user_id || null,\n        event_source_id: order.eventId || event._id,\n        session_source_id: order.eventDateId || order.sessionId || null,\n        order_reference: order.reference || order.orderReference || order._id,\n        status: order.status || null,\n        financial_status: order.financialStatus || order.paymentStatus || null,\n        manual_order: boolOrNull(order.manualOrder),\n        sales_channel: order.salesChannel || order.channel || null,\n        is_international_transaction: boolOrNull(order.isInternationalTransaction || order.international),\n        first_name: firstName,\n        last_name: lastName,\n        purchaser_name: purchaserName,\n        purchaser_email: order.email || order.contactEmail || null,\n        mobile: order.mobile || order.phoneNumber || order.phone || null,\n        organisation: order.organisation || order.organization || null,\n        business_purpose: boolOrNull(order.businessPurpose || order.business?.purpose),\n        business_tax_id: order.businessTaxId || order.business?.taxId || null,\n        business_name: order.businessName || order.business?.name || null,\n        payment_type: order.paymentType || order.payment?.type || null,\n        payment_gateway: order.paymentGateway || order.payment?.gateway || null,\n        tip_fees: boolOrNull(order.tipFees),\n        currency: order.currency || eventCurrency,\n        access_code: order.accessCode || null,\n        organiser_mail_list_opt_in: boolOrNull(order.organiserMailListOptIn ?? marketing.mailListOptIn ?? order.mailListOptIn),\n        waitlist_offer_id: order.waitlistOfferId || order.waitlistOfferID || null,\n        discount_code_used: order.discountCodeUsed || order.discountCode || null,\n        discount_code_amount_cents: cents(order.discountCodeAmount || order.discountCode?.amount),\n        auto_discount_amount_cents: cents(order.autoDiscountAmount || order.autoDiscount?.amount),\n        client_donation_cents: cents(order.clientDonation || order.donation?.clientAmount),\n        total_cents: cents(totals.total),\n        subtotal_cents: cents(totals.subtotal),\n        net_sales_cents: cents(totals.netSales),\n        gross_sales_cents: cents(totals.grossSales),\n        discounts_cents: cents(totals.discounts ?? totals.discount),\n        taxes_cents: cents(totals.taxes ?? totals.tax),\n        humanitix_fee_cents: cents(totals.humanitixFee),\n        booking_fee_cents: cents(totals.bookingFee),\n        passed_on_fee_cents: cents(totals.passedOnFee),\n        amex_fee_cents: cents(totals.amexFee),\n        zip_fee_cents: cents(totals.zipFee),\n        booking_taxes_cents: cents(totals.bookingTaxes),\n        passed_on_taxes_cents: cents(totals.passedOnTaxes),\n        total_taxes_cents: cents(totals.totalTaxes),\n        order_client_donation_cents: cents(totalDonations.client || totalDonations.clientDonation),\n        net_client_donation_cents: cents(totalDonations.net || totalDonations.netDonation),\n        donation_cents: cents(totalDonations.total || totalDonations.donation),\n        dgr_donation_cents: cents(totalDonations.dgr || totalDonations.dgrDonation),\n        gift_card_credit_cents: cents(totals.giftCardCredit),\n        credit_cents: cents(totals.credit),\n        refunds_cents: cents(totals.refunds),\n        referral_amount_cents: cents(totals.referralAmount),\n        outstanding_amount_cents: cents(totals.outstanding),\n        purchase_total_cents: cents(purchaseTotals.total),\n        purchase_subtotal_cents: cents(purchaseTotals.subtotal),\n        purchase_net_sales_cents: cents(purchaseTotals.netSales),\n        purchase_gross_sales_cents: cents(purchaseTotals.grossSales),\n        purchase_humanitix_fee_cents: cents(purchaseTotals.humanitixFee),\n        purchase_booking_fee_cents: cents(purchaseTotals.bookingFee),\n        purchase_discounts_cents: cents(purchaseTotals.discounts),\n        purchase_refunds_cents: cents(purchaseTotals.refunds),\n        fees_included: boolOrNull(totals.feesIncluded ?? order.feesIncluded),\n        purchase_fees_included: boolOrNull(purchaseTotals.feesIncluded),\n        created_at: toIso(order.createdAt),\n        updated_at: toIso(order.updatedAt),\n        incomplete_at: toIso(order.incompleteAt),\n        completed_at: toIso(order.completedAt),\n        ordered_at: toIso(order.completedAt || order.createdAt),\n        location: order.location || order.venueLocation || null,\n        notes: order.notes || order.internalNotes || null,\n        additional_fields: order.additionalFields || order.metadata || null,\n        raw: order,\n        ingested_at: syncStartedAt,\n        updated_at_api: toIso(order.updatedAt || order.modifiedAt || order.completedAt),\n      });\n    });\n\n    const tickets = await fetchHumanitix({\n      path: `/events/${event._id}/tickets`,\n      resultKey: 'tickets',\n      label: `tickets for ${event._id}`,\n      query: { since: lastSync },\n    });\n\n    tickets.forEach((ticket) => {\n      const checkIn = ticket.checkIn || {};\n      const seating = ticket.seatingLocation || ticket.seating || {};\n      const discounts = ticket.discounts || {};\n      const discountCode = discounts.discountCode || ticket.discountCode || {};\n      const autoDiscount = discounts.autoDiscount || {};\n      const packageInfo = ticket.package || ticket.packageInfo || {};\n      const attendeeProfile = ticket.attendee || {};\n      const history = Array.isArray(ticket.checkInHistory)\n        ? ticket.checkInHistory\n        : Array.isArray(checkIn.history)\n        ? checkIn.history\n        : null;\n\n      ticketsPayload.push({\n        source: 'humanitix',\n        source_id: ticket._id,\n        event_source_id: ticket.eventId || event._id,\n        order_source_id: ticket.orderId || null,\n        session_source_id: ticket.eventDateId || ticket.sessionId || null,\n        ticket_type_id: ticket.ticketTypeId || ticket.ticketType?.id || null,\n        ticket_type_name: ticket.ticketTypeName || ticket.ticketType?.name || null,\n        ticket_number: ticket.number || ticket.ticketNumber || null,\n        first_name: ticket.firstName || attendeeProfile.firstName || null,\n        last_name: ticket.lastName || attendeeProfile.lastName || null,\n        organisation: ticket.organisation || ticket.organization || null,\n        attendee_profile_id: ticket.attendeeProfileId || attendeeProfile.profileId || null,\n        price_cents: cents(ticket.price),\n        net_price_cents: cents(ticket.netPrice),\n        total_cents: cents(ticket.total),\n        discount_cents: cents(ticket.discount),\n        taxes_cents: cents(ticket.taxes),\n        fee_cents: cents(ticket.fee),\n        passed_on_fee_cents: cents(ticket.passedOnFee),\n        absorbed_fee_cents: cents(ticket.absorbedFee),\n        dgr_donation_cents: cents(ticket.dgrDonation),\n        package_id: packageInfo.id || packageInfo.packageId || null,\n        package_name: packageInfo.name || null,\n        package_group_id: packageInfo.groupId || packageInfo.group_id || null,\n        package_price_cents: cents(packageInfo.price),\n        discount_code_used: discountCode.code || null,\n        discount_code_amount_cents: cents(discountCode.discountAmount || discountCode.amount),\n        auto_discount_amount_cents: cents(autoDiscount.discountAmount || autoDiscount.amount),\n        status: ticket.status || null,\n        sales_channel: ticket.salesChannel || null,\n        is_donation: boolOrNull(ticket.isDonation),\n        cancelled_at: toIso(ticket.cancelledAt),\n        checked_in: boolOrNull(checkIn.checkedIn),\n        check_in_status: checkIn.status || null,\n        check_in_date: toIso(checkIn.checkedInAt),\n        check_in_device: checkIn.device || null,\n        check_in_location: checkIn.location || null,\n        check_in_notes: checkIn.notes || null,\n        seating_map_id: seating.seatingMapId || seating.mapId || null,\n        seating_name: seating.name || null,\n        seating_section: seating.section || null,\n        seating_table: seating.table || null,\n        seating_seat: seating.seat || null,\n        seating_note: seating.note || null,\n        barcode: ticket.qrCodeData?._id || ticket.barcode || ticket.customScanningCode || null,\n        qr_code_data: ticket.qrCodeData || null,\n        custom_scanning_code: ticket.customScanningCode || null,\n        access_code: ticket.accessCode || null,\n        swapped_from: ticket.swappedFrom || null,\n        swapped_to: ticket.swappedTo || null,\n        currency: ticket.currency || eventCurrency,\n        location: ticket.location || null,\n        order_name: ticket.orderName || null,\n        additional_fields: ticket.additionalFields || ticket.metadata || null,\n        check_in_history: history,\n        raw: ticket,\n        created_at: toIso(ticket.createdAt),\n        updated_at: toIso(ticket.updatedAt),\n        ingested_at: syncStartedAt,\n        updated_at_api: toIso(ticket.updatedAt || checkIn.checkedInAt || ticket.modifiedAt),\n      });\n    });\n\n    await wait(500);\n  }\n\n  await upsertTable('events_htx', eventsPayload);\n  await upsertTable('sessions_htx', sessionsPayload);\n  await upsertSessionSources(sessionSourcesPayload);\n  await upsertTable('orders_htx', ordersPayload);\n  await upsertTable('tickets_htx', ticketsPayload);\n\n  setStaticData(syncStartedAt);\n\n  console.log(\n    `Sync complete. Events: ${eventsPayload.length}, Sessions: ${sessionsPayload.length}, Orders: ${ordersPayload.length}, Tickets: ${ticketsPayload.length}`\n  );\n\n  return [\n    {\n      json: {\n        lastSyncUsed: lastSync,\n        syncedAt: syncStartedAt,\n        events: eventsPayload.length,\n        sessions: sessionsPayload.length,\n        orders: ordersPayload.length,\n        tickets: ticketsPayload.length,\n      },\n    },\n  ];\n}\n\nreturn run.call(this);\n"
      },
      "id": "6c91c462-633a-48e1-b842-8c9d8bf995ac",
      "name": "Sync Humanitix to Supabase",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        224,
        0
      ]
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 10
            }
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        0,
        0
      ],
      "id": "6dfbc6d2-3bdc-48b5-8307-ab0ff91ba437",
      "name": "Schedule Trigger"
    }
  ],
  "pinData": {},
  "connections": {
    "Schedule Trigger": {
      "main": [
        [
          {
            "node": "Sync Humanitix to Supabase",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "timezone": "Australia/Sydney",
    "callerPolicy": "workflowsFromSameOwner",
    "availableInMCP": false
  },
  "versionId": "3d012723-ee6b-4ff0-bbcc-54c697adece7",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "f7982260359ec38ac1c22ac6f7afe7d220775ffc19f83939f161a55b37bcebf7"
  },
  "id": "GlfFnsZVkhM1tUYt",
  "tags": []
}