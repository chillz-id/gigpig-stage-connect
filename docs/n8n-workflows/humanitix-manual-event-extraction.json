{
  "name": "Humanitix Manual Event-Specific Extraction",
  "nodes": [
    {
      "parameters": {
        "options": {
          "webhookId": "humanitix-manual-extraction"
        }
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "webhookId": "humanitix-manual-extraction"
    },
    {
      "parameters": {
        "jsCode": "// Manual event extraction configuration\n// Accepts webhook payload with specific event IDs or date ranges\n\nconst payload = $json;\n\n// Extract configuration from webhook payload\nconst config = {\n  extractionType: payload.extractionType || 'specific-events', // 'specific-events', 'date-range', 'all-events'\n  eventIds: payload.eventIds || [], // Array of specific event IDs\n  dateRange: payload.dateRange || {\n    start: new Date(new Date().setDate(new Date().getDate() - 7)).toISOString(), // Last 7 days\n    end: new Date().toISOString()\n  },\n  includeFinancials: payload.includeFinancials !== false, // Default true\n  includeCustomers: payload.includeCustomers !== false, // Default true\n  generateInvoice: payload.generateInvoice || false,\n  outputFormat: payload.outputFormat || 'detailed', // 'summary', 'detailed', 'invoice'\n  requestedBy: payload.requestedBy || 'manual-trigger',\n  priority: payload.priority || 'normal' // 'low', 'normal', 'high', 'urgent'\n};\n\n// Validation\nif (config.extractionType === 'specific-events' && config.eventIds.length === 0) {\n  throw new Error('Event IDs must be provided for specific event extraction');\n}\n\n// Performance settings based on priority\nconst performanceSettings = {\n  low: { batchSize: 10, rateLimitDelay: 2000, maxRetries: 2 },\n  normal: { batchSize: 25, rateLimitDelay: 1000, maxRetries: 3 },\n  high: { batchSize: 50, rateLimitDelay: 500, maxRetries: 5 },\n  urgent: { batchSize: 100, rateLimitDelay: 100, maxRetries: 10 }\n};\n\n// Output configuration\nconst outputConfig = {\n  summary: {\n    includeOrderDetails: false,\n    includeCustomerDetails: false,\n    includeTicketBreakdown: false\n  },\n  detailed: {\n    includeOrderDetails: true,\n    includeCustomerDetails: true,\n    includeTicketBreakdown: true\n  },\n  invoice: {\n    includeOrderDetails: true,\n    includeCustomerDetails: true,\n    includeTicketBreakdown: true,\n    generatePDF: true,\n    calculatePartnerShare: true\n  }\n};\n\nreturn [{\n  json: {\n    config,\n    performance: performanceSettings[config.priority],\n    outputSettings: outputConfig[config.outputFormat],\n    timestamp: new Date().toISOString(),\n    requestId: `manual-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`\n  }\n}];"
      },
      "id": "configure-manual-extraction",
      "name": "Configure Manual Extraction",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "extraction-type-check",
              "leftValue": "={{ $json.config.extractionType }}",
              "rightValue": "specific-events",
              "operator": {
                "type": "string",
                "operation": "equals",
                "rightType": "string"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "if-specific-events",
      "name": "IF Specific Events",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [680, 300]
    },
    {
      "parameters": {
        "jsCode": "// Extract specific events by ID\nconst config = $json.config;\nconst eventIds = config.eventIds;\n\n// Create individual requests for each event ID\nconst eventRequests = eventIds.map(eventId => ({\n  json: {\n    eventId,\n    extractionConfig: config,\n    requestType: 'specific-event'\n  }\n}));\n\nreturn eventRequests;"
      },
      "id": "prepare-specific-events",
      "name": "Prepare Specific Events",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 260]
    },
    {
      "parameters": {
        "url": "https://api.humanitix.com/v1/events",
        "authentication": "headerAuth",
        "headerAuth": {
          "name": "X-API-Key",
          "value": "{{ $env.HUMANITIX_API_KEY }}"
        },
        "options": {
          "qs": {
            "page": "1",
            "limit": "100",
            "created_after": "={{ $json.config.dateRange.start }}",
            "created_before": "={{ $json.config.dateRange.end }}",
            "status": "all"
          }
        }
      },
      "id": "fetch-events-by-date",
      "name": "Fetch Events by Date",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [900, 360]
    },
    {
      "parameters": {
        "url": "=https://api.humanitix.com/v1/events/{{ $json.eventId }}",
        "authentication": "headerAuth",
        "headerAuth": {
          "name": "X-API-Key",
          "value": "{{ $env.HUMANITIX_API_KEY }}"
        },
        "options": {}
      },
      "id": "fetch-specific-event",
      "name": "Fetch Specific Event",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1120, 260]
    },
    {
      "parameters": {
        "mode": "chooseBranch",
        "output": "input1"
      },
      "id": "merge-event-sources",
      "name": "Merge Event Sources",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [1340, 300]
    },
    {
      "parameters": {
        "jsCode": "// Process events from different sources\nconst eventData = $json;\nconst config = $node['Configure Manual Extraction'].json.config;\n\n// Handle different event data structures\nlet events = [];\n\nif (eventData.data && Array.isArray(eventData.data)) {\n  // From date range fetch\n  events = eventData.data;\n} else if (eventData.id) {\n  // From specific event fetch\n  events = [eventData];\n} else {\n  // Single event object\n  events = [eventData];\n}\n\n// Process each event\nconst processedEvents = events.map(event => ({\n  id: event.id,\n  name: event.name,\n  description: event.description,\n  startDate: event.startDate,\n  endDate: event.endDate,\n  venue: event.venue,\n  status: event.status,\n  ticketsSold: event.ticketsSold || 0,\n  grossRevenue: event.grossRevenue || 0,\n  url: event.url,\n  createdAt: event.createdAt,\n  updatedAt: event.updatedAt,\n  extractionConfig: config\n}));\n\nreturn processedEvents.map(event => ({ json: event }));"
      },
      "id": "process-events",
      "name": "Process Events",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1560, 300]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "split-events",
      "name": "Split Events",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [1780, 300]
    },
    {
      "parameters": {
        "url": "=https://api.humanitix.com/v1/events/{{ $json.id }}/tickets",
        "authentication": "headerAuth",
        "headerAuth": {
          "name": "X-API-Key",
          "value": "{{ $env.HUMANITIX_API_KEY }}"
        },
        "options": {
          "qs": {
            "page": "1",
            "limit": "100"
          }
        }
      },
      "id": "fetch-tickets",
      "name": "Fetch Tickets",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2000, 260]
    },
    {
      "parameters": {
        "url": "=https://api.humanitix.com/v1/events/{{ $json.id }}/orders",
        "authentication": "headerAuth",
        "headerAuth": {
          "name": "X-API-Key",
          "value": "{{ $env.HUMANITIX_API_KEY }}"
        },
        "options": {
          "qs": {
            "page": "1",
            "limit": "100",
            "status": "all"
          }
        }
      },
      "id": "fetch-orders",
      "name": "Fetch Orders",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2000, 340]
    },
    {
      "parameters": {
        "jsCode": "// Process complete event data with all related information\nconst eventData = $node['Split Events'].json;\nconst ticketsResponse = $node['Fetch Tickets'].json;\nconst ordersResponse = $node['Fetch Orders'].json;\nconst config = eventData.extractionConfig;\nconst outputSettings = $node['Configure Manual Extraction'].json.outputSettings;\n\n// Process ticket types\nconst ticketTypes = (ticketsResponse.data || []).map(ticket => ({\n  id: ticket.id,\n  name: ticket.name,\n  price: ticket.price || 0,\n  quantityAvailable: ticket.quantityAvailable || 0,\n  quantitySold: ticket.quantitySold || 0,\n  status: ticket.status\n}));\n\n// Process orders with comprehensive financial data\nconst orders = (ordersResponse.data || []).map(order => {\n  const subtotal = order.subtotal || 0;\n  const fees = {\n    humanitix: order.totals?.humanitixFee || 0,\n    booking: order.totals?.bookingFee || 0,\n    passedOn: order.totals?.passedOnFee || 0,\n    absorbed: order.totals?.absorbedFee || 0,\n    amex: order.totals?.amexFee || 0,\n    zip: order.totals?.zipFee || 0\n  };\n  \n  const discounts = order.totals?.discounts || 0;\n  const refunds = order.totals?.refunds || 0;\n  const rebates = order.totals?.rebates || 0;\n  const total = order.total || 0;\n  \n  // Calculate partner share\n  const partnerShare = subtotal - discounts - refunds - rebates - fees.passedOn;\n  \n  const orderData = {\n    id: order.id,\n    orderName: order.orderName,\n    eventId: eventData.id,\n    customer: {\n      email: order.email,\n      firstName: order.firstName,\n      lastName: order.lastName,\n      mobile: order.mobile,\n      location: order.location || 'AU'\n    },\n    tickets: order.tickets || [],\n    financials: {\n      subtotal,\n      fees,\n      discounts,\n      refunds,\n      rebates,\n      total,\n      partnerShare\n    },\n    status: order.status,\n    financialStatus: order.financialStatus,\n    paymentGateway: order.paymentGateway,\n    createdAt: order.createdAt,\n    completedAt: order.completedAt\n  };\n  \n  // Filter data based on output settings\n  if (!outputSettings.includeCustomerDetails) {\n    delete orderData.customer;\n  }\n  if (!outputSettings.includeTicketBreakdown) {\n    delete orderData.tickets;\n  }\n  \n  return orderData;\n});\n\n// Calculate event summary\nconst eventSummary = {\n  totalOrders: orders.length,\n  totalRevenue: orders.reduce((sum, order) => sum + order.financials.total, 0),\n  totalPartnerShare: orders.reduce((sum, order) => sum + order.financials.partnerShare, 0),\n  totalFees: orders.reduce((sum, order) => sum + Object.values(order.financials.fees).reduce((a, b) => a + b, 0), 0),\n  totalDiscounts: orders.reduce((sum, order) => sum + order.financials.discounts, 0),\n  totalRefunds: orders.reduce((sum, order) => sum + order.financials.refunds, 0),\n  averageOrderValue: orders.length > 0 ? orders.reduce((sum, order) => sum + order.financials.total, 0) / orders.length : 0\n};\n\n// Create complete event data\nconst completeEventData = {\n  event: {\n    id: eventData.id,\n    name: eventData.name,\n    description: eventData.description,\n    startDate: eventData.startDate,\n    endDate: eventData.endDate,\n    venue: eventData.venue,\n    status: eventData.status,\n    ticketsSold: eventData.ticketsSold,\n    grossRevenue: eventData.grossRevenue,\n    url: eventData.url,\n    createdAt: eventData.createdAt,\n    updatedAt: eventData.updatedAt\n  },\n  ticketTypes,\n  orders: outputSettings.includeOrderDetails ? orders : [],\n  summary: eventSummary,\n  extractionMetadata: {\n    extractionType: config.extractionType,\n    extractedAt: new Date().toISOString(),\n    requestId: $node['Configure Manual Extraction'].json.requestId,\n    requestedBy: config.requestedBy,\n    outputFormat: config.outputFormat,\n    priority: config.priority\n  }\n};\n\nreturn [{ json: completeEventData }];"
      },
      "id": "process-complete-data",
      "name": "Process Complete Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2220, 300]
    },
    {
      "parameters": {
        "amount": "={{ $node['Configure Manual Extraction'].json.performance.rateLimitDelay }}",
        "unit": "milliseconds"
      },
      "id": "dynamic-rate-limit",
      "name": "Dynamic Rate Limit",
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1,
      "position": [2440, 300]
    },
    {
      "parameters": {
        "mode": "chooseBranch",
        "output": "input1"
      },
      "id": "merge-all-events",
      "name": "Merge All Events",
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [2660, 300]
    },
    {
      "parameters": {
        "jsCode": "// Generate final extraction report\nconst allEventData = $input.all();\nconst config = $node['Configure Manual Extraction'].json.config;\nconst requestId = $node['Configure Manual Extraction'].json.requestId;\n\n// Create comprehensive extraction report\nconst extractionReport = {\n  requestInfo: {\n    requestId,\n    extractionType: config.extractionType,\n    requestedBy: config.requestedBy,\n    priority: config.priority,\n    outputFormat: config.outputFormat,\n    requestedAt: $node['Configure Manual Extraction'].json.timestamp,\n    completedAt: new Date().toISOString()\n  },\n  \n  extractionSummary: {\n    totalEventsExtracted: allEventData.length,\n    totalOrders: allEventData.reduce((sum, event) => sum + event.json.summary.totalOrders, 0),\n    totalRevenue: allEventData.reduce((sum, event) => sum + event.json.summary.totalRevenue, 0),\n    totalPartnerShare: allEventData.reduce((sum, event) => sum + event.json.summary.totalPartnerShare, 0),\n    totalFees: allEventData.reduce((sum, event) => sum + event.json.summary.totalFees, 0),\n    totalDiscounts: allEventData.reduce((sum, event) => sum + event.json.summary.totalDiscounts, 0),\n    totalRefunds: allEventData.reduce((sum, event) => sum + event.json.summary.totalRefunds, 0),\n    averageOrderValue: allEventData.length > 0 ? allEventData.reduce((sum, event) => sum + event.json.summary.averageOrderValue, 0) / allEventData.length : 0\n  },\n  \n  eventDetails: allEventData.map(event => ({\n    eventId: event.json.event.id,\n    eventName: event.json.event.name,\n    eventDate: event.json.event.startDate,\n    venue: event.json.event.venue?.name || 'TBD',\n    status: event.json.event.status,\n    summary: event.json.summary,\n    ticketTypes: event.json.ticketTypes.length,\n    orders: event.json.orders.length\n  })),\n  \n  // Include full event data if detailed output\n  fullEventData: config.outputFormat === 'detailed' ? allEventData.map(event => event.json) : undefined,\n  \n  // Generate invoice data if requested\n  invoiceData: config.generateInvoice ? {\n    invoiceId: `MANUAL-${requestId}`,\n    generatedAt: new Date().toISOString(),\n    totalAmount: allEventData.reduce((sum, event) => sum + event.json.summary.totalPartnerShare, 0),\n    currency: 'AUD',\n    events: allEventData.map(event => ({\n      eventId: event.json.event.id,\n      eventName: event.json.event.name,\n      eventDate: event.json.event.startDate,\n      partnerShare: event.json.summary.totalPartnerShare,\n      orderCount: event.json.summary.totalOrders\n    }))\n  } : undefined,\n  \n  dataQuality: {\n    extractionSuccess: true,\n    dataCompleteness: 100,\n    processingTime: new Date().getTime() - new Date($node['Configure Manual Extraction'].json.timestamp).getTime(),\n    apiCallsUsed: allEventData.length * 3, // events + tickets + orders per event\n    rateLimitRespected: true\n  }\n};\n\nreturn [{ json: extractionReport }];"
      },
      "id": "generate-extraction-report",
      "name": "Generate Extraction Report",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2880, 300]
    },
    {
      "parameters": {
        "operation": "write",
        "fileName": "=manual-extraction-{{ $json.requestInfo.requestId }}.json",
        "fileContent": "={{ JSON.stringify($json, null, 2) }}",
        "options": {
          "encoding": "utf8"
        }
      },
      "id": "save-extraction-report",
      "name": "Save Extraction Report",
      "type": "n8n-nodes-base.filesys",
      "typeVersion": 1,
      "position": [3100, 300]
    },
    {
      "parameters": {
        "channel": "={{ $env.SLACK_CHANNEL }}",
        "text": "=✅ **Manual Humanitix Extraction Complete!**\n\n🎯 **Request Details:**\n• **Request ID:** {{ $json.requestInfo.requestId }}\n• **Extraction Type:** {{ $json.requestInfo.extractionType }}\n• **Requested By:** {{ $json.requestInfo.requestedBy }}\n• **Priority:** {{ $json.requestInfo.priority }}\n• **Output Format:** {{ $json.requestInfo.outputFormat }}\n\n📊 **Extraction Summary:**\n• **Events Extracted:** {{ $json.extractionSummary.totalEventsExtracted }}\n• **Total Orders:** {{ $json.extractionSummary.totalOrders }}\n• **Total Revenue:** ${{ $json.extractionSummary.totalRevenue.toFixed(2) }}\n• **Partner Share:** ${{ $json.extractionSummary.totalPartnerShare.toFixed(2) }}\n• **Average Order Value:** ${{ $json.extractionSummary.averageOrderValue.toFixed(2) }}\n\n🎫 **Event Breakdown:**\n{{ $json.eventDetails.map(event => `• **${event.eventName}** (${new Date(event.eventDate).toLocaleDateString()}): ${event.orders} orders, $${event.summary.totalRevenue.toFixed(2)} revenue`).join('\\n') }}\n\n⚡ **Performance:**\n• **Processing Time:** {{ $json.dataQuality.processingTime }}ms\n• **API Calls Used:** {{ $json.dataQuality.apiCallsUsed }}\n• **Data Completeness:** {{ $json.dataQuality.dataCompleteness }}%\n\n💾 **Output:** manual-extraction-{{ $json.requestInfo.requestId }}.json\n\n{{ $json.invoiceData ? `💰 **Invoice Generated:** ${$json.invoiceData.invoiceId} - $${$json.invoiceData.totalAmount.toFixed(2)}` : '' }}\n\n🚀 Manual extraction successful!"
      },
      "id": "notify-completion",
      "name": "Notify Completion",
      "type": "@modelcontextprotocol/server-slack.sendMessage",
      "typeVersion": 1,
      "position": [3320, 300]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Configure Manual Extraction",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Configure Manual Extraction": {
      "main": [
        [
          {
            "node": "IF Specific Events",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Specific Events": {
      "main": [
        [
          {
            "node": "Prepare Specific Events",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Fetch Events by Date",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Specific Events": {
      "main": [
        [
          {
            "node": "Fetch Specific Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Events by Date": {
      "main": [
        [
          {
            "node": "Merge Event Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Specific Event": {
      "main": [
        [
          {
            "node": "Merge Event Sources",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Event Sources": {
      "main": [
        [
          {
            "node": "Process Events",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Events": {
      "main": [
        [
          {
            "node": "Split Events",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Events": {
      "main": [
        [
          {
            "node": "Fetch Tickets",
            "type": "main",
            "index": 0
          },
          {
            "node": "Fetch Orders",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Tickets": {
      "main": [
        [
          {
            "node": "Process Complete Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Orders": {
      "main": [
        [
          {
            "node": "Process Complete Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Complete Data": {
      "main": [
        [
          {
            "node": "Dynamic Rate Limit",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Dynamic Rate Limit": {
      "main": [
        [
          {
            "node": "Merge All Events",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge All Events": {
      "main": [
        [
          {
            "node": "Generate Extraction Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Extraction Report": {
      "main": [
        [
          {
            "node": "Save Extraction Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Extraction Report": {
      "main": [
        [
          {
            "node": "Notify Completion",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "tags": [
    {
      "id": "tag1",
      "name": "humanitix"
    },
    {
      "id": "tag2",
      "name": "manual-trigger"
    },
    {
      "id": "tag3",
      "name": "on-demand"
    },
    {
      "id": "tag4",
      "name": "webhook"
    }
  ],
  "triggerCount": 1,
  "versionId": "2.0"
}