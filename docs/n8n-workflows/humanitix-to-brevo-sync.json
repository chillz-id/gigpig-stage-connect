{
  "meta": {
    "instanceId": "e3a1c1c4e2a4f1b2c3d4e5f6a7b8c9d0"
  },
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "value": 15
            }
          ]
        }
      },
      "id": "humanitix-cron-trigger",
      "name": "Schedule Trigger",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.1,
      "position": [280, 300]
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "url": "https://api.humanitix.com/v1/events",
        "options": {
          "qs": {
            "page": 1,
            "pageSize": 50,
            "inFutureOnly": false
          }
        }
      },
      "id": "fetch-humanitix-events",
      "name": "Fetch Humanitix Events",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [500, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "humanitix-api-key",
          "name": "Humanitix API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process events and prepare for order fetching\nconst events = $input.all()[0].json.events || [];\nconst output = [];\n\nfor (const event of events) {\n  // Only process live events from last 30 days\n  const eventDate = new Date(event.startDate);\n  const thirtyDaysAgo = new Date();\n  thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);\n  \n  if (event.status === 'live' && eventDate > thirtyDaysAgo) {\n    output.push({\n      eventId: event._id,\n      eventName: event.title,\n      eventDate: event.startDate,\n      eventLocation: event.location,\n      venue: event.eventLocation?.venueName || 'Unknown Venue',\n      city: event.eventLocation?.city || '',\n      region: event.eventLocation?.region || ''\n    });\n  }\n}\n\nconsole.log(`Processing ${output.length} events for order sync`);\nreturn output;"
      },
      "id": "process-events",
      "name": "Process Events",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [720, 300]
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "url": "=https://api.humanitix.com/v1/events/{{ $json.eventId }}/orders",
        "options": {
          "qs": {
            "page": 1,
            "pageSize": 100
          }
        }
      },
      "id": "fetch-event-orders",
      "name": "Fetch Event Orders",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [940, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "humanitix-api-key",
          "name": "Humanitix API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Process orders and map to Brevo format with state mapping\nconst orders = $input.all()[0].json.orders || [];\nconst eventData = $input.all()[0].json;\nconst output = [];\n\n// Australian state mapping function\nconst stateMapping = {\n  'sydney': 'NSW', 'newcastle': 'NSW', 'wollongong': 'NSW', 'nsw': 'NSW', 'new south wales': 'NSW',\n  'melbourne': 'VIC', 'geelong': 'VIC', 'ballarat': 'VIC', 'vic': 'VIC', 'victoria': 'VIC',\n  'brisbane': 'QLD', 'gold coast': 'QLD', 'sunshine coast': 'QLD', 'qld': 'QLD', 'queensland': 'QLD',\n  'perth': 'WA', 'fremantle': 'WA', 'bunbury': 'WA', 'wa': 'WA', 'western australia': 'WA',\n  'adelaide': 'SA', 'mount gambier': 'SA', 'sa': 'SA', 'south australia': 'SA',\n  'hobart': 'TAS', 'launceston': 'TAS', 'tas': 'TAS', 'tasmania': 'TAS',\n  'darwin': 'NT', 'alice springs': 'NT', 'nt': 'NT', 'northern territory': 'NT',\n  'canberra': 'ACT', 'act': 'ACT', 'australian capital territory': 'ACT'\n};\n\nfunction mapLocationToState(city, region) {\n  const normalizeText = (text) => text?.toLowerCase().trim() || '';\n  \n  // Try region first\n  const normalizedRegion = normalizeText(region);\n  if (stateMapping[normalizedRegion]) {\n    return stateMapping[normalizedRegion];\n  }\n  \n  // Try city\n  const normalizedCity = normalizeText(city);\n  if (stateMapping[normalizedCity]) {\n    return stateMapping[normalizedCity];\n  }\n  \n  // Try partial matches\n  for (const [location, state] of Object.entries(stateMapping)) {\n    if (normalizedCity.includes(location) || normalizedRegion.includes(location)) {\n      return state;\n    }\n  }\n  \n  return 'Unknown';\n}\n\n// Get state from event location\nconst customerState = mapLocationToState(eventData.city, eventData.region);\n\nfor (const order of orders) {\n  if (order.status === 'paid' && order.customer?.email) {\n    output.push({\n      email: order.customer.email,\n      firstName: order.customer.firstName || '',\n      lastName: order.customer.lastName || '',\n      state: customerState,\n      eventName: eventData.eventName,\n      eventDate: eventData.eventDate,\n      venue: eventData.venue,\n      platform: 'Humanitix',\n      orderTotal: order.totals?.total || 0,\n      ticketQuantity: order.tickets?.reduce((sum, ticket) => sum + (ticket.quantity || 0), 0) || 1,\n      marketingOptIn: order.customer.organiserMailListOptIn || false,\n      orderDate: order.createdAt,\n      listIds: [3] // Stand Up Sydney list ID\n    });\n  }\n}\n\nconsole.log(`Found ${output.length} customers to sync to Brevo`);\nreturn output;"
      },
      "id": "process-orders",
      "name": "Process Orders for Brevo",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1160, 300]
    },
    {
      "parameters": {
        "authentication": "headerAuth",
        "url": "https://api.brevo.com/v3/contacts",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "api-key",
              "value": "={{ $credentials.brevoApiKey.api_key }}"
            },
            {
              "name": "accept",
              "value": "application/json"
            },
            {
              "name": "content-type", 
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "bodyContentType": "json",
        "jsonBody": "={\n  \"email\": \"{{ $json.email }}\",\n  \"attributes\": {\n    \"FIRSTNAME\": \"{{ $json.firstName }}\",\n    \"LASTNAME\": \"{{ $json.lastName }}\",\n    \"STATE\": \"{{ $json.state }}\",\n    \"LAST_EVENT\": \"{{ $json.eventName }}\",\n    \"LAST_EVENT_DATE\": \"{{ $json.eventDate }}\",\n    \"VENUE\": \"{{ $json.venue }}\",\n    \"PLATFORM\": \"{{ $json.platform }}\",\n    \"ORDER_TOTAL\": {{ $json.orderTotal }},\n    \"TICKET_QUANTITY\": {{ $json.ticketQuantity }},\n    \"MARKETING_OPT_IN\": {{ $json.marketingOptIn }}\n  },\n  \"listIds\": {{ JSON.stringify($json.listIds) }},\n  \"updateEnabled\": true\n}",\n        "options": {\n          \"response\": {\n            \"response\": {\n              \"neverError\": true\n            }\n          }\n        }\n      },\n      \"id\": \"sync-to-brevo\",\n      \"name\": \"Sync to Brevo\",\n      \"type\": \"n8n-nodes-base.httpRequest\",\n      \"typeVersion\": 4.1,\n      \"position\": [1380, 300],\n      \"credentials\": {\n        \"httpHeaderAuth\": {\n          \"id\": \"brevo-api-key\",\n          \"name\": \"Brevo API Key\"\n        }\n      }\n    },\n    {\n      \"parameters\": {\n        \"jsCode\": \"// Log sync results and handle errors\\nconst results = $input.all();\\nlet successCount = 0;\\nlet errorCount = 0;\\nconst errors = [];\\n\\nfor (const result of results) {\\n  if (result.json.statusCode && result.json.statusCode >= 400) {\\n    errorCount++;\\n    errors.push({\\n      email: result.json.email || 'unknown',\\n      error: result.json.message || 'Unknown error',\\n      statusCode: result.json.statusCode\\n    });\\n  } else {\\n    successCount++;\\n  }\\n}\\n\\nconst summary = {\\n  timestamp: new Date().toISOString(),\\n  platform: 'Humanitix',\\n  totalProcessed: results.length,\\n  successCount,\\n  errorCount,\\n  errors: errors.slice(0, 10), // Limit to first 10 errors\\n  status: errorCount === 0 ? 'success' : errorCount < results.length / 2 ? 'partial_success' : 'failed'\\n};\\n\\nconsole.log('Humanitix â†’ Brevo Sync Summary:', JSON.stringify(summary, null, 2));\\n\\nreturn [summary];\"\n      },\n      \"id\": \"log-results\",\n      \"name\": \"Log Sync Results\",\n      \"type\": \"n8n-nodes-base.code\",\n      \"typeVersion\": 2,\n      \"position\": [1600, 300]\n    },\n    {\n      \"parameters\": {\n        \"resource\": \"database\",\n        \"operation\": \"insert\",\n        \"schema\": {\n          \"value\": \"public\"\n        },\n        \"table\": {\n          \"value\": \"webhook_logs\"\n        },\n        \"columns\": {\n          \"mappingMode\": \"defineBelow\",\n          \"values\": {\n            \"platform\": \"={{ $json.platform }}\",\n            \"event_type\": \"sync_completed\",\n            \"payload\": \"={{ JSON.stringify($json) }}\",\n            \"response_status\": \"={{ $json.status }}\",\n            \"processed_at\": \"={{ $json.timestamp }}\"\n          }\n        }\n      },\n      \"id\": \"log-to-database\",\n      \"name\": \"Log to Database\",\n      \"type\": \"n8n-nodes-base.supabase\",\n      \"typeVersion\": 1,\n      \"position\": [1820, 300],\n      \"credentials\": {\n        \"supabaseApi\": {\n          \"id\": \"supabase-credentials\",\n          \"name\": \"Supabase API\"\n        }\n      }\n    }\n  ],\n  \"connections\": {\n    \"Schedule Trigger\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Fetch Humanitix Events\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Fetch Humanitix Events\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Process Events\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Process Events\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Fetch Event Orders\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Fetch Event Orders\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Process Orders for Brevo\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Process Orders for Brevo\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Sync to Brevo\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Sync to Brevo\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Log Sync Results\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    },\n    \"Log Sync Results\": {\n      \"main\": [\n        [\n          {\n            \"node\": \"Log to Database\",\n            \"type\": \"main\",\n            \"index\": 0\n          }\n        ]\n      ]\n    }\n  },\n  \"pinData\": {},\n  \"settings\": {\n    \"executionOrder\": \"v1\"\n  },\n  \"staticData\": null,\n  \"tags\": [\n    {\n      \"createdAt\": \"2025-01-19T10:30:00.000Z\",\n      \"updatedAt\": \"2025-01-19T10:30:00.000Z\",\n      \"id\": \"humanitix-brevo-sync\",\n      \"name\": \"Humanitix Brevo Sync\"\n    }\n  ],\n  \"triggerCount\": 1,\n  \"updatedAt\": \"2025-01-19T10:30:00.000Z\",\n  \"versionId\": \"1\"\n}