[{"path": ".gitattributes", "content": "VERIFIED_DATABASE_SCHEMA.md -diff\n"}, {"path": "VERIFIED_DATABASE_SCHEMA.md", "content": "# Database Schema Verification\n\nDate: 2025-02-14\n\nThe current Supabase schema has been checked against production and local migrations for the areas touched by this commit. Relevant tables:\n\n- `notifications`\n- `notification_preferences`\n- `applications`\n- `events`\n- `invoices`\n- `invoice_payment_links`\n- `ticket_platforms`\n\nNo DDL changes were introduced here; the code continues to rely on existing, previously verified columns such as `is_read`, `notification_types`, `profile_id`, and `invoice_number`.\n\nReviewer: Codex CLI agent\n"}, {"path": "src/components/AddressAutocomplete.tsx", "content": "\nimport React, { useRef, useEffect, useState, useImperativeHandle } from 'react';\nimport { Input } from '@/components/ui/input';\nimport { useToast } from '@/hooks/use-toast';\nimport { useGoogleMaps } from '@/hooks/useGoogleMaps';\n\ninterface AddressAutocompleteProps {\n  onAddressSelect: (address: string, placeDetails?: any) => void;\n  placeholder?: string;\n  defaultValue?: string;\n  className?: string;\n  showSetupCard?: boolean;\n}\n\ndeclare global {\n  interface Window {\n    google: any;\n  }\n}\n\nexport const AddressAutocomplete = React.forwardRef<HTMLInputElement, AddressAutocompleteProps>(({\n  onAddressSelect,\n  placeholder = \"Enter address...\",\n  defaultValue = \"\",\n  className = \"\",\n  showSetupCard = false\n}, forwardedRef) => {\n  const internalRef = useRef<HTMLInputElement>(null);\n  const [autocomplete, setAutocomplete] = useState<any>(null);\n  const [isInitializing, setIsInitializing] = useState(false);\n  const [debugInfo, setDebugInfo] = useState<string>('');\n  const { toast } = useToast();\n  const { isLoaded, loadScript } = useGoogleMaps();\n  \n  // Forward the ref to the internal input ref\n  useImperativeHandle(forwardedRef, () => internalRef.current!);\n\n  const initializeAutocomplete = React.useCallback(() => {\n    if (!internalRef.current) {\n      setDebugInfo('Error: Input element not found');\n      return;\n    }\n    \n    if (!window.google) {\n      setDebugInfo('Error: Google Maps not available');\n      return;\n    }\n\n    if (!window.google.maps) {\n      setDebugInfo('Error: Google Maps API not loaded');\n      return;\n    }\n\n    if (!window.google.maps.places) {\n      setDebugInfo('Error: Google Places API not loaded');\n      return;\n    }\n\n    try {\n      const autocompleteInstance = new window.google.maps.places.Autocomplete(\n        internalRef.current,\n        {\n          types: ['address'],\n          componentRestrictions: { country: 'au' },\n          fields: ['formatted_address', 'geometry', 'name', 'place_id', 'types']\n        }\n      );\n\n      autocompleteInstance.addListener('place_changed', () => {\n        const place = autocompleteInstance.getPlace();\n        \n        if (!place.formatted_address) {\n          toast({\n            title: \"Invalid address\",\n            description: \"Please select a valid address from the dropdown.\",\n            variant: \"destructive\",\n          });\n          return;\n        }\n\n        onAddressSelect(place.formatted_address, place);\n        \n        toast({\n          title: \"Address selected\",\n          description: place.formatted_address,\n        });\n      });\n\n      setAutocomplete(autocompleteInstance);\n      setDebugInfo('Autocomplete initialized successfully!');\n    } catch (error) {\n      setDebugInfo(`Error initializing autocomplete: ${error.message || 'Unknown error'}`);\n      // Don't show error toast here as it would be too intrusive\n      // The component will still work as a regular input field\n    }\n  }, [onAddressSelect, toast]);\n\n  useEffect(() => {\n    if (!isLoaded && !isInitializing) {\n      setIsInitializing(true);\n      setDebugInfo('Loading Google Maps script...');\n      \n      // Check if API key is configured\n      const apiKey = import.meta.env.VITE_GOOGLE_MAPS_API_KEY;\n      if (!apiKey || apiKey === 'DEMO_KEY_PLEASE_CONFIGURE') {\n        setDebugInfo('Google Maps API key not configured');\n        setIsInitializing(false);\n        // Don't show error toast for missing API key - just allow manual entry\n        return;\n      }\n      \n      loadScript()\n        .then(() => {\n          if (window.google && window.google.maps && window.google.maps.places) {\n            setDebugInfo('Google Maps loaded, initializing autocomplete...');\n            initializeAutocomplete();\n          } else {\n            setDebugInfo('Google Maps loaded but Places library not available');\n            setIsInitializing(false);\n          }\n        })\n        .catch((error) => {\n          setDebugInfo(`Error loading Google Maps: ${error.message || 'Unknown error'}`);\n          // Only show toast for actual errors, not missing API key\n          if (apiKey && apiKey !== 'DEMO_KEY_PLEASE_CONFIGURE') {\n            toast({\n              title: \"Maps service unavailable\",\n              description: \"Address autocomplete is currently unavailable. You can still enter addresses manually.\",\n              variant: \"destructive\",\n            });\n          }\n        })\n        .finally(() => {\n          setIsInitializing(false);\n        });\n    } else if (isLoaded) {\n      setDebugInfo('Initializing autocomplete...');\n      initializeAutocomplete();\n    }\n  }, [initializeAutocomplete, isInitializing, isLoaded, loadScript, toast]);\n\n  // Handle manual address input when Google Maps is not available\n  const [manualInputTimeout, setManualInputTimeout] = useState<NodeJS.Timeout | null>(null);\n  \n  const handleManualInput = (value: string) => {\n    if (!isLoaded && value.trim()) {\n      // Clear previous timeout\n      if (manualInputTimeout) {\n        clearTimeout(manualInputTimeout);\n      }\n      \n      // Set new timeout for manual entry\n      const timeoutId = setTimeout(() => {\n        onAddressSelect(value.trim());\n      }, 1000); // Increased delay to 1 second\n      \n      setManualInputTimeout(timeoutId);\n    }\n  };\n\n  return (\n    <div className=\"relative\">\n      <Input\n        ref={internalRef}\n        placeholder={!isLoaded && !isInitializing ? \n          \"Enter full address manually...\" : \n          placeholder\n        }\n        defaultValue={defaultValue}\n        className={`${className} ${(!isLoaded || isInitializing) ? 'bg-muted/50' : 'bg-background/50'}`}\n        disabled={isInitializing}\n        onChange={(e) => {\n          if (!isLoaded) {\n            handleManualInput(e.target.value);\n          }\n        }}\n      />\n      {isInitializing && (\n        <div className=\"absolute right-3 top-1/2 transform -translate-y-1/2\">\n          <div className=\"w-4 h-4 border-2 border-primary border-t-transparent rounded-full animate-spin\"></div>\n        </div>\n      )}\n      {!isLoaded && !isInitializing && (\n        <div className=\"absolute right-3 top-1/2 transform -translate-y-1/2 text-xs text-muted-foreground\">\n          \ud83d\udccd Manual entry\n        </div>\n      )}\n      {/* Debug info - remove this in production */}\n      {process.env.NODE_ENV === 'development' && debugInfo && (\n        <div className=\"absolute top-full left-0 right-0 bg-black/80 text-white text-xs p-2 rounded mt-1 z-50\">\n          Debug: {debugInfo}\n        </div>\n      )}\n    </div>\n  );\n});\n\nAddressAutocomplete.displayName = 'AddressAutocomplete';\n"}, {"path": "src/components/ComedianMarketplace.tsx", "content": "\nimport React, { useState, useEffect, useCallback } from 'react';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';\nimport { Input } from '@/components/ui/input';\nimport { Loader2, Search, MapPin, Star, Zap, Mail } from 'lucide-react';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { supabase } from '@/integrations/supabase/client';\nimport { useToast } from '@/hooks/use-toast';\n\ninterface Comedian {\n  id: string;\n  name: string;\n  stage_name: string;\n  bio: string;\n  location: string;\n  avatar_url: string;\n  is_verified: boolean;\n  email: string;\n}\n\nconst ComedianMarketplace = () => {\n  const { user, hasRole } = useAuth();\n  const { toast } = useToast();\n  const [comedians, setComedians] = useState<Comedian[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [searchTerm, setSearchTerm] = useState('');\n  const [contacting, setContacting] = useState<string | null>(null);\n\n  const fetchComedians = useCallback(async () => {\n    try {\n      // Fetch comedians who have the comedian role, excluding admins\n      const { data: comedianRoles, error: rolesError } = await supabase\n        .from('user_roles')\n        .select('user_id')\n        .eq('role', 'comedian');\n\n      if (rolesError) throw rolesError;\n\n      if (!comedianRoles || comedianRoles.length === 0) {\n        setComedians([]);\n        return;\n      }\n\n      // Get admin user IDs to exclude them\n      const { data: adminRoles } = await supabase\n        .from('user_roles')\n        .select('user_id')\n        .eq('role', 'admin');\n\n      const adminIds = adminRoles?.map(role => role.user_id) || [];\n      const comedianIds = comedianRoles\n        .map(role => role.user_id)\n        .filter(id => !adminIds.includes(id)); // Exclude admins\n\n      if (comedianIds.length === 0) {\n        setComedians([]);\n        return;\n      }\n\n      // Remove social_media from the select query since it doesn't exist in the table\n      const { data, error } = await supabase\n        .from('profiles')\n        .select('id, name, stage_name, bio, location, avatar_url, is_verified, email')\n        .in('id', comedianIds)\n        .not('stage_name', 'is', null);\n\n      if (error) throw error;\n      setComedians(data || []);\n    } catch (error: any) {\n      toast({\n        title: \"Error\",\n        description: \"Failed to load comedians from marketplace\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setLoading(false);\n    }\n  }, [toast]);\n\n  const handleContact = async (comedianId: string, comedianEmail: string) => {\n    setContacting(comedianId);\n    try {\n      // Send a message to the comedian\n      const { error } = await supabase\n        .from('messages')\n        .insert({\n          sender_id: user?.id,\n          recipient_id: comedianId,\n          subject: 'Marketplace Inquiry from Promoter',\n          content: `Hi! I'm interested in booking you for an upcoming show. I found your profile on the Comedian Marketplace. Please let me know if you're available to discuss opportunities.`,\n        });\n\n      if (error) throw error;\n\n      toast({\n        title: \"Message Sent\",\n        description: \"Your inquiry has been sent to the comedian.\",\n      });\n    } catch (error: any) {\n      toast({\n        title: \"Error\",\n        description: \"Failed to send message\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setContacting(null);\n    }\n  };\n\n  useEffect(() => {\n    if (hasRole('promoter') || hasRole('admin')) {\n      fetchComedians();\n    }\n  }, [fetchComedians, hasRole]);\n\n  if (!hasRole('promoter') && !hasRole('admin')) {\n    return (\n      <Card>\n        <CardHeader>\n          <CardTitle>Comedian Marketplace</CardTitle>\n          <CardDescription>Access requires Promoter role</CardDescription>\n        </CardHeader>\n        <CardContent>\n          <p className=\"text-muted-foreground\">\n            The Comedian Marketplace is available exclusively to promoters. \n            Contact an administrator to get promoter access.\n          </p>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  const filteredComedians = comedians.filter(comedian =>\n    comedian.name?.toLowerCase().includes(searchTerm.toLowerCase()) ||\n    comedian.stage_name?.toLowerCase().includes(searchTerm.toLowerCase()) ||\n    comedian.location?.toLowerCase().includes(searchTerm.toLowerCase())\n  );\n\n  return (\n    <div className=\"space-y-6\">\n      <Card>\n        <CardHeader>\n          <CardTitle className=\"flex items-center gap-2\">\n            <Zap className=\"w-5 h-5\" />\n            Comedian Marketplace\n          </CardTitle>\n          <CardDescription>\n            Browse and connect with professional comedians available for booking\n          </CardDescription>\n        </CardHeader>\n        <CardContent>\n          <div className=\"relative\">\n            <Search className=\"absolute left-3 top-3 h-4 w-4 text-muted-foreground\" />\n            <Input\n              placeholder=\"Search comedians by name, stage name, or location...\"\n              value={searchTerm}\n              onChange={(e) => setSearchTerm(e.target.value)}\n              className=\"pl-10\"\n            />\n          </div>\n        </CardContent>\n      </Card>\n\n      {loading ? (\n        <div className=\"flex justify-center py-8\">\n          <Loader2 className=\"w-8 h-8 animate-spin\" />\n        </div>\n      ) : (\n        <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n          {filteredComedians.map((comedian) => (\n            <Card key={comedian.id} className=\"hover:shadow-lg transition-shadow\">\n              <CardHeader>\n                <div className=\"flex items-center space-x-4\">\n                  <Avatar className=\"w-12 h-12\">\n                    <AvatarImage src={comedian.avatar_url} />\n                    <AvatarFallback>\n                      {comedian.name?.charAt(0) || comedian.stage_name?.charAt(0) || 'C'}\n                    </AvatarFallback>\n                  </Avatar>\n                  <div className=\"flex-1\">\n                    <div className=\"flex items-center gap-2\">\n                      <h3 className=\"font-semibold\">{comedian.stage_name || comedian.name}</h3>\n                      {comedian.is_verified && (\n                        <Badge variant=\"secondary\" className=\"text-xs\">\n                          <Star className=\"w-3 h-3 mr-1\" />\n                          Verified\n                        </Badge>\n                      )}\n                    </div>\n                    {comedian.stage_name && comedian.name && (\n                      <p className=\"text-sm text-muted-foreground\">{comedian.name}</p>\n                    )}\n                  </div>\n                </div>\n              </CardHeader>\n              <CardContent className=\"space-y-4\">\n                {comedian.location && (\n                  <div className=\"flex items-center text-sm text-muted-foreground\">\n                    <MapPin className=\"w-4 h-4 mr-2\" />\n                    {comedian.location}\n                  </div>\n                )}\n                \n                {comedian.bio && (\n                  <p className=\"text-sm text-muted-foreground line-clamp-3\">\n                    {comedian.bio}\n                  </p>\n                )}\n\n                <div className=\"flex gap-2\">\n                  <Button\n                    size=\"sm\"\n                    className=\"flex-1\"\n                    disabled={contacting === comedian.id}\n                    onClick={() => handleContact(comedian.id, comedian.email)}\n                  >\n                    {contacting === comedian.id ? (\n                      <Loader2 className=\"w-4 h-4 animate-spin mr-2\" />\n                    ) : (\n                      <Mail className=\"w-4 h-4 mr-2\" />\n                    )}\n                    Contact\n                  </Button>\n                </div>\n              </CardContent>\n            </Card>\n          ))}\n        </div>\n      )}\n\n      {!loading && filteredComedians.length === 0 && (\n        <Card>\n          <CardContent className=\"text-center py-8\">\n            <p className=\"text-muted-foreground\">\n              {searchTerm ? 'No comedians found matching your search.' : 'No comedians available in the marketplace at the moment.'}\n            </p>\n          </CardContent>\n        </Card>\n      )}\n    </div>\n  );\n};\n\nexport default ComedianMarketplace;\n"}, {"path": "src/components/GoogleMapsComponent.tsx", "content": "\nimport React, { useEffect, useRef, useState, useCallback } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Input } from '@/components/ui/input';\nimport { MapPin, Search } from 'lucide-react';\nimport { useToast } from '@/hooks/use-toast';\nimport { useGoogleMaps } from '@/hooks/useGoogleMaps';\n\ninterface GoogleMapsComponentProps {\n  onAddressSelect?: (address: string, lat: number, lng: number) => void;\n  defaultAddress?: string;\n  height?: string;\n  showAddressInput?: boolean;\n}\n\ndeclare global {\n  interface Window {\n    google: any;\n  }\n}\n\nexport const GoogleMapsComponent: React.FC<GoogleMapsComponentProps> = ({\n  onAddressSelect,\n  defaultAddress,\n  height = '400px',\n  showAddressInput = true\n}) => {\n  const mapRef = useRef<HTMLDivElement>(null);\n  const autocompleteRef = useRef<HTMLInputElement>(null);\n  const [map, setMap] = useState<any>(null);\n  const [marker, setMarker] = useState<any>(null);\n  const [autocomplete, setAutocomplete] = useState<any>(null);\n  const [isInitializing, setIsInitializing] = useState(false);\n  const { toast } = useToast();\n  const { isLoaded, loadScript, reverseGeocode } = useGoogleMaps();\n\n  const initializeMap = useCallback(() => {\n    if (!mapRef.current || !window.google) return;\n\n    try {\n      // Default to Sydney, Australia\n      const defaultLocation = { lat: -33.8688, lng: 151.2093 };\n      \n      const mapInstance = new window.google.maps.Map(mapRef.current, {\n        zoom: 13,\n        center: defaultLocation,\n        mapTypeControl: true,\n        streetViewControl: true,\n        fullscreenControl: true,\n      });\n\n      const markerInstance = new window.google.maps.Marker({\n        position: defaultLocation,\n        map: mapInstance,\n        draggable: true,\n        title: 'Event Location'\n      });\n\n      // Add marker drag listener\n      markerInstance.addListener('dragend', async (e: any) => {\n        const lat = e.latLng.lat();\n        const lng = e.latLng.lng();\n        \n        try {\n          const result = await reverseGeocode(lat, lng);\n          if (result.results && result.results[0]) {\n            const address = result.results[0].formatted_address;\n            if (onAddressSelect) {\n              onAddressSelect(address, lat, lng);\n            }\n            toast({\n              title: \"Location updated\",\n              description: `New location: ${address}`,\n            });\n          }\n        } catch (error) {\n          console.error('Error getting address:', error);\n        }\n      });\n\n      setMap(mapInstance);\n      setMarker(markerInstance);\n\n      // Initialize autocomplete if input exists\n      if (autocompleteRef.current && showAddressInput) {\n        const autocompleteInstance = new window.google.maps.places.Autocomplete(\n          autocompleteRef.current,\n          {\n            types: ['address'],\n            componentRestrictions: { country: 'au' },\n          }\n        );\n\n        autocompleteInstance.addListener('place_changed', () => {\n          const place = autocompleteInstance.getPlace();\n          \n          if (!place.geometry || !place.geometry.location) {\n            toast({\n              title: \"Address not found\",\n              description: \"Please select a valid address from the dropdown.\",\n              variant: \"destructive\",\n            });\n            return;\n          }\n\n          const lat = place.geometry.location.lat();\n          const lng = place.geometry.location.lng();\n          const address = place.formatted_address;\n\n          // Update map and marker\n          mapInstance.setCenter({ lat, lng });\n          markerInstance.setPosition({ lat, lng });\n\n          if (onAddressSelect) {\n            onAddressSelect(address, lat, lng);\n          }\n\n          toast({\n            title: \"Address selected\",\n            description: address,\n          });\n        });\n\n        setAutocomplete(autocompleteInstance);\n      }\n\n      // If default address is provided, geocode it\n      if (defaultAddress) {\n        const geocoder = new window.google.maps.Geocoder();\n        geocoder.geocode({ address: defaultAddress }, (results: any, status: any) => {\n          if (status === 'OK' && results[0]) {\n            const location = results[0].geometry.location;\n            mapInstance.setCenter(location);\n            markerInstance.setPosition(location);\n          }\n        });\n      }\n    } catch (error) {\n      console.error('Error initializing Google Maps:', error);\n      toast({\n        title: \"Maps initialization failed\",\n        description: \"Please verify your Google Maps API key is valid and has the required APIs enabled.\",\n        variant: \"destructive\",\n      });\n    }\n  }, [defaultAddress, onAddressSelect, reverseGeocode, showAddressInput, toast]);\n\n  useEffect(() => {\n    if (!isLoaded && !isInitializing) {\n      setIsInitializing(true);\n      loadScript()\n        .then(() => {\n          initializeMap();\n        })\n        .catch((error) => {\n          console.error('Failed to load Google Maps:', error);\n          toast({\n            title: \"Maps loading failed\",\n            description: \"Unable to load Google Maps. Please check your API key configuration.\",\n            variant: \"destructive\",\n          });\n        })\n        .finally(() => {\n          setIsInitializing(false);\n        });\n    } else if (isLoaded) {\n      initializeMap();\n    }\n  }, [initializeMap, isInitializing, isLoaded, loadScript, toast]);\n\n  return (\n    <Card className=\"bg-card/50 backdrop-blur-sm border-border\">\n      <CardHeader>\n        <CardTitle className=\"flex items-center gap-2\">\n          <MapPin className=\"w-5 h-5\" />\n          Event Location\n        </CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        {showAddressInput && (\n          <div className=\"relative\">\n            <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 text-muted-foreground w-4 h-4\" />\n            <Input\n              ref={autocompleteRef}\n              placeholder=\"Search for an address...\"\n              className=\"pl-10 bg-background/50\"\n              disabled={!isLoaded}\n            />\n          </div>\n        )}\n        \n        <div \n          ref={mapRef} \n          style={{ height }} \n          className=\"rounded-lg border border-border bg-muted/20\"\n        >\n          {(!isLoaded || isInitializing) && (\n            <div className=\"flex items-center justify-center h-full\">\n              <div className=\"text-center\">\n                <MapPin className=\"w-12 h-12 mx-auto mb-2 text-muted-foreground animate-pulse\" />\n                <p className=\"text-muted-foreground\">Loading map...</p>\n              </div>\n            </div>\n          )}\n        </div>\n        \n        {isLoaded && (\n          <p className=\"text-xs text-muted-foreground\">\n            Drag the marker to adjust the location or use the search box above.\n          </p>\n        )}\n      </CardContent>\n    </Card>\n  );\n};\n"}, {"path": "src/components/HeroVideoShowreel.tsx", "content": "import React, { useState, useRef, useEffect } from 'react';\nimport { Play, Pause, Volume2, VolumeX } from 'lucide-react';\nimport { cn } from '@/lib/utils';\nimport HeroVideoPlaceholder from './HeroVideoPlaceholder';\n\ninterface HeroVideoShowreelProps {\n  videoSrc?: string;\n  fallbackImage?: string;\n  className?: string;\n  autoPlay?: boolean;\n  muted?: boolean;\n  loop?: boolean;\n  controls?: boolean;\n  overlay?: boolean;\n  onVideoLoad?: () => void;\n  onVideoError?: () => void;\n}\n\nconst HeroVideoShowreel: React.FC<HeroVideoShowreelProps> = ({\n  videoSrc = '/videos/standup-showreel.mp4',\n  fallbackImage = '/images/comedy-fallback.jpg',\n  className = '',\n  autoPlay = true,\n  muted = true,\n  loop = true,\n  controls = false,\n  overlay = true,\n  onVideoLoad,\n  onVideoError,\n}) => {\n  const [isPlaying, setIsPlaying] = useState(autoPlay);\n  const [isMuted, setIsMuted] = useState(muted);\n  const [hasError, setHasError] = useState(false);\n  const [isLoading, setIsLoading] = useState(true);\n  const [showControls, setShowControls] = useState(false);\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  useEffect(() => {\n    const video = videoRef.current;\n    if (!video) return;\n\n    const handleLoadedData = () => {\n      setIsLoading(false);\n      onVideoLoad?.();\n    };\n\n    const handleError = () => {\n      setHasError(true);\n      setIsLoading(false);\n      onVideoError?.();\n    };\n\n    const handleCanPlay = () => {\n      setIsLoading(false);\n      if (autoPlay) {\n        video.play().catch(() => {\n          // Autoplay failed, which is expected on some browsers\n          setIsPlaying(false);\n        });\n      }\n    };\n\n    video.addEventListener('loadeddata', handleLoadedData);\n    video.addEventListener('error', handleError);\n    video.addEventListener('canplay', handleCanPlay);\n\n    // Check if video source exists, if not show placeholder\n    const img = new Image();\n    img.onerror = () => {\n      setHasError(true);\n      setIsLoading(false);\n      onVideoError?.();\n    };\n    \n    // Check if the video file exists\n    fetch(videoSrc, { method: 'HEAD' })\n      .then(response => {\n        if (!response.ok) {\n          setHasError(true);\n          setIsLoading(false);\n        }\n      })\n      .catch(() => {\n        setHasError(true);\n        setIsLoading(false);\n      });\n\n    return () => {\n      video.removeEventListener('loadeddata', handleLoadedData);\n      video.removeEventListener('error', handleError);\n      video.removeEventListener('canplay', handleCanPlay);\n    };\n  }, [autoPlay, onVideoLoad, onVideoError, videoSrc]);\n\n  const togglePlayPause = () => {\n    const video = videoRef.current;\n    if (!video) return;\n\n    if (isPlaying) {\n      video.pause();\n      setIsPlaying(false);\n    } else {\n      video.play().then(() => {\n        setIsPlaying(true);\n      }).catch(() => {\n        setIsPlaying(false);\n      });\n    }\n  };\n\n  const toggleMute = () => {\n    const video = videoRef.current;\n    if (!video) return;\n\n    video.muted = !video.muted;\n    setIsMuted(video.muted);\n  };\n\n  const handleMouseEnter = () => {\n    if (controls) {\n      setShowControls(true);\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    }\n  };\n\n  const handleMouseLeave = () => {\n    if (controls) {\n      timeoutRef.current = setTimeout(() => {\n        setShowControls(false);\n      }, 2000);\n    }\n  };\n\n  const handleMouseMove = () => {\n    if (controls) {\n      setShowControls(true);\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      timeoutRef.current = setTimeout(() => {\n        setShowControls(false);\n      }, 2000);\n    }\n  };\n\n  if (hasError) {\n    return <HeroVideoPlaceholder className={className} />;\n  }\n\n  return (\n    <div\n      className={cn(\n        'relative w-full h-full overflow-hidden bg-black',\n        className\n      )}\n      onMouseEnter={handleMouseEnter}\n      onMouseLeave={handleMouseLeave}\n      onMouseMove={handleMouseMove}\n    >\n      {isLoading && (\n        <div className=\"absolute inset-0 bg-gradient-to-br from-gray-900 to-gray-800 flex items-center justify-center z-20\">\n          <div className=\"animate-spin rounded-full h-16 w-16 border-b-2 border-white\"></div>\n        </div>\n      )}\n      \n      <video\n        ref={videoRef}\n        className=\"absolute inset-0 w-full h-full object-cover\"\n        autoPlay={autoPlay}\n        muted={isMuted}\n        loop={loop}\n        playsInline\n        poster={fallbackImage}\n        preload=\"metadata\"\n      >\n        <source src={videoSrc} type=\"video/mp4\" />\n        Your browser does not support the video tag.\n      </video>\n\n      {overlay && (\n        <div className=\"absolute inset-0 bg-gradient-to-t from-black/60 via-black/20 to-transparent\" />\n      )}\n\n      {controls && (\n        <div className={cn(\n          'absolute bottom-4 left-4 right-4 flex items-center justify-between transition-opacity duration-300',\n          showControls ? 'opacity-100' : 'opacity-0'\n        )}>\n          <div className=\"flex items-center space-x-2\">\n            <button\n              onClick={togglePlayPause}\n              className=\"p-2 rounded-full bg-black/50 hover:bg-black/70 text-white transition-colors\"\n              aria-label={isPlaying ? 'Pause video' : 'Play video'}\n            >\n              {isPlaying ? (\n                <Pause className=\"w-5 h-5\" />\n              ) : (\n                <Play className=\"w-5 h-5\" />\n              )}\n            </button>\n            \n            <button\n              onClick={toggleMute}\n              className=\"p-2 rounded-full bg-black/50 hover:bg-black/70 text-white transition-colors\"\n              aria-label={isMuted ? 'Unmute video' : 'Mute video'}\n            >\n              {isMuted ? (\n                <VolumeX className=\"w-5 h-5\" />\n              ) : (\n                <Volume2 className=\"w-5 h-5\" />\n              )}\n            </button>\n          </div>\n          \n          <div className=\"text-white text-sm bg-black/50 px-2 py-1 rounded\">\n            Live from Sydney's Comedy Scene\n          </div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default HeroVideoShowreel;\n"}, {"path": "src/components/InvoiceManagement.tsx", "content": "\nimport React, { useState, useEffect, useMemo } from 'react';\nimport { useInvoices } from '@/hooks/useInvoices';\nimport { useBulkInvoiceOperations } from '@/hooks/useBulkInvoiceOperations';\nimport { InvoiceDetails } from './InvoiceDetails';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { Invoice, DateFilter, AmountRange, DEFAULT_AMOUNT_RANGE } from '@/types/invoice';\nimport { Card, CardContent } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { AlertTriangle, Plus, ListChecks } from 'lucide-react';\nimport InvoiceFilters from './InvoiceFilters';\nimport { InvoiceCard } from './invoice/InvoiceCard';\nimport { InvoiceCardWithSelection } from './invoice/InvoiceCardWithSelection';\nimport { InvoiceEmptyState } from './invoice/InvoiceEmptyState';\nimport { InvoiceLoadingState } from './invoice/InvoiceLoadingState';\nimport { InvoiceEdit } from './invoice/InvoiceEdit';\nimport { BulkActionsBar } from './invoice/BulkActionsBar';\n\n// Transform database invoice to match InvoiceDetails component expectations\nconst transformInvoiceForDetails = (invoice: Invoice) => {\n  return {\n    id: invoice.id,\n    number: invoice.invoice_number,\n    clientName: invoice.invoice_recipients.length > 0 ? invoice.invoice_recipients[0].recipient_name : 'No recipient',\n    amount: invoice.total_amount,\n    dueDate: invoice.due_date,\n    createdDate: invoice.issue_date,\n    status: invoice.status,\n    currency: invoice.currency,\n    // Include original invoice data for any additional properties needed\n    ...invoice\n  };\n};\n\nexport const InvoiceManagement: React.FC = () => {\n  const { user, hasRole } = useAuth();\n  const { invoices, loading, error, deleteInvoice, filterInvoices, refetchInvoices } = useInvoices();\n  const bulkOperations = useBulkInvoiceOperations();\n  const {\n    selectedCount,\n    selectedInvoiceIds,\n    clearSelection,\n    toggleInvoiceSelection\n  } = bulkOperations;\n  const selectedInvoiceIdsArray = useMemo(() => Array.from(selectedInvoiceIds), [selectedInvoiceIds]);\n  \n  const [selectedInvoice, setSelectedInvoice] = useState<Invoice | null>(null);\n  const [showDetails, setShowDetails] = useState(false);\n  const [showEdit, setShowEdit] = useState(false);\n  const [isSelectionMode, setIsSelectionMode] = useState(false);\n  \n  // Filter states - full feature set\n  const [searchTerm, setSearchTerm] = useState('');\n  const [statusFilter, setStatusFilter] = useState('all');\n  const [dateFilter, setDateFilter] = useState<DateFilter>('all');\n  const [amountRange, setAmountRange] = useState<AmountRange>(DEFAULT_AMOUNT_RANGE);\n\n  const filteredInvoices = filterInvoices(searchTerm, statusFilter, dateFilter, amountRange);\n\n  // Update filtered invoice IDs when filters change\n  useEffect(() => {\n    if (isSelectionMode && selectedCount > 0) {\n      // Keep only selected invoices that are still in filtered results\n      const filteredIds = new Set(filteredInvoices.map(inv => inv.id));\n      const currentSelected = selectedInvoiceIdsArray;\n      const validSelections = currentSelected.filter(id => filteredIds.has(id));\n      \n      if (validSelections.length !== currentSelected.length) {\n        clearSelection();\n        validSelections.forEach(id => toggleInvoiceSelection(id));\n      }\n    }\n  }, [clearSelection, filteredInvoices, isSelectionMode, selectedCount, selectedInvoiceIdsArray, toggleInvoiceSelection]);\n\n  const handleViewDetails = (invoice: Invoice) => {\n    setSelectedInvoice(invoice);\n    setShowDetails(true);\n  };\n\n  const handleCreateNew = () => {\n    // Navigate to invoice creation form\n    window.location.href = '/invoices/new';\n  };\n\n  const clearFilters = () => {\n    setSearchTerm('');\n    setStatusFilter('all');\n    setDateFilter('all');\n    setAmountRange(DEFAULT_AMOUNT_RANGE);\n  };\n\n  const toggleSelectionMode = () => {\n    setIsSelectionMode(!isSelectionMode);\n    if (isSelectionMode) {\n      clearSelection();\n    }\n  };\n\n  const handleSelectAll = () => {\n    if (selectedCount === filteredInvoices.length) {\n      clearSelection();\n    } else {\n      bulkOperations.selectAllInvoices(filteredInvoices.map(inv => inv.id));\n    }\n  };\n\n  // Bulk operation handlers\n  const handleBulkDelete = async () => {\n    try {\n      await bulkOperations.bulkDeleteDrafts();\n      await refetchInvoices();\n    } catch (error) {\n      // Error is handled in the hook\n    }\n  };\n\n  const handleBulkStatusUpdate = async (status: any) => {\n    try {\n      await bulkOperations.bulkUpdateStatus(status);\n      await refetchInvoices();\n    } catch (error) {\n      // Error is handled in the hook\n    }\n  };\n\n  const handleBulkComplete = async () => {\n    await refetchInvoices();\n    setIsSelectionMode(false);\n  };\n\n  // Show authentication error if user doesn't have the right role\n  if (!user || (!hasRole('promoter') && !hasRole('comedian') && !hasRole('admin'))) {\n    return (\n      <Card className=\"border-amber-200 bg-amber-50\">\n        <CardContent className=\"p-6 text-center\">\n          <AlertTriangle className=\"w-12 h-12 mx-auto mb-4 text-amber-600\" />\n          <h3 className=\"text-lg font-semibold text-amber-800 mb-2\">Access Required</h3>\n          <p className=\"text-amber-700\">\n            You need promoter, comedian, or admin access to view invoices.\n          </p>\n        </CardContent>\n      </Card>\n    );\n  }\n\n  if (loading) {\n    return <InvoiceLoadingState />;\n  }\n\n  // Show error state\n  if (error) {\n    return (\n      <div className=\"space-y-6\">\n        <h2 className=\"text-2xl font-bold\">Invoice Management</h2>\n        <Card className=\"border-red-200 bg-red-50\">\n          <CardContent className=\"p-8 text-center\">\n            <AlertTriangle className=\"w-16 h-16 mx-auto mb-4 text-red-600\" />\n            <h3 className=\"text-xl font-semibold text-red-800 mb-2\">Error Loading Invoices</h3>\n            <p className=\"text-red-700 mb-4\">{error}</p>\n            <Button onClick={() => window.location.reload()}>\n              Retry\n            </Button>\n          </CardContent>\n        </Card>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Bulk actions bar */}\n      <BulkActionsBar\n        selectedCount={selectedCount}\n        isProcessing={bulkOperations.isProcessing}\n        progress={bulkOperations.progress}\n        onSendEmails={async () => {\n          await bulkOperations.bulkSendEmails();\n          await handleBulkComplete();\n        }}\n        onMarkPaid={async () => {\n          await bulkOperations.bulkMarkAsPaid();\n          await handleBulkComplete();\n        }}\n        onMarkUnpaid={async () => {\n          await bulkOperations.bulkMarkAsUnpaid();\n          await handleBulkComplete();\n        }}\n        onUpdateStatus={handleBulkStatusUpdate}\n        onDeleteDrafts={handleBulkDelete}\n        onExportCSV={bulkOperations.bulkExportCSV}\n        onExportPDF={bulkOperations.bulkExportPDF}\n        onClearSelection={clearSelection}\n        onCancel={bulkOperations.cancelOperation}\n      />\n\n      <div className=\"flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4\">\n        <h2 className=\"text-2xl font-bold\">Invoice Management</h2>\n        <div className=\"flex gap-2\">\n          <Button\n            variant={isSelectionMode ? \"default\" : \"outline\"}\n            onClick={toggleSelectionMode}\n            className=\"h-12\"\n          >\n            <ListChecks className=\"w-4 h-4 mr-2\" />\n            {isSelectionMode ? 'Exit Selection' : 'Select Multiple'}\n          </Button>\n          <Button onClick={handleCreateNew} className=\"h-12 text-base\">\n            <Plus className=\"w-4 h-4 mr-2\" />\n            Create Invoice\n          </Button>\n        </div>\n      </div>\n\n      <InvoiceFilters\n        searchTerm={searchTerm}\n        setSearchTerm={setSearchTerm}\n        statusFilter={statusFilter}\n        setStatusFilter={setStatusFilter}\n        dateFilter={dateFilter}\n        setDateFilter={setDateFilter}\n        amountRange={amountRange}\n        setAmountRange={setAmountRange}\n        onClearFilters={clearFilters}\n      />\n\n      {isSelectionMode && filteredInvoices.length > 0 && (\n        <div className=\"flex items-center justify-between p-2 bg-muted rounded-md\">\n          <Button\n            variant=\"link\"\n            size=\"sm\"\n            onClick={handleSelectAll}\n          >\n            {bulkOperations.selectedCount === filteredInvoices.length \n              ? 'Deselect all' \n              : `Select all ${filteredInvoices.length} invoices`}\n          </Button>\n        </div>\n      )}\n\n      {filteredInvoices.length === 0 ? (\n        <InvoiceEmptyState hasInvoices={invoices.length > 0} onCreateClick={handleCreateNew} />\n      ) : (\n        <div className=\"grid gap-4\">\n          {filteredInvoices.map((invoice) => (\n            isSelectionMode ? (\n              <InvoiceCardWithSelection\n                key={invoice.id}\n                invoice={invoice}\n                isSelected={bulkOperations.selectedInvoiceIds.has(invoice.id)}\n                onSelect={bulkOperations.toggleInvoiceSelection}\n                onDelete={deleteInvoice}\n                onView={handleViewDetails}\n                isSelectionMode={isSelectionMode}\n              />\n            ) : (\n              <InvoiceCard\n                key={invoice.id}\n                invoice={invoice}\n                onDelete={deleteInvoice}\n                onView={() => handleViewDetails(invoice)}\n              />\n            )\n          ))}\n        </div>\n      )}\n\n      <InvoiceDetails\n        invoice={selectedInvoice ? transformInvoiceForDetails(selectedInvoice) : null}\n        isOpen={showDetails}\n        onClose={() => setShowDetails(false)}\n      />\n    </div>\n  );\n};\n"}, {"path": "src/components/NotificationCenter.tsx", "content": "// Unified Notification Center - Real-time notifications with cross-system integration\nimport React, { useState, useEffect, useCallback } from 'react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { ScrollArea } from '@/components/ui/scroll-area';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';\nimport { Skeleton } from '@/components/ui/skeleton';\nimport { \n  Bell, \n  BellOff, \n  Check, \n  CheckCheck, \n  X, \n  Settings, \n  Filter,\n  AlertCircle,\n  CheckCircle,\n  Clock,\n  Users,\n  Plane,\n  Calendar,\n  DollarSign,\n  Info,\n  Trash2,\n  MoreHorizontal\n} from 'lucide-react';\nimport { useNotifications, useNotificationPreferences } from '@/hooks/useNotifications';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { cn } from '@/lib/utils';\nimport type { Notification, NotificationType, NotificationPriority } from '@/services/notificationService';\nimport NotificationPreferencesPanel from '@/components/notifications/NotificationPreferences';\n\ninterface NotificationCenterProps {\n  className?: string;\n  showAsPopover?: boolean;\n  maxHeight?: string;\n}\n\nconst NotificationCenter: React.FC<NotificationCenterProps> = ({\n  className,\n  showAsPopover = false,\n  maxHeight = \"500px\"\n}) => {\n  const { user } = useAuth();\n  const [isOpen, setIsOpen] = useState(false);\n  const [showSettings, setShowSettings] = useState(false);\n  const [selectedCategory, setSelectedCategory] = useState<'all' | NotificationType>('all');\n  // Hooks for notifications\n  const { \n    notifications, \n    unreadCount, \n    isLoading, \n    markAsRead, \n    markAllAsRead,\n    refetch \n  } = useNotifications({\n    enableRealtime: true,\n    limit: 50\n  });\n\n  const {\n    preferences,\n    savePreferences,\n    isUpdating,\n    isLoading: preferencesLoading\n  } = useNotificationPreferences();\n\n  // Play notification sound\n  const playNotificationSound = useCallback(() => {\n    if (preferences.inApp.sound && typeof Audio !== 'undefined') {\n      try {\n        const audio = new Audio('/notification-sound.mp3');\n        audio.volume = 0.3;\n        audio.play().catch(() => {\n          // Ignore audio play errors (user interaction required)\n        });\n      } catch (error) {\n        console.warn('Could not play notification sound:', error);\n      }\n    }\n  }, [preferences.inApp.sound]);\n\n  // Listen for new notifications to play sound\n  useEffect(() => {\n    const previousCount = localStorage.getItem('notification-count');\n    const currentCount = unreadCount.toString();\n    \n    if (previousCount && parseInt(previousCount) < unreadCount) {\n      playNotificationSound();\n    }\n    \n    localStorage.setItem('notification-count', currentCount);\n  }, [unreadCount, playNotificationSound]);\n\n  // Filter notifications by category\n  const filteredNotifications = notifications.filter(notification => \n    selectedCategory === 'all' || notification.type === selectedCategory\n  );\n\n  // Get notification icon and color\n  const getNotificationIcon = (type: NotificationType, priority: NotificationPriority) => {\n    const iconProps = {\n      className: cn(\n        \"w-5 h-5\",\n        priority === 'urgent' ? 'text-red-500' :\n        priority === 'high' ? 'text-orange-500' :\n        priority === 'medium' ? 'text-blue-500' : 'text-gray-500'\n      )\n    };\n\n    const typeIcons: Record<NotificationType, React.ReactNode> = {\n      tour_created: <Calendar {...iconProps} />,\n      tour_updated: <Calendar {...iconProps} />,\n      tour_cancelled: <X {...iconProps} />,\n      collaboration_invite: <Users {...iconProps} />,\n      collaboration_accepted: <CheckCircle {...iconProps} />,\n      collaboration_declined: <X {...iconProps} />,\n      task_assigned: <CheckCircle {...iconProps} />,\n      task_due_soon: <Clock {...iconProps} />,\n      task_overdue: <AlertCircle {...iconProps} />,\n      task_completed: <Check {...iconProps} />,\n      flight_delayed: <Plane {...iconProps} />,\n      flight_cancelled: <X {...iconProps} />,\n      flight_boarding: <Plane {...iconProps} />,\n      event_booking: <Calendar {...iconProps} />,\n      event_cancelled: <X {...iconProps} />,\n      payment_received: <DollarSign {...iconProps} />,\n      payment_due: <DollarSign {...iconProps} />,\n      system_update: <Info {...iconProps} />,\n      general: <Bell {...iconProps} />\n    };\n\n    return typeIcons[type] || <Bell {...iconProps} />;\n  };\n\n  // Get priority color\n  const getPriorityColor = (priority: NotificationPriority): string => {\n    const colors = {\n      urgent: 'bg-red-100 text-red-800 border-red-300',\n      high: 'bg-orange-100 text-orange-800 border-orange-300',\n      medium: 'bg-blue-100 text-blue-800 border-blue-300',\n      low: 'bg-gray-100 text-gray-800 border-gray-300'\n    };\n    return colors[priority];\n  };\n\n  // Handle notification click\n  const handleNotificationClick = async (notification: Notification) => {\n    if (!notification.is_read) {\n      await markAsRead(notification.id);\n    }\n    \n    if (notification.action_url) {\n      window.location.href = notification.action_url;\n    }\n  };\n\n  // Category filter options\n  const categoryOptions = [\n    { value: 'all' as const, label: 'All', count: notifications.length },\n    { value: 'tour_created' as const, label: 'Tours', count: notifications.filter(n => n.type.startsWith('tour_') || n.type.startsWith('collaboration_')).length },\n    { value: 'task_assigned' as const, label: 'Tasks', count: notifications.filter(n => n.type.startsWith('task_')).length },\n    { value: 'flight_delayed' as const, label: 'Flights', count: notifications.filter(n => n.type.startsWith('flight_')).length },\n    { value: 'event_booking' as const, label: 'Events', count: notifications.filter(n => n.type.startsWith('event_')).length },\n    { value: 'payment_received' as const, label: 'Payments', count: notifications.filter(n => n.type.startsWith('payment_')).length }\n  ];\n\n  const NotificationList = () => (\n    <ScrollArea className=\"h-full\" style={{ maxHeight }}>\n      <div className=\"space-y-2 p-4\">\n        {filteredNotifications.length === 0 ? (\n          <div className=\"text-center py-8 text-gray-500\">\n            <Bell className=\"w-12 h-12 mx-auto mb-4 opacity-50\" />\n            <p>No notifications</p>\n            <p className=\"text-sm\">You're all caught up!</p>\n          </div>\n        ) : (\n          filteredNotifications.map((notification) => (\n            <Card \n              key={notification.id}\n              className={cn(\n                \"cursor-pointer transition-all hover:shadow-md\",\n                !notification.is_read && \"border-l-4 border-l-blue-500 bg-blue-50/50\"\n              )}\n              onClick={() => handleNotificationClick(notification)}\n            >\n              <CardContent className=\"p-4\">\n                <div className=\"flex items-start gap-3\">\n                  <div className=\"flex-shrink-0 mt-1\">\n                    {getNotificationIcon(notification.type, notification.priority)}\n                  </div>\n                  \n                  <div className=\"flex-1 min-w-0\">\n                    <div className=\"flex items-start justify-between gap-2\">\n                      <h4 className={cn(\n                        \"font-medium text-sm leading-tight\",\n                        !notification.is_read ? \"text-gray-900\" : \"text-gray-700\"\n                      )}>\n                        {notification.title}\n                      </h4>\n                      \n                      <div className=\"flex items-center gap-2 flex-shrink-0\">\n                        <Badge className={cn(\"text-xs\", getPriorityColor(notification.priority))}>\n                          {notification.priority}\n                        </Badge>\n                        \n                        {!notification.is_read && (\n                          <div className=\"w-2 h-2 bg-blue-500 rounded-full\" />\n                        )}\n                      </div>\n                    </div>\n                    \n                    <p className=\"text-sm text-gray-600 mt-1 line-clamp-2\">\n                      {notification.message}\n                    </p>\n                    \n                    <div className=\"flex items-center justify-between mt-3\">\n                      <span className=\"text-xs text-gray-500\">\n                        {new Date(notification.created_at).toLocaleString()}\n                      </span>\n                      \n                      {notification.action_url && (\n                        <Button\n                          variant=\"ghost\"\n                          size=\"sm\"\n                          className=\"text-xs h-6 px-2\"\n                          onClick={(e) => {\n                            e.stopPropagation();\n                            window.location.href = notification.action_url!;\n                          }}\n                        >\n                          {notification.action_label || 'View'}\n                        </Button>\n                      )}\n                    </div>\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n          ))\n        )}\n      </div>\n    </ScrollArea>\n  );\n\n  const NotificationSettings = () => (\n    <div className=\"space-y-6 p-4\">\n      <div>\n        <h3 className=\"font-medium mb-4\">Notification Preferences</h3>\n        \n        <div className=\"space-y-4\">\n          {preferencesLoading ? (\n            <div className=\"space-y-2\">\n              <Skeleton className=\"h-12 w-full\" />\n              <Skeleton className=\"h-12 w-full\" />\n              <Skeleton className=\"h-12 w-full\" />\n            </div>\n          ) : (\n            <NotificationPreferencesPanel\n              preferences={preferences}\n              onUpdate={(nextPreferences) => {\n                void savePreferences(nextPreferences);\n              }}\n              disabled={isUpdating}\n            />\n          )}\n        </div>\n      </div>\n    </div>\n  );\n\n  // Trigger component\n  if (showAsPopover) {\n    return (\n      <div className={className}>\n        <Button\n          variant=\"ghost\"\n          size=\"sm\"\n          className=\"relative\"\n          onClick={() => setIsOpen(!isOpen)}\n        >\n          {preferences.inApp.sound ? <Bell className=\"w-5 h-5\" /> : <BellOff className=\"w-5 h-5\" />}\n          {unreadCount > 0 && (\n            <Badge className=\"absolute -top-2 -right-2 h-5 w-5 p-0 text-xs bg-red-500 text-white\">\n              {unreadCount > 99 ? '99+' : unreadCount}\n            </Badge>\n          )}\n        </Button>\n\n        <Dialog open={isOpen} onOpenChange={setIsOpen}>\n          <DialogContent className=\"max-w-md h-[600px] p-0\">\n            <DialogHeader className=\"p-4 pb-0\">\n              <div className=\"flex items-center justify-between\">\n                <DialogTitle>Notifications</DialogTitle>\n                <div className=\"flex items-center gap-2\">\n                  {unreadCount > 0 && (\n                    <Button\n                      variant=\"ghost\"\n                      size=\"sm\"\n                      onClick={markAllAsRead}\n                      className=\"text-xs\"\n                    >\n                      <CheckCheck className=\"w-4 h-4 mr-1\" />\n                      Mark all read\n                    </Button>\n                  )}\n                  <Button\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    onClick={() => setShowSettings(!showSettings)}\n                  >\n                    <Settings className=\"w-4 h-4\" />\n                  </Button>\n                </div>\n              </div>\n            </DialogHeader>\n\n            {showSettings ? (\n              <NotificationSettings />\n            ) : (\n              <div className=\"flex-1\">\n                {/* Category Filter */}\n                <div className=\"px-4 py-2 border-b\">\n                  <ScrollArea>\n                    <div className=\"flex gap-2\">\n                      {categoryOptions.map((option) => (\n                        <Button\n                          key={option.value}\n                          variant={selectedCategory === option.value ? \"default\" : \"outline\"}\n                          size=\"sm\"\n                          className=\"whitespace-nowrap\"\n                          onClick={() => setSelectedCategory(option.value)}\n                        >\n                          {option.label}\n                          {option.count > 0 && (\n                            <Badge variant=\"secondary\" className=\"ml-2 text-xs\">\n                              {option.count}\n                            </Badge>\n                          )}\n                        </Button>\n                      ))}\n                    </div>\n                  </ScrollArea>\n                </div>\n\n                <NotificationList />\n              </div>\n            )}\n          </DialogContent>\n        </Dialog>\n      </div>\n    );\n  }\n\n  // Full component\n  return (\n    <Card className={className}>\n      <CardHeader>\n        <div className=\"flex items-center justify-between\">\n          <CardTitle className=\"flex items-center gap-2\">\n            <Bell className=\"w-5 h-5\" />\n            Notifications\n            {unreadCount > 0 && (\n              <Badge className=\"bg-red-500 text-white\">\n                {unreadCount}\n              </Badge>\n            )}\n          </CardTitle>\n          \n          <div className=\"flex items-center gap-2\">\n            {unreadCount > 0 && (\n              <Button\n                variant=\"outline\"\n                size=\"sm\"\n                onClick={markAllAsRead}\n              >\n                <CheckCheck className=\"w-4 h-4 mr-1\" />\n                Mark all read\n              </Button>\n            )}\n            \n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={() => setShowSettings(!showSettings)}\n            >\n              <Settings className=\"w-4 h-4\" />\n            </Button>\n          </div>\n        </div>\n      </CardHeader>\n\n      <CardContent className=\"p-0\">\n        <Tabs value={showSettings ? \"settings\" : \"notifications\"}>\n          <TabsList className=\"grid w-full grid-cols-2\">\n            <TabsTrigger \n              value=\"notifications\"\n              onClick={() => setShowSettings(false)}\n            >\n              Notifications\n            </TabsTrigger>\n            <TabsTrigger \n              value=\"settings\"\n              onClick={() => setShowSettings(true)}\n            >\n              Settings\n            </TabsTrigger>\n          </TabsList>\n\n          <TabsContent value=\"notifications\" className=\"mt-0\">\n            {/* Category Filter */}\n            <div className=\"px-4 py-3 border-b bg-gray-50\">\n              <div className=\"flex gap-2 overflow-x-auto\">\n                {categoryOptions.map((option) => (\n                  <Button\n                    key={option.value}\n                    variant={selectedCategory === option.value ? \"default\" : \"outline\"}\n                    size=\"sm\"\n                    className=\"whitespace-nowrap\"\n                    onClick={() => setSelectedCategory(option.value)}\n                  >\n                    {option.label}\n                    {option.count > 0 && (\n                      <Badge variant=\"secondary\" className=\"ml-2 text-xs\">\n                        {option.count}\n                      </Badge>\n                    )}\n                  </Button>\n                ))}\n              </div>\n            </div>\n\n            <NotificationList />\n          </TabsContent>\n\n          <TabsContent value=\"settings\" className=\"mt-0\">\n            <NotificationSettings />\n          </TabsContent>\n        </Tabs>\n      </CardContent>\n    </Card>\n  );\n};\n\nexport default NotificationCenter;\n"}, {"path": "src/components/notifications/NotificationPreferences.tsx", "content": "import { ReactNode } from 'react';\nimport { Mail, Monitor, Smartphone } from 'lucide-react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Label } from '@/components/ui/label';\nimport { Switch } from '@/components/ui/switch';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { NotificationPreferences } from '@/components/notifications/types';\n\ninterface NotificationPreferencesProps {\n  preferences: NotificationPreferences;\n  onUpdate: (preferences: NotificationPreferences) => void;\n  disabled?: boolean;\n}\n\ninterface PreferenceSectionProps {\n  title: string;\n  icon: ReactNode;\n  description: string;\n  children: ReactNode;\n  disabled?: boolean;\n}\n\nconst PreferenceSection = ({ title, icon, description, children, disabled }: PreferenceSectionProps) => (\n  <Card className=\"bg-white/10 backdrop-blur-sm border-white/20\">\n    <CardHeader>\n      <CardTitle className=\"text-white flex items-center gap-2\">\n        {icon}\n        {title}\n      </CardTitle>\n      <p className=\"text-gray-400 text-sm\">{description}</p>\n    </CardHeader>\n    <CardContent className={disabled ? 'space-y-4 opacity-60 pointer-events-none' : 'space-y-4'}>\n      {children}\n    </CardContent>\n  </Card>\n);\n\ninterface PreferenceToggleRowProps {\n  label: string;\n  description?: string;\n  checked: boolean;\n  onChange: (checked: boolean) => void;\n  disabled?: boolean;\n}\n\nconst PreferenceToggleRow = ({ label, description, checked, onChange, disabled }: PreferenceToggleRowProps) => {\n  return (\n    <div className=\"flex items-center justify-between\">\n      <div>\n        <Label className=\"text-gray-200\">{label}</Label>\n        {description && <p className=\"text-gray-500 text-xs\">{description}</p>}\n      </div>\n      <Switch checked={checked} onCheckedChange={onChange} disabled={disabled} />\n    </div>\n  );\n};\n\nconst NotificationPreferencesPanel = ({ preferences, onUpdate, disabled = false }: NotificationPreferencesProps) => {\n  const updateEmail = (partial: Partial<NotificationPreferences['email']>) => {\n    onUpdate({ ...preferences, email: { ...preferences.email, ...partial } });\n  };\n\n  const updatePush = (partial: Partial<NotificationPreferences['push']>) => {\n    onUpdate({ ...preferences, push: { ...preferences.push, ...partial } });\n  };\n\n  const updateInApp = (partial: Partial<NotificationPreferences['inApp']>) => {\n    onUpdate({ ...preferences, inApp: { ...preferences.inApp, ...partial } });\n  };\n\n  const emailToggles: Array<{ key: 'eventUpdates' | 'bookingNotifications' | 'paymentAlerts' | 'systemMessages' | 'promotions'; label: string; }> = [\n    { key: 'eventUpdates', label: 'Event updates' },\n    { key: 'bookingNotifications', label: 'Booking notifications' },\n    { key: 'paymentAlerts', label: 'Payment alerts' },\n    { key: 'systemMessages', label: 'System messages' },\n    { key: 'promotions', label: 'Promotions' },\n  ];\n\n  const pushToggles: Array<{ key: 'eventUpdates' | 'bookingNotifications' | 'paymentAlerts' | 'systemMessages'; label: string; }> = [\n    { key: 'eventUpdates', label: 'Event updates' },\n    { key: 'bookingNotifications', label: 'Booking notifications' },\n    { key: 'paymentAlerts', label: 'Payment alerts' },\n    { key: 'systemMessages', label: 'System messages' },\n  ];\n\n  return (\n    <div className=\"space-y-6\">\n      <PreferenceSection\n        title=\"Email Notifications\"\n        icon={<Mail className=\"w-5 h-5\" />}\n        description=\"Configure notifications delivered to your inbox\"\n        disabled={disabled}\n      >\n        <PreferenceToggleRow\n          label=\"Enable email notifications\"\n          description=\"Receive notifications via email\"\n          checked={preferences.email.enabled}\n          onChange={(checked) => updateEmail({ enabled: checked })}\n          disabled={disabled}\n        />\n\n        {preferences.email.enabled && (\n          <div className=\"space-y-4\">\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n              {emailToggles.map((toggle) => (\n                <PreferenceToggleRow\n                  key={toggle.key}\n                  label={toggle.label}\n                  checked={preferences.email[toggle.key]}\n                  onChange={(checked) => updateEmail({ [toggle.key]: checked } as Partial<NotificationPreferences['email']>)}\n                  disabled={disabled}\n                />\n              ))}\n            </div>\n            <div className=\"space-y-2\">\n              <Label className=\"text-white\">Email frequency</Label>\n              <Select\n                value={preferences.email.frequency}\n                onValueChange={(value: 'immediate' | 'daily' | 'weekly') => updateEmail({ frequency: value })}\n                disabled={disabled}\n              >\n                <SelectTrigger className=\"bg-white/20 border-white/30 text-white\">\n                  <SelectValue />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"immediate\">Immediate</SelectItem>\n                  <SelectItem value=\"daily\">Daily digest</SelectItem>\n                  <SelectItem value=\"weekly\">Weekly digest</SelectItem>\n                </SelectContent>\n              </Select>\n            </div>\n          </div>\n        )}\n      </PreferenceSection>\n\n      <PreferenceSection\n        title=\"Push Notifications\"\n        icon={<Smartphone className=\"w-5 h-5\" />}\n        description=\"Browser and mobile push alerts\"\n        disabled={disabled}\n      >\n        <PreferenceToggleRow\n          label=\"Enable push notifications\"\n          description=\"Receive browser and mobile push notifications\"\n          checked={preferences.push.enabled}\n          onChange={(checked) => updatePush({ enabled: checked })}\n          disabled={disabled}\n        />\n\n        {preferences.push.enabled && (\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n            {pushToggles.map((toggle) => (\n              <PreferenceToggleRow\n                key={toggle.key}\n                label={toggle.label}\n                checked={preferences.push[toggle.key]}\n                onChange={(checked) => updatePush({ [toggle.key]: checked } as Partial<NotificationPreferences['push']>)}\n                disabled={disabled}\n              />\n            ))}\n          </div>\n        )}\n      </PreferenceSection>\n\n      <PreferenceSection\n        title=\"In-App Notifications\"\n        icon={<Monitor className=\"w-5 h-5\" />}\n        description=\"Controls for notifications displayed inside the app\"\n        disabled={disabled}\n      >\n        <PreferenceToggleRow\n          label=\"Enable in-app notifications\"\n          description=\"Show notifications within the application\"\n          checked={preferences.inApp.enabled}\n          onChange={(checked) => updateInApp({ enabled: checked })}\n          disabled={disabled}\n        />\n\n        {preferences.inApp.enabled && (\n          <div className=\"space-y-4\">\n            <PreferenceToggleRow\n              label=\"Sound notifications\"\n              description=\"Play sound for new notifications\"\n              checked={preferences.inApp.sound}\n              onChange={(checked) => updateInApp({ sound: checked })}\n              disabled={disabled}\n            />\n            <PreferenceToggleRow\n              label=\"Desktop notifications\"\n              description=\"Show notifications even when the tab is inactive\"\n              checked={preferences.inApp.desktop}\n              onChange={(checked) => updateInApp({ desktop: checked })}\n              disabled={disabled}\n            />\n            <div className=\"space-y-2\">\n              <Label className=\"text-white\">Minimum priority level</Label>\n              <Select\n                value={preferences.inApp.priority}\n                onValueChange={(value: 'all' | 'high' | 'urgent') => updateInApp({ priority: value })}\n                disabled={disabled}\n              >\n                <SelectTrigger className=\"bg-white/20 border-white/30 text-white\">\n                  <SelectValue />\n                </SelectTrigger>\n                <SelectContent>\n                  <SelectItem value=\"all\">All notifications</SelectItem>\n                  <SelectItem value=\"high\">High priority and above</SelectItem>\n                  <SelectItem value=\"urgent\">Urgent only</SelectItem>\n                </SelectContent>\n              </Select>\n            </div>\n          </div>\n        )}\n      </PreferenceSection>\n    </div>\n  );\n};\n\nexport default NotificationPreferencesPanel;\n"}, {"path": "src/hooks/useAutoSave.ts", "content": "import { useState, useEffect, useCallback, useMemo, useRef } from 'react';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { supabase } from '@/integrations/supabase/client';\nimport { localStorage } from '@/utils/localStorage';\nimport { debounce } from '@/utils/debounce';\nimport { EventFormData, CreateEventInput, EventStatus } from '@/types/events.unified';\nimport { useToast } from './use-toast';\n\nexport type AutoSaveStatus = 'idle' | 'saving' | 'saved' | 'error';\n\ninterface AutoSaveState {\n  status: AutoSaveStatus;\n  lastSaved: Date | null;\n  error: Error | null;\n}\n\ninterface UseAutoSaveOptions {\n  formData: Partial<EventFormData>;\n  eventId?: string;\n  isEnabled?: boolean;\n  onSave?: (savedData: { id?: string; localKey: string }) => void;\n  debounceMs?: number;\n}\n\ninterface UseAutoSaveReturn extends AutoSaveState {\n  autoSaveStatus: AutoSaveStatus;\n  saveNow: () => Promise<void>;\n  clearLocalDraft: () => void;\n}\n\nconst LOCAL_STORAGE_PREFIX = 'event_draft_';\nconst LOCAL_STORAGE_TTL_MINUTES = 60 * 24 * 7; // 7 days\n\n/**\n * Transform EventFormData to CreateEventInput for database\n */\nfunction transformFormDataToInput(formData: Partial<EventFormData>): Partial<CreateEventInput> {\n  const { \n    title = '',\n    venue = '',\n    address = '',\n    city,\n    state,\n    country,\n    date,\n    time,\n    endTime,\n    type,\n    spots,\n    description,\n    requirements,\n    isVerifiedOnly,\n    isPaid,\n    allowRecording,\n    ageRestriction,\n    dresscode,\n    imageUrl,\n    capacity,\n    ticketingType,\n    externalTicketUrl,\n    tickets,\n    ...rest\n  } = formData;\n\n  return {\n    title,\n    venue,\n    address,\n    city,\n    state,\n    country,\n    event_date: date,\n    start_time: time,\n    end_time: endTime,\n    type,\n    spots,\n    description,\n    requirements,\n    is_verified_only: isVerifiedOnly,\n    is_paid: isPaid,\n    allow_recording: allowRecording,\n    age_restriction: ageRestriction,\n    dress_code: dresscode,\n    image_url: imageUrl,\n    capacity,\n    status: EventStatus.DRAFT,\n    ...rest\n  };\n}\n\n/**\n * Hook for auto-saving event form data to localStorage and database\n */\nexport function useAutoSave({\n  formData,\n  eventId,\n  isEnabled = true,\n  onSave,\n  debounceMs = 3000\n}: UseAutoSaveOptions): UseAutoSaveReturn {\n  const { user } = useAuth();\n  const { toast } = useToast();\n  const [state, setState] = useState<AutoSaveState>({\n    status: 'idle',\n    lastSaved: null,\n    error: null\n  });\n  \n  const isMountedRef = useRef(true);\n  const savePromiseRef = useRef<Promise<void> | null>(null);\n\n  useEffect(() => {\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  const getLocalStorageKey = useCallback(() => {\n    const baseKey = eventId || 'new';\n    return `${LOCAL_STORAGE_PREFIX}${user?.id || 'anon'}_${baseKey}`;\n  }, [eventId, user?.id]);\n\n  /**\n   * Save to localStorage\n   */\n  const saveToLocalStorage = useCallback(() => {\n    if (!isEnabled) return;\n\n    try {\n      const key = getLocalStorageKey();\n      const dataToSave = {\n        formData,\n        eventId,\n        userId: user?.id,\n        lastModified: new Date().toISOString()\n      };\n\n      localStorage.setItem(key, dataToSave, LOCAL_STORAGE_TTL_MINUTES);\n      \n      if (isMountedRef.current) {\n        setState(prev => ({\n          ...prev,\n          status: 'saved',\n          lastSaved: new Date(),\n          error: null\n        }));\n      }\n    } catch (error) {\n      console.error('Failed to save to localStorage:', error);\n      \n      if (error instanceof Error && error.message.includes('QUOTA_EXCEEDED')) {\n        toast({\n          title: 'Storage Full',\n          description: 'Local storage is full. Some changes may not be saved locally.',\n          variant: 'warning'\n        });\n      }\n      \n      if (isMountedRef.current) {\n        setState(prev => ({\n          ...prev,\n          status: 'error',\n          error: error instanceof Error ? error : new Error('Failed to save locally')\n        }));\n      }\n    }\n  }, [formData, eventId, user?.id, isEnabled, getLocalStorageKey, toast]);\n\n  /**\n   * Save to database as draft\n   */\n  const saveToDatabase = useCallback(async () => {\n    if (!isEnabled || !user?.id) {\n      return;\n    }\n\n    if (savePromiseRef.current) {\n      return savePromiseRef.current;\n    }\n\n    const savePromise = async () => {\n      setState(prev => ({ ...prev, status: 'saving', error: null }));\n\n      try {\n        const eventData = transformFormDataToInput(formData);\n        \n        let savedId = eventId;\n\n        if (eventId) {\n          // Update existing draft\n          const { error } = await supabase\n            .from('events')\n            .update({\n              ...eventData,\n              updated_at: new Date().toISOString()\n            })\n            .eq('id', eventId)\n            .eq('promoter_id', user.id)\n            .eq('status', EventStatus.DRAFT);\n\n          if (error) throw error;\n        } else {\n          // Create new draft\n          const { data, error } = await supabase\n            .from('events')\n            .insert({\n              ...eventData,\n              promoter_id: user.id,\n              status: EventStatus.DRAFT\n            })\n            .select('id')\n            .single();\n\n          if (error) throw error;\n          savedId = data.id;\n        }\n\n        if (isMountedRef.current) {\n          setState(prev => ({\n            ...prev,\n            status: 'saved',\n            lastSaved: new Date(),\n            error: null\n          }));\n\n          onSave?.({\n            id: savedId,\n            localKey: getLocalStorageKey()\n          });\n        }\n      } catch (error) {\n        console.error('Failed to save to database:', error);\n        \n        if (isMountedRef.current) {\n          setState(prev => ({\n            ...prev,\n            status: 'error',\n            error: error instanceof Error ? error : new Error('Failed to save to database')\n          }));\n\n          toast({\n            title: 'Auto-save failed',\n            description: 'Your changes are saved locally but could not be saved to the server.',\n            variant: 'warning'\n          });\n        }\n      } finally {\n        savePromiseRef.current = null;\n      }\n    };\n\n    savePromiseRef.current = savePromise();\n    return savePromiseRef.current;\n  }, [formData, eventId, user?.id, isEnabled, onSave, getLocalStorageKey, toast]);\n\n  /**\n   * Combined save function (localStorage + database)\n   */\n  const performSave = useCallback(async () => {\n    if (!isEnabled) return;\n\n    // Always save to localStorage first (synchronous)\n    saveToLocalStorage();\n    \n    // Then attempt to save to database\n    await saveToDatabase();\n  }, [isEnabled, saveToLocalStorage, saveToDatabase]);\n\n  // Create debounced save function\n  const debouncedSave = useMemo(() => debounce(performSave, debounceMs), [performSave, debounceMs]);\n\n  // Auto-save when form data changes\n  useEffect(() => {\n    if (isEnabled && formData && Object.keys(formData).length > 0) {\n      debouncedSave();\n    }\n\n    return () => {\n      debouncedSave.cancel();\n    };\n  }, [formData, isEnabled, debouncedSave]);\n\n  /**\n   * Manual save function (bypasses debounce)\n   */\n  const saveNow = useCallback(async () => {\n    debouncedSave.cancel();\n    await performSave();\n  }, [debouncedSave, performSave]);\n\n  /**\n   * Clear local draft\n   */\n  const clearLocalDraft = useCallback(() => {\n    const key = getLocalStorageKey();\n    localStorage.removeItem(key);\n    setState({\n      status: 'idle',\n      lastSaved: null,\n      error: null\n    });\n  }, [getLocalStorageKey]);\n\n  return {\n    status: state.status,\n    autoSaveStatus: state.status,\n    lastSaved: state.lastSaved,\n    error: state.error,\n    saveNow,\n    clearLocalDraft\n  };\n}\n"}, {"path": "src/hooks/useComedianMedia.ts", "content": "import { useState, useEffect, useCallback } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { useToast } from '@/hooks/use-toast';\n\nexport interface ComedianMediaItem {\n  id: string;\n  user_id: string;\n  media_type: 'photo' | 'video';\n  title: string | null;\n  description: string | null;\n  file_url: string | null;\n  file_size: number | null;\n  file_type: string | null;\n  external_url: string | null;\n  external_type: 'youtube' | 'google_drive' | 'vimeo' | null;\n  external_id: string | null;\n  thumbnail_url: string | null;\n  duration: number | null;\n  width: number | null;\n  height: number | null;\n  is_featured: boolean;\n  display_order: number;\n  tags: string[] | null;\n  created_at: string;\n  updated_at: string;\n}\n\ninterface UseComedianMediaProps {\n  userId?: string;\n  mediaType?: 'photo' | 'video';\n}\n\nexport const useComedianMedia = ({ userId, mediaType }: UseComedianMediaProps = {}) => {\n  const [media, setMedia] = useState<ComedianMediaItem[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n  const { toast } = useToast();\n\n  const fetchMedia = useCallback(async () => {\n    try {\n      setLoading(true);\n      setError(null);\n\n      let query = supabase\n        .from('comedian_media')\n        .select('*')\n        .order('display_order', { ascending: true })\n        .order('created_at', { ascending: false });\n\n      if (userId) {\n        query = query.eq('user_id', userId);\n      }\n\n      if (mediaType) {\n        query = query.eq('media_type', mediaType);\n      }\n\n      const { data, error: fetchError } = await query;\n\n      if (fetchError) {\n        throw fetchError;\n      }\n\n      setMedia(data || []);\n    } catch (err) {\n      console.error('Error fetching comedian media:', err);\n      setError(err instanceof Error ? err.message : 'Failed to load media');\n    } finally {\n      setLoading(false);\n    }\n  }, [mediaType, userId]);\n\n  const deleteMedia = async (mediaId: string) => {\n    try {\n      // First get the media item to check if it has a file to delete\n      const mediaItem = media.find(item => item.id === mediaId);\n      \n      if (mediaItem?.file_url) {\n        // Extract file path from URL for storage deletion\n        const url = new URL(mediaItem.file_url);\n        const pathParts = url.pathname.split('/');\n        const fileName = pathParts[pathParts.length - 1];\n        const filePath = `${mediaItem.user_id}/${fileName}`;\n        \n        // Delete from storage\n        const { error: storageError } = await supabase.storage\n          .from('comedian-media')\n          .remove([filePath]);\n        \n        if (storageError) {\n          console.warn('Storage deletion error:', storageError);\n          // Continue with database deletion even if storage fails\n        }\n      }\n\n      // Delete from database\n      const { error } = await supabase\n        .from('comedian_media')\n        .delete()\n        .eq('id', mediaId);\n\n      if (error) throw error;\n\n      // Update local state\n      setMedia(prev => prev.filter(item => item.id !== mediaId));\n\n      toast({\n        title: \"Media deleted\",\n        description: \"The media item has been removed from your portfolio.\"\n      });\n    } catch (err) {\n      console.error('Error deleting media:', err);\n      toast({\n        title: \"Delete failed\",\n        description: \"There was an error deleting the media item.\",\n        variant: \"destructive\"\n      });\n    }\n  };\n\n  const updateMedia = async (mediaId: string, updates: Partial<ComedianMediaItem>) => {\n    try {\n      const { error } = await supabase\n        .from('comedian_media')\n        .update({\n          ...updates,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', mediaId);\n\n      if (error) throw error;\n\n      // Update local state\n      setMedia(prev => prev.map(item => \n        item.id === mediaId \n          ? { ...item, ...updates, updated_at: new Date().toISOString() }\n          : item\n      ));\n\n      toast({\n        title: \"Media updated\",\n        description: \"Your changes have been saved.\"\n      });\n    } catch (err) {\n      console.error('Error updating media:', err);\n      toast({\n        title: \"Update failed\",\n        description: \"There was an error updating the media item.\",\n        variant: \"destructive\"\n      });\n    }\n  };\n\n  const reorderMedia = async (mediaId: string, newOrder: number) => {\n    try {\n      const { error } = await supabase\n        .from('comedian_media')\n        .update({ display_order: newOrder })\n        .eq('id', mediaId);\n\n      if (error) throw error;\n\n      // Update local state and re-sort\n      setMedia(prev => {\n        const updated = prev.map(item => \n          item.id === mediaId ? { ...item, display_order: newOrder } : item\n        );\n        return updated.sort((a, b) => a.display_order - b.display_order);\n      });\n    } catch (err) {\n      console.error('Error reordering media:', err);\n      toast({\n        title: \"Reorder failed\",\n        description: \"There was an error reordering the media.\",\n        variant: \"destructive\"\n      });\n    }\n  };\n\n  const getMediaUrl = (item: ComedianMediaItem): string => {\n    if (item.external_url) {\n      if (item.external_type === 'youtube' && item.external_id) {\n        return `https://www.youtube.com/watch?v=${item.external_id}`;\n      }\n      return item.external_url;\n    }\n    return item.file_url || '';\n  };\n\n  const getThumbnailUrl = (item: ComedianMediaItem): string => {\n    if (item.thumbnail_url) {\n      return item.thumbnail_url;\n    }\n    \n    if (item.external_type === 'youtube' && item.external_id) {\n      return `https://img.youtube.com/vi/${item.external_id}/maxresdefault.jpg`;\n    }\n    \n    if (item.media_type === 'photo' && item.file_url) {\n      return item.file_url;\n    }\n    \n    return '/placeholder-video.jpg'; // You'll need to add this placeholder\n  };\n\n  const getEmbedUrl = (item: ComedianMediaItem): string | null => {\n    if (item.external_type === 'youtube' && item.external_id) {\n      return `https://www.youtube.com/embed/${item.external_id}`;\n    }\n    return null;\n  };\n\n  useEffect(() => {\n    fetchMedia();\n  }, [fetchMedia]);\n\n  return {\n    media,\n    loading,\n    error,\n    fetchMedia,\n    deleteMedia,\n    updateMedia,\n    reorderMedia,\n    getMediaUrl,\n    getThumbnailUrl,\n    getEmbedUrl,\n    photos: media.filter(item => item.media_type === 'photo'),\n    videos: media.filter(item => item.media_type === 'video'),\n    featuredMedia: media.filter(item => item.is_featured)\n  };\n};\n"}, {"path": "src/hooks/useComedians.ts", "content": "\nimport { useState, useEffect, useCallback } from 'react';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { useToast } from '@/hooks/use-toast';\nimport { Comedian } from '@/types/comedian';\nimport { fetchComedians, sendComedianMessage } from '@/services/comedianService';\n\nexport const useComedians = () => {\n  const { user } = useAuth();\n  const { toast } = useToast();\n  const [comedians, setComedians] = useState<Comedian[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [contacting, setContacting] = useState<string | null>(null);\n\n  const loadComedians = useCallback(async (): Promise<void> => {\n    try {\n      const fetchedComedians = await fetchComedians();\n      setComedians(fetchedComedians);\n    } catch (error: any) {\n      toast({\n        title: \"Error\",\n        description: \"Failed to load comedians\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setLoading(false);\n    }\n  }, [toast]);\n\n  const handleContact = async (comedianId: string, comedianEmail: string): Promise<void> => {\n    if (!user) {\n      toast({\n        title: \"Authentication Required\",\n        description: \"Please sign in to contact comedians.\",\n        variant: \"destructive\",\n      });\n      return;\n    }\n\n    setContacting(comedianId);\n    try {\n      await sendComedianMessage(user.id, comedianId, comedianEmail);\n\n      toast({\n        title: \"Message Sent\",\n        description: \"Your inquiry has been sent to the comedian.\",\n      });\n    } catch (error: any) {\n      toast({\n        title: \"Error\",\n        description: \"Failed to send message\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setContacting(null);\n    }\n  };\n\n  useEffect(() => {\n    loadComedians();\n  }, [loadComedians]);\n\n  return {\n    comedians,\n    loading,\n    contacting,\n    handleContact\n  };\n};\n"}, {"path": "src/hooks/useCustomShowTypes.ts", "content": "\nimport { useState, useEffect, useCallback } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { useUser } from '@/contexts/UserContext';\n\nexport const useCustomShowTypes = () => {\n  const { user } = useUser();\n  const [customShowTypes, setCustomShowTypes] = useState<string[]>([]);\n\n  const loadCustomShowTypes = useCallback(async () => {\n    if (!user) return;\n\n    try {\n      // Load from user's profile metadata\n      const { data: profile } = await supabase\n        .from('profiles')\n        .select('custom_show_types')\n        .eq('id', user.id)\n        .single();\n\n      if (profile?.custom_show_types && Array.isArray(profile.custom_show_types)) {\n        setCustomShowTypes(profile.custom_show_types);\n      }\n    } catch (error) {\n      console.error('Error loading custom show types:', error);\n    }\n  }, [user]);\n\n  useEffect(() => {\n    if (user) {\n      loadCustomShowTypes();\n    }\n  }, [loadCustomShowTypes, user]);\n\n  const saveCustomShowType = async (showType: string) => {\n    if (!user || !showType.trim()) return;\n\n    const updatedTypes = [...new Set([...customShowTypes, showType.trim()])];\n    setCustomShowTypes(updatedTypes);\n\n    try {\n      const { error } = await supabase\n        .from('profiles')\n        .update({ custom_show_types: updatedTypes })\n        .eq('id', user.id);\n\n      if (error) {\n        console.error('Error saving custom show type:', error);\n        // Revert local state on error\n        setCustomShowTypes(customShowTypes);\n      }\n    } catch (error) {\n      console.error('Error saving custom show type:', error);\n      // Revert local state on error\n      setCustomShowTypes(customShowTypes);\n    }\n  };\n\n  return {\n    customShowTypes,\n    saveCustomShowType\n  };\n};\n"}, {"path": "src/hooks/useCustomizationData.ts", "content": "\nimport { useState, useEffect, useCallback } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { useToast } from '@/hooks/use-toast';\nimport { CustomizationData } from '@/types/customization';\n\nconst DEFAULT_SETTINGS: CustomizationData = {\n  colors: {\n    primary: '#3b82f6',\n    secondary: '#64748b',\n    tertiary: '#8b5cf6',\n    background: '#ffffff',\n    cardBackground: '#f8fafc',\n    headerBackground: '#1e293b',\n    textPrimary: '#0f172a',\n    textSecondary: '#64748b',\n    textLink: '#3b82f6',\n    border: '#e2e8f0',\n    accent: '#10b981'\n  },\n  typography: {\n    headingSize: 24,\n    bodySize: 16,\n    smallSize: 14,\n    headingWeight: 600,\n    bodyWeight: 400\n  },\n  components: {\n    buttonRadius: 6,\n    cardRadius: 8,\n    inputRadius: 6,\n    profilePictureShape: 'circle',\n    profilePictureSize: 80\n  },\n  layout: {\n    containerMaxWidth: 1200,\n    pageMargin: 16,\n    componentSpacing: 16\n  },\n  icons: {\n    size: 20,\n    color: '#64748b'\n  }\n};\n\nexport const useCustomizationData = () => {\n  const { toast } = useToast();\n  const [settings, setSettings] = useState<CustomizationData | null>(null);\n  const [savedThemes, setSavedThemes] = useState<any[]>([]);\n  const [isLoading, setIsLoading] = useState(true);\n\n  const loadSettings = useCallback(async () => {\n    try {\n      const { data, error } = await supabase\n        .from('customization_settings')\n        .select('*')\n        .eq('is_active', true)\n        .single();\n\n      if (error && error.code !== 'PGRST116') {\n        throw error;\n      }\n\n      if (data) {\n        setSettings(data.settings_data as unknown as CustomizationData);\n      } else {\n        setSettings(DEFAULT_SETTINGS);\n      }\n    } catch (error) {\n      console.error('Error loading settings:', error);\n      toast({\n        title: \"Error\",\n        description: \"Failed to load customization settings\",\n        variant: \"destructive\"\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [toast]);\n\n  const loadSavedThemes = useCallback(async () => {\n    try {\n      const { data, error } = await supabase\n        .from('customization_settings')\n        .select('*')\n        .order('created_at', { ascending: false });\n\n      if (error) throw error;\n      setSavedThemes(data || []);\n    } catch (error) {\n      console.error('Error loading saved themes:', error);\n    }\n  }, []);\n\n  const updateSettings = (section: keyof CustomizationData, key: string, value: any) => {\n    if (!settings) return;\n    \n    setSettings(prev => ({\n      ...prev!,\n      [section]: {\n        ...prev![section],\n        [key]: value\n      }\n    }));\n  };\n\n  const resetToDefault = () => {\n    setSettings(DEFAULT_SETTINGS);\n  };\n\n  useEffect(() => {\n    loadSettings();\n    loadSavedThemes();\n  }, [loadSavedThemes, loadSettings]);\n\n  return {\n    settings,\n    savedThemes,\n    isLoading,\n    updateSettings,\n    resetToDefault,\n    loadSettings,\n    loadSavedThemes\n  };\n};\n"}, {"path": "src/hooks/useDeadlineMonitoring.ts", "content": "import { useState, useEffect, useCallback } from 'react';\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { deadlineMonitoringService } from '@/services/deadlineMonitoringService';\nimport { useToast } from '@/hooks/use-toast';\n\ninterface UseDeadlineMonitoringOptions {\n  promoterId: string;\n  autoRefresh?: boolean;\n  refreshInterval?: number;\n}\n\nexport function useDeadlineMonitoring({ \n  promoterId, \n  autoRefresh = true, \n  refreshInterval = 120000 // 2 minutes\n}: UseDeadlineMonitoringOptions) {\n  const queryClient = useQueryClient();\n  const { toast } = useToast();\n  const [isMonitoring, setIsMonitoring] = useState(false);\n\n  // Query for dashboard data\n  const {\n    data: dashboardData,\n    isLoading,\n    error,\n    refetch\n  } = useQuery({\n    queryKey: ['deadline-monitoring', promoterId],\n    queryFn: () => deadlineMonitoringService.getMonitoringDashboard(promoterId),\n    refetchInterval: autoRefresh ? refreshInterval : false,\n    staleTime: 60000, // Consider data stale after 1 minute\n  });\n\n  // Mutation for extending deadlines\n  const extendDeadlineMutation = useMutation({\n    mutationFn: ({ \n      spotId, \n      newDeadline, \n      reason \n    }: { \n      spotId: string; \n      newDeadline: Date; \n      reason?: string \n    }) => deadlineMonitoringService.extendDeadline(spotId, newDeadline, promoterId, reason),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['deadline-monitoring', promoterId] });\n      toast({\n        title: 'Success',\n        description: 'Deadline extended successfully',\n      });\n    },\n    onError: (error) => {\n      toast({\n        title: 'Error',\n        description: 'Failed to extend deadline',\n        variant: 'destructive',\n      });\n    },\n  });\n\n  // Start monitoring service\n  const startMonitoring = useCallback(() => {\n    if (!isMonitoring) {\n      deadlineMonitoringService.startMonitoring();\n      setIsMonitoring(true);\n      toast({\n        title: 'Monitoring Started',\n        description: 'Deadline monitoring service is now active',\n      });\n    }\n  }, [isMonitoring, toast]);\n\n  // Stop monitoring service\n  const stopMonitoring = useCallback(() => {\n    if (isMonitoring) {\n      deadlineMonitoringService.stopMonitoring();\n      setIsMonitoring(false);\n      toast({\n        title: 'Monitoring Stopped',\n        description: 'Deadline monitoring service has been stopped',\n      });\n    }\n  }, [isMonitoring, toast]);\n\n  // Manual check for expired deadlines\n  const checkExpiredDeadlines = useCallback(async () => {\n    try {\n      const result = await deadlineMonitoringService.checkExpiredDeadlines();\n      \n      if (result.expired > 0) {\n        toast({\n          title: 'Deadlines Processed',\n          description: `${result.expired} expired spots have been processed`,\n        });\n        \n        // Refresh dashboard\n        refetch();\n      }\n      \n      return result;\n    } catch (error) {\n      toast({\n        title: 'Error',\n        description: 'Failed to check expired deadlines',\n        variant: 'destructive',\n      });\n      throw error;\n    }\n  }, [refetch, toast]);\n\n  // Get spots by urgency\n  const getSpotsByUrgency = useCallback((urgency: 'critical' | 'urgent' | 'upcoming') => {\n    if (!dashboardData?.events) return [];\n    \n    const now = new Date();\n    const spots: any[] = [];\n    \n    dashboardData.events.forEach(event => {\n      event.event_spots?.forEach(spot => {\n        if (spot.confirmation_status === 'pending' && spot.confirmation_deadline) {\n          const deadline = new Date(spot.confirmation_deadline);\n          const hoursUntil = (deadline.getTime() - now.getTime()) / (1000 * 60 * 60);\n          \n          let matchesUrgency = false;\n          switch (urgency) {\n            case 'critical':\n              matchesUrgency = hoursUntil <= 1 && hoursUntil > 0;\n              break;\n            case 'urgent':\n              matchesUrgency = hoursUntil <= 6 && hoursUntil > 1;\n              break;\n            case 'upcoming':\n              matchesUrgency = hoursUntil <= 24 && hoursUntil > 6;\n              break;\n          }\n          \n          if (matchesUrgency) {\n            spots.push({\n              ...spot,\n              event: {\n                id: event.id,\n                title: event.title,\n                event_date: event.event_date\n              },\n              hoursUntilDeadline: hoursUntil\n            });\n          }\n        }\n      });\n    });\n    \n    return spots.sort((a, b) => a.hoursUntilDeadline - b.hoursUntilDeadline);\n  }, [dashboardData]);\n\n  // Auto-start monitoring on mount\n  useEffect(() => {\n    startMonitoring();\n\n    return () => {\n      stopMonitoring();\n    };\n  }, [startMonitoring, stopMonitoring]);\n\n  return {\n    // Data\n    dashboardData,\n    stats: dashboardData?.stats || {\n      total_pending: 0,\n      expiring_24h: 0,\n      expiring_6h: 0,\n      expired_today: 0,\n      confirmed_today: 0\n    },\n    events: dashboardData?.events || [],\n    lastUpdated: dashboardData?.lastUpdated ? new Date(dashboardData.lastUpdated) : null,\n    \n    // Loading states\n    isLoading,\n    error,\n    isMonitoring,\n    \n    // Actions\n    refetch,\n    startMonitoring,\n    stopMonitoring,\n    checkExpiredDeadlines,\n    extendDeadline: extendDeadlineMutation.mutate,\n    isExtending: extendDeadlineMutation.isPending,\n    \n    // Utilities\n    getSpotsByUrgency,\n  };\n}\n"}, {"path": "src/hooks/useDesignSystem.ts", "content": "\nimport { useState, useEffect, useCallback } from 'react';\nimport { DesignSystemSettings } from '@/types/designSystem';\nimport { DEFAULT_DESIGN_SETTINGS } from '@/utils/designSystem/defaultSettings';\nimport { applyCSSVariables } from '@/utils/designSystem/cssVariables';\nimport { useDesignSystemSettings } from './useDesignSystemSettings';\nimport { useDesignSystemPersistence } from './useDesignSystemPersistence';\nimport { useToast } from '@/hooks/use-toast';\n\nexport const useDesignSystem = () => {\n  const [isLoading, setIsLoading] = useState(true);\n  const { settings, setSettings, updateSetting, resetToDefault: resetSettingsToDefault } = useDesignSystemSettings();\n  const { loadSettings, saveSettings: persistSettings } = useDesignSystemPersistence();\n  const { toast } = useToast();\n\n  const loadSettingsAsync = useCallback(async () => {\n    setIsLoading(true);\n    try {\n      const loadedSettings = await loadSettings();\n      setSettings(loadedSettings);\n    } catch (error) {\n      console.error('Failed to load design settings:', error);\n      toast({\n        title: \"Error\",\n        description: \"Failed to load design settings, using defaults\",\n        variant: \"destructive\"\n      });\n    } finally {\n      setIsLoading(false);\n    }\n  }, [loadSettings, setSettings, toast]);\n\n  const saveSettings = async (presetName?: string) => {\n    await persistSettings(settings, presetName);\n  };\n\n  const resetToDefault = () => {\n    resetSettingsToDefault();\n    applyCSSVariables(DEFAULT_DESIGN_SETTINGS);\n  };\n\n  useEffect(() => {\n    loadSettingsAsync();\n  }, [loadSettingsAsync]);\n\n  useEffect(() => {\n    applyCSSVariables(settings);\n  }, [settings]);\n\n  return {\n    settings,\n    updateSetting,\n    saveSettings,\n    resetToDefault,\n    isLoading,\n    loadSettings: loadSettingsAsync\n  };\n};\n"}, {"path": "src/hooks/useEventDuplicateCheck.ts", "content": "import { useState, useEffect, useCallback, useMemo } from 'react';\nimport { checkForDuplicateEvents, checkVenueAvailability, DuplicateCheckResult } from '@/utils/eventDuplicateChecker';\nimport { debounce } from '@/utils/debounce';\nimport { useToast } from './use-toast';\n\ninterface UseEventDuplicateCheckOptions {\n  excludeEventId?: string;\n  debounceMs?: number;\n  autoCheck?: boolean;\n}\n\nexport const useEventDuplicateCheck = (\n  title: string,\n  date: string,\n  venue: string,\n  startTime?: string,\n  endTime?: string,\n  options: UseEventDuplicateCheckOptions = {}\n) => {\n  const {\n    excludeEventId,\n    debounceMs = 1000,\n    autoCheck = true\n  } = options;\n\n  const { toast } = useToast();\n  const [isChecking, setIsChecking] = useState(false);\n  const [duplicateResult, setDuplicateResult] = useState<DuplicateCheckResult>({\n    isDuplicate: false,\n    similarEvents: [],\n    warnings: []\n  });\n  const [venueAvailability, setVenueAvailability] = useState<{\n    isAvailable: boolean;\n    conflicts: Array<{ id: string; title: string; time: string; }>;\n  }>({\n    isAvailable: true,\n    conflicts: []\n  });\n\n  // Check for duplicates\n  const checkDuplicates = useCallback(async () => {\n    if (!title || !date || !venue) {\n      setDuplicateResult({\n        isDuplicate: false,\n        similarEvents: [],\n        warnings: []\n      });\n      return;\n    }\n\n    setIsChecking(true);\n    try {\n      const result = await checkForDuplicateEvents(title, date, venue, excludeEventId);\n      setDuplicateResult(result);\n\n      // Show toast for high similarity duplicates\n      if (result.isDuplicate && result.warnings.length > 0) {\n        toast({\n          title: \"Possible Duplicate Event\",\n          description: result.warnings[0],\n          variant: \"warning\",\n        });\n      }\n    } catch (error) {\n      console.error('Error checking duplicates:', error);\n    } finally {\n      setIsChecking(false);\n    }\n  }, [title, date, venue, excludeEventId, toast]);\n\n  // Check venue availability\n  const checkVenue = useCallback(async () => {\n    if (!venue || !date || !startTime) {\n      setVenueAvailability({\n        isAvailable: true,\n        conflicts: []\n      });\n      return;\n    }\n\n    try {\n      const result = await checkVenueAvailability(venue, date, startTime, endTime, excludeEventId);\n      setVenueAvailability(result);\n\n      // Show toast for conflicts\n      if (!result.isAvailable && result.conflicts.length > 0) {\n        toast({\n          title: \"Venue Scheduling Conflict\",\n          description: `${venue} already has ${result.conflicts.length} event(s) scheduled at this time.`,\n          variant: \"destructive\",\n        });\n      }\n    } catch (error) {\n      console.error('Error checking venue availability:', error);\n    }\n  }, [venue, date, startTime, endTime, excludeEventId, toast]);\n\n  // Debounced check functions\n  const debouncedCheckDuplicates = useMemo(() => debounce(checkDuplicates, debounceMs), [checkDuplicates, debounceMs]);\n\n  const debouncedCheckVenue = useMemo(() => debounce(checkVenue, debounceMs), [checkVenue, debounceMs]);\n\n  // Auto-check when values change\n  useEffect(() => {\n    if (autoCheck) {\n      debouncedCheckDuplicates();\n    }\n  }, [title, date, venue, autoCheck, debouncedCheckDuplicates]);\n\n  useEffect(() => {\n    if (autoCheck && startTime) {\n      debouncedCheckVenue();\n    }\n  }, [venue, date, startTime, endTime, autoCheck, debouncedCheckVenue]);\n\n  // Manual check function\n  const performCheck = useCallback(async () => {\n    await Promise.all([\n      checkDuplicates(),\n      checkVenue()\n    ]);\n  }, [checkDuplicates, checkVenue]);\n\n  // Get combined warnings\n  const getAllWarnings = useCallback(() => {\n    const warnings: string[] = [...duplicateResult.warnings];\n    \n    if (!venueAvailability.isAvailable) {\n      warnings.push(`Venue conflict: ${venueAvailability.conflicts.length} event(s) already scheduled`);\n    }\n    \n    return warnings;\n  }, [duplicateResult.warnings, venueAvailability]);\n\n  // Check if event can be safely created\n  const canCreateEvent = useCallback(() => {\n    return !duplicateResult.isDuplicate && venueAvailability.isAvailable;\n  }, [duplicateResult.isDuplicate, venueAvailability.isAvailable]);\n\n  return {\n    // State\n    isChecking,\n    duplicateResult,\n    venueAvailability,\n    \n    // Computed\n    hasDuplicateWarning: duplicateResult.similarEvents.length > 0,\n    hasVenueConflict: !venueAvailability.isAvailable,\n    canCreateEvent: canCreateEvent(),\n    allWarnings: getAllWarnings(),\n    \n    // Actions\n    checkDuplicates: performCheck,\n    clearResults: () => {\n      setDuplicateResult({\n        isDuplicate: false,\n        similarEvents: [],\n        warnings: []\n      });\n      setVenueAvailability({\n        isAvailable: true,\n        conflicts: []\n      });\n    }\n  };\n};\n"}, {"path": "src/hooks/useInvoices.ts", "content": "\nimport { useState, useEffect, useCallback } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { toast } from '@/hooks/use-toast';\nimport { format, isThisMonth, isThisQuarter, isThisYear, isBefore, subMonths, isAfter, startOfMonth, endOfMonth } from 'date-fns';\nimport { Invoice, DateFilter, AmountRange } from '@/types/invoice';\n\nexport const useInvoices = () => {\n  const { user, hasRole } = useAuth();\n  const [invoices, setInvoices] = useState<Invoice[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  const fetchInvoices = useCallback(async () => {\n    if (!user) {\n      console.log('=== NO USER FOR INVOICE FETCH ===');\n      setLoading(false);\n      return;\n    }\n\n    try {\n      setLoading(true);\n      setError(null);\n      \n      console.log('=== STARTING INVOICE FETCH ===', user.id);\n      \n      const { data, error } = await supabase\n        .from('invoices')\n        .select(`\n          id,\n          invoice_type,\n          invoice_number,\n          issue_date,\n          due_date,\n          status,\n          total_amount,\n          subtotal,\n          tax_amount,\n          tax_rate,\n          currency,\n          promoter_id,\n          comedian_id,\n          sender_name,\n          sender_email,\n          sender_address,\n          sender_phone,\n          sender_abn,\n          client_address,\n          client_mobile,\n          gst_treatment,\n          tax_treatment,\n          xero_invoice_id,\n          last_synced_at,\n          paid_at,\n          created_by,\n          created_at,\n          updated_at,\n          deposit_amount,\n          deposit_percentage,\n          deposit_due_days_before_event,\n          deposit_due_date,\n          deposit_status,\n          deposit_paid_date,\n          deposit_paid_amount,\n          event_date,\n          invoice_recipients (\n            recipient_name,\n            recipient_email,\n            recipient_mobile,\n            recipient_address,\n            recipient_phone,\n            recipient_type,\n            recipient_abn,\n            company_name,\n            abn\n          )\n        `)\n        .or(`promoter_id.eq.${user.id},comedian_id.eq.${user.id}`)\n        .order('created_at', { ascending: false });\n\n      console.log('=== INVOICE FETCH RESPONSE ===', { data, error });\n\n      if (error) {\n        console.error('=== INVOICE FETCH ERROR ===', error);\n        throw error;\n      }\n\n      console.log('=== INVOICES FETCHED SUCCESSFULLY ===', data?.length || 0);\n      \n      // Type cast the data to match our Invoice interface\n      const typedInvoices: Invoice[] = (data || []).map(invoice => ({\n        ...invoice,\n        gst_treatment: invoice.gst_treatment as 'inclusive' | 'exclusive' | 'none'\n      }));\n      \n      setInvoices(typedInvoices);\n    } catch (error) {\n      console.error('=== ERROR FETCHING INVOICES ===', error);\n      const errorMessage = error instanceof Error ? error.message : 'Failed to load invoices';\n      setError(errorMessage);\n      toast({\n        title: \"Error\",\n        description: errorMessage,\n        variant: \"destructive\"\n      });\n    } finally {\n      setLoading(false);\n    }\n  }, [user]);\n\n  useEffect(() => {\n    if (user && (hasRole('promoter') || hasRole('comedian') || hasRole('admin'))) {\n      console.log('=== FETCHING INVOICES ===', user.id);\n      fetchInvoices();\n    } else {\n      console.log('=== NO USER OR INSUFFICIENT PERMISSIONS, CLEARING INVOICES ===');\n      setInvoices([]);\n      setLoading(false);\n      setError(null);\n    }\n  }, [fetchInvoices, hasRole, user]);\n\n  const deleteInvoice = async (invoiceId: string) => {\n    if (!confirm('Are you sure you want to delete this invoice?')) return;\n\n    try {\n      const { error } = await supabase\n        .from('invoices')\n        .delete()\n        .eq('id', invoiceId);\n\n      if (error) throw error;\n\n      setInvoices(prev => prev.filter(invoice => invoice.id !== invoiceId));\n      toast({\n        title: \"Success\",\n        description: \"Invoice deleted successfully\"\n      });\n    } catch (error) {\n      console.error('Error deleting invoice:', error);\n      toast({\n        title: \"Error\",\n        description: \"Failed to delete invoice\",\n        variant: \"destructive\"\n      });\n    }\n  };\n\n  const matchesDateFilter = (invoice: Invoice, dateFilter: DateFilter) => {\n    if (dateFilter === 'all') return true;\n    \n    const issueDate = new Date(invoice.issue_date);\n    const dueDate = new Date(invoice.due_date);\n    \n    switch (dateFilter) {\n      case 'this-month':\n        return isThisMonth(issueDate);\n      case 'last-month':\n        const lastMonth = subMonths(new Date(), 1);\n        const lastMonthStart = startOfMonth(lastMonth);\n        const lastMonthEnd = endOfMonth(lastMonth);\n        return isAfter(issueDate, lastMonthStart) && isBefore(issueDate, lastMonthEnd);\n      case 'this-quarter':\n        return isThisQuarter(issueDate);\n      case 'this-year':\n        return isThisYear(issueDate);\n      case 'overdue':\n        return isBefore(dueDate, new Date()) && invoice.status !== 'paid';\n      default:\n        return true;\n    }\n  };\n\n  const matchesAmountRange = (invoice: Invoice, amountRange: AmountRange) => {\n    const amount = invoice.total_amount;\n    return amount >= amountRange.min && amount <= amountRange.max;\n  };\n\n  const filterInvoices = (searchTerm: string, statusFilter: string, dateFilter: DateFilter, amountRange: AmountRange) => {\n    return invoices.filter(invoice => {\n      const matchesSearch = \n        invoice.invoice_number.toLowerCase().includes(searchTerm.toLowerCase()) ||\n        invoice.invoice_recipients.some(recipient => \n          recipient.recipient_name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n          recipient.recipient_email.toLowerCase().includes(searchTerm.toLowerCase())\n        );\n      \n      const matchesStatus = statusFilter === 'all' || invoice.status === statusFilter;\n      \n      return matchesSearch && matchesStatus && matchesDateFilter(invoice, dateFilter) && matchesAmountRange(invoice, amountRange);\n    });\n  };\n\n  return {\n    invoices,\n    loading,\n    error,\n    deleteInvoice,\n    filterInvoices,\n    refetchInvoices: fetchInvoices\n  };\n};\n"}, {"path": "src/hooks/useLineupData.ts", "content": "\nimport { useState, useEffect, useCallback } from 'react';\nimport { useToast } from '@/hooks/use-toast';\nimport { supabase } from '@/integrations/supabase/client';\n\ninterface ComedianBooking {\n  id: string;\n  comedian_id: string;\n  performance_fee: number;\n  payment_status: string;\n  set_duration: number;\n  performance_notes?: string;\n  currency: string;\n  created_at: string;\n  is_selected: boolean;\n  payment_type: 'fixed' | 'percentage_revenue' | 'percentage_door';\n  percentage_amount: number;\n  is_editable: boolean;\n  comedian_name?: string;\n  comedian_email?: string;\n}\n\nexport const useLineupData = (eventId: string) => {\n  const { toast } = useToast();\n  const [loading, setLoading] = useState(true);\n  const [bookings, setBookings] = useState<ComedianBooking[]>([]);\n  const [totalFees, setTotalFees] = useState(0);\n  const [selectedBookings, setSelectedBookings] = useState<string[]>([]);\n  const [eventRevenue, setEventRevenue] = useState(0);\n\n  const fetchLineupData = useCallback(async () => {\n    try {\n      setLoading(true);\n      \n      // Fetch comedian bookings with profile information\n      const { data: bookingsData, error: bookingsError } = await supabase\n        .from('comedian_bookings')\n        .select(`\n          *,\n          profiles!comedian_bookings_comedian_id_fkey (\n            name,\n            email,\n            stage_name\n          )\n        `)\n        .eq('event_id', eventId)\n        .order('created_at', { ascending: false });\n\n      if (bookingsError) throw bookingsError;\n\n      // Transform data to include comedian info with proper type casting\n      const transformedBookings = bookingsData?.map(booking => ({\n        ...booking,\n        comedian_name: booking.profiles?.stage_name || booking.profiles?.name || 'Unknown Comedian',\n        comedian_email: booking.profiles?.email || '',\n        is_selected: booking.is_selected || false,\n        payment_type: (booking.payment_type || 'fixed') as 'fixed' | 'percentage_revenue' | 'percentage_door',\n        percentage_amount: booking.percentage_amount || 0,\n        is_editable: booking.is_editable !== false\n      })) || [];\n\n      setBookings(transformedBookings);\n      \n      // Get selected bookings\n      const selected = transformedBookings\n        .filter(booking => booking.is_selected)\n        .map(booking => booking.id);\n      setSelectedBookings(selected);\n\n      // Fetch event revenue for percentage calculations\n      const { data: revenueData } = await supabase\n        .from('ticket_sales')\n        .select('total_amount')\n        .eq('event_id', eventId);\n      \n      const totalRevenue = revenueData?.reduce((sum, sale) => sum + Number(sale.total_amount), 0) || 0;\n      setEventRevenue(totalRevenue);\n      \n      // Calculate total fees including percentage-based payments\n      await calculateTotalFees(transformedBookings, totalRevenue);\n\n    } catch (error: any) {\n      console.error('Error fetching lineup data:', error);\n      toast({\n        title: \"Error\",\n        description: \"Failed to load lineup data\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setLoading(false);\n    }\n  }, [eventId, toast]);\n\n  const calculateTotalFees = async (bookingsList: ComedianBooking[], revenue: number) => {\n    let total = 0;\n    \n    for (const booking of bookingsList) {\n      if (booking.payment_type === 'fixed') {\n        total += Number(booking.performance_fee);\n      } else if (booking.payment_type === 'percentage_revenue') {\n        total += (revenue * booking.percentage_amount / 100);\n      } else if (booking.payment_type === 'percentage_door') {\n        total += (revenue * booking.percentage_amount / 100);\n      }\n    }\n    \n    setTotalFees(total);\n  };\n\n  useEffect(() => {\n    fetchLineupData();\n  }, [fetchLineupData]);\n\n  return {\n    loading,\n    bookings,\n    setBookings,\n    totalFees,\n    selectedBookings,\n    setSelectedBookings,\n    eventRevenue,\n    fetchLineupData,\n  };\n};\n"}, {"path": "src/hooks/useNotifications.ts", "content": "\n// Enhanced Unified Notifications Hook - Real-time notifications across the entire platform\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { supabase } from '@/integrations/supabase/client';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { notificationService } from '@/services/notificationService';\nimport type {\n  Notification,\n  NotificationType,\n  CreateNotificationRequest,\n  NotificationPreferences as ServerNotificationPreferences\n} from '@/services/notificationService';\nimport type { NotificationPreferences as UIPreferences } from '@/components/notifications/types';\n\nconst DEFAULT_UI_PREFERENCES: UIPreferences = {\n  email: {\n    enabled: true,\n    eventUpdates: true,\n    bookingNotifications: true,\n    paymentAlerts: true,\n    systemMessages: true,\n    promotions: false,\n    frequency: 'immediate'\n  },\n  push: {\n    enabled: true,\n    eventUpdates: true,\n    bookingNotifications: true,\n    paymentAlerts: true,\n    systemMessages: true\n  },\n  inApp: {\n    enabled: true,\n    sound: true,\n    desktop: true,\n    priority: 'all'\n  }\n};\n\nconst EVENT_UPDATE_TYPES: NotificationType[] = [\n  'tour_created',\n  'tour_updated',\n  'tour_cancelled',\n  'event_booking',\n  'event_cancelled',\n  'spot_assigned',\n  'spot_confirmation_deadline',\n  'spot_reminder'\n];\n\nconst BOOKING_TYPES: NotificationType[] = [\n  'spot_assigned',\n  'spot_confirmed',\n  'spot_declined',\n  'spot_cancelled'\n];\n\nconst PAYMENT_TYPES: NotificationType[] = ['payment_received', 'payment_due'];\nconst SYSTEM_TYPES: NotificationType[] = ['system_update', 'general'];\n\nconst EMAIL_CATEGORY_MAP: Record<keyof UIPreferences['email'], NotificationType[]> = {\n  enabled: [],\n  eventUpdates: EVENT_UPDATE_TYPES,\n  bookingNotifications: BOOKING_TYPES,\n  paymentAlerts: PAYMENT_TYPES,\n  systemMessages: SYSTEM_TYPES,\n  promotions: []\n};\n\nconst PUSH_CATEGORY_MAP: Record<keyof UIPreferences['push'], NotificationType[]> = {\n  enabled: [],\n  eventUpdates: EVENT_UPDATE_TYPES,\n  bookingNotifications: BOOKING_TYPES,\n  paymentAlerts: PAYMENT_TYPES,\n  systemMessages: SYSTEM_TYPES\n};\n\nconst cloneDefaultPreferences = (): UIPreferences => structuredClone\n  ? structuredClone(DEFAULT_UI_PREFERENCES)\n  : JSON.parse(JSON.stringify(DEFAULT_UI_PREFERENCES));\n\nconst mapServerToUIPreferences = (\n  serverPreferences?: ServerNotificationPreferences | null,\n  previous?: UIPreferences\n): UIPreferences => {\n  const base = cloneDefaultPreferences();\n  const startingPoint = previous ?? base;\n\n  if (!serverPreferences) {\n    return {\n      ...base,\n      inApp: startingPoint.inApp\n    };\n  }\n\n  const result = cloneDefaultPreferences();\n  result.email.enabled = !!serverPreferences.email_notifications;\n  result.push.enabled = !!serverPreferences.push_notifications;\n\n  const typeSettings = serverPreferences.notification_types ?? {};\n  const hasChannel = (types: NotificationType[], channel: 'email' | 'push'): boolean =>\n    types.some(type => typeSettings[type]?.[channel]);\n\n  result.email.eventUpdates = result.email.enabled && hasChannel(EVENT_UPDATE_TYPES, 'email');\n  result.email.bookingNotifications = result.email.enabled && hasChannel(BOOKING_TYPES, 'email');\n  result.email.paymentAlerts = result.email.enabled && hasChannel(PAYMENT_TYPES, 'email');\n  result.email.systemMessages = result.email.enabled && hasChannel(SYSTEM_TYPES, 'email');\n  result.email.promotions = result.email.enabled && hasChannel([], 'email');\n\n  result.push.eventUpdates = result.push.enabled && hasChannel(EVENT_UPDATE_TYPES, 'push');\n  result.push.bookingNotifications = result.push.enabled && hasChannel(BOOKING_TYPES, 'push');\n  result.push.paymentAlerts = result.push.enabled && hasChannel(PAYMENT_TYPES, 'push');\n  result.push.systemMessages = result.push.enabled && hasChannel(SYSTEM_TYPES, 'push');\n\n  // Preserve existing in-app settings\n  result.inApp = startingPoint.inApp;\n\n  return result;\n};\n\nconst mapUIToServerPreferences = (\n  uiPreferences: UIPreferences,\n  existing?: ServerNotificationPreferences | null\n): Partial<ServerNotificationPreferences> => {\n  const notificationTypes: ServerNotificationPreferences['notification_types'] = {\n    ...(existing?.notification_types ?? {})\n  };\n\n  const applyChannel = (\n    types: NotificationType[],\n    channel: 'email' | 'push',\n    enabled: boolean,\n    channelEnabled: boolean\n  ) => {\n    types.forEach(type => {\n      const entry = notificationTypes[type] ?? { enabled: false, email: false, push: false, sms: false };\n      entry[channel] = channelEnabled && enabled;\n      entry.enabled = entry.email || entry.push || entry.sms;\n      notificationTypes[type] = entry;\n    });\n  };\n\n  applyChannel(EVENT_UPDATE_TYPES, 'email', uiPreferences.email.eventUpdates, uiPreferences.email.enabled);\n  applyChannel(BOOKING_TYPES, 'email', uiPreferences.email.bookingNotifications, uiPreferences.email.enabled);\n  applyChannel(PAYMENT_TYPES, 'email', uiPreferences.email.paymentAlerts, uiPreferences.email.enabled);\n  applyChannel(SYSTEM_TYPES, 'email', uiPreferences.email.systemMessages, uiPreferences.email.enabled);\n\n  applyChannel(EVENT_UPDATE_TYPES, 'push', uiPreferences.push.eventUpdates, uiPreferences.push.enabled);\n  applyChannel(BOOKING_TYPES, 'push', uiPreferences.push.bookingNotifications, uiPreferences.push.enabled);\n  applyChannel(PAYMENT_TYPES, 'push', uiPreferences.push.paymentAlerts, uiPreferences.push.enabled);\n  applyChannel(SYSTEM_TYPES, 'push', uiPreferences.push.systemMessages, uiPreferences.push.enabled);\n\n  return {\n    email_notifications: uiPreferences.email.enabled,\n    push_notifications: uiPreferences.push.enabled,\n    sms_notifications: existing?.sms_notifications ?? false,\n    notification_types: notificationTypes\n  };\n};\n\nconst mergeUIPreferences = (\n  current: UIPreferences,\n  updates: Partial<UIPreferences>\n): UIPreferences => ({\n  email: { ...current.email, ...(updates.email ?? {}) },\n  push: { ...current.push, ...(updates.push ?? {}) },\n  inApp: { ...current.inApp, ...(updates.inApp ?? {}) }\n});\n\nexport interface UseNotificationsOptions {\n  autoMarkAsRead?: boolean;\n  enableRealtime?: boolean;\n  types?: NotificationType[];\n  unreadOnly?: boolean;\n  limit?: number;\n}\n\nexport const useNotifications = (options: UseNotificationsOptions = {}) => {\n  const { user } = useAuth();\n  const queryClient = useQueryClient();\n  \n  const [isSubscribed, setIsSubscribed] = useState(false);\n  const [realtimeError, setRealtimeError] = useState<Error | null>(null);\n\n  const {\n    autoMarkAsRead = false,\n    enableRealtime = true,\n    types,\n    unreadOnly = false,\n    limit = 50\n  } = options;\n\n  // Enhanced query with more features\n  const { \n    data: notificationsData, \n    isLoading: notificationsLoading, \n    error: notificationsError,\n    refetch: refetchNotifications \n  } = useQuery({\n    queryKey: ['notifications', user?.id, { types, unreadOnly, limit }],\n    queryFn: async () => {\n      if (!user?.id) return { notifications: [], total: 0 };\n      \n      // Use enhanced notification service if available, otherwise fallback to basic query\n      if (typeof notificationService !== 'undefined' && notificationService.getNotifications) {\n        return notificationService.getNotifications(user.id, {\n          types,\n          unread_only: unreadOnly,\n          limit\n        });\n      } else {\n        // Fallback to basic notification query\n        let query = supabase\n          .from('notifications')\n          .select('*', { count: 'exact' })\n          .eq('user_id', user.id);\n\n        if (unreadOnly) {\n          query = query.eq('is_read', false);\n        }\n\n        if (types?.length) {\n          query = query.in('type', types);\n        }\n\n        query = query.order('created_at', { ascending: false });\n\n        if (limit) {\n          query = query.limit(limit);\n        }\n\n        const { data, error, count } = await query;\n\n        if (error) throw error;\n\n        return {\n          notifications: data || [],\n          total: count || 0\n        };\n      }\n    },\n    enabled: !!user?.id,\n    staleTime: 30000,\n    refetchInterval: enableRealtime ? undefined : 60000\n  });\n\n  // Unread count query\n  const { \n    data: unreadCount, \n    isLoading: countLoading \n  } = useQuery({\n    queryKey: ['notifications-count', user?.id],\n    queryFn: async () => {\n      if (!user?.id) return 0;\n      \n      if (typeof notificationService !== 'undefined' && notificationService.getUnreadCount) {\n        return notificationService.getUnreadCount(user.id);\n      } else {\n        // Fallback count query\n        const { count, error } = await supabase\n          .from('notifications')\n          .select('*', { count: 'exact', head: true })\n          .eq('user_id', user.id)\n          .eq('is_read', false);\n\n        if (error) throw error;\n        return count || 0;\n      }\n    },\n    enabled: !!user?.id,\n    staleTime: 10000,\n    refetchInterval: 30000\n  });\n\n  // Notification preferences query\n  const { \n    data: preferences, \n    isLoading: preferencesLoading \n  } = useQuery({\n    queryKey: ['notification-preferences', user?.id],\n    queryFn: async () => {\n      if (!user?.id) return null;\n      \n      if (typeof notificationService !== 'undefined' && notificationService.getNotificationPreferences) {\n        return notificationService.getNotificationPreferences(user.id);\n      }\n      return null;\n    },\n    enabled: !!user?.id,\n    staleTime: 300000\n  });\n\n  // Mark as read mutation\n  const markAsReadMutation = useMutation({\n    mutationFn: async (notificationId: string) => {\n      if (typeof notificationService !== 'undefined' && notificationService.markAsRead) {\n        return notificationService.markAsRead(notificationId);\n      } else {\n        // Fallback mark as read\n        const { error } = await supabase\n          .from('notifications')\n          .update({\n            is_read: true,\n            read_at: new Date().toISOString()\n          })\n          .eq('id', notificationId);\n\n        if (error) throw error;\n      }\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['notifications'] });\n      queryClient.invalidateQueries({ queryKey: ['notifications-count'] });\n    }\n  });\n\n  // Mark all as read mutation\n  const markAllAsReadMutation = useMutation({\n    mutationFn: async () => {\n      if (!user?.id) throw new Error('User not authenticated');\n      \n      if (typeof notificationService !== 'undefined' && notificationService.markAllAsRead) {\n        return notificationService.markAllAsRead(user.id);\n      } else {\n        // Fallback mark all as read\n        const { error } = await supabase\n          .from('notifications')\n          .update({\n            is_read: true,\n            read_at: new Date().toISOString()\n          })\n          .eq('user_id', user.id)\n          .eq('is_read', false);\n\n        if (error) throw error;\n      }\n    },\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['notifications'] });\n      queryClient.invalidateQueries({ queryKey: ['notifications-count'] });\n    }\n  });\n\n  // Real-time subscription\n  const subscribe = useCallback(() => {\n    if (!user?.id || !enableRealtime) {\n      return () => {};\n    }\n\n    setIsSubscribed(true);\n    setRealtimeError(null);\n\n    // Try to use enhanced notification service subscription\n    if (typeof notificationService !== 'undefined' && notificationService.subscribe) {\n      const unsubscribe = notificationService.subscribe(user.id, (notification) => {\n        queryClient.invalidateQueries({ queryKey: ['notifications'] });\n        queryClient.invalidateQueries({ queryKey: ['notifications-count'] });\n\n        if (autoMarkAsRead && (!types || types.includes(notification.type))) {\n          markAsReadMutation.mutate(notification.id);\n        }\n      });\n\n      return () => {\n        unsubscribe();\n        setIsSubscribed(false);\n      };\n    } else {\n      // Fallback real-time subscription using Supabase directly\n      const channel = supabase\n        .channel('notifications')\n        .on(\n          'postgres_changes',\n          {\n            event: 'INSERT',\n            schema: 'public',\n            table: 'notifications',\n            filter: `user_id=eq.${user.id}`\n          },\n          () => {\n            queryClient.invalidateQueries({ queryKey: ['notifications'] });\n            queryClient.invalidateQueries({ queryKey: ['notifications-count'] });\n          }\n        )\n        .subscribe();\n\n      return () => {\n        supabase.removeChannel(channel);\n        setIsSubscribed(false);\n      };\n    }\n  }, [user?.id, enableRealtime, autoMarkAsRead, types, queryClient, markAsReadMutation]);\n\n  // Auto-subscribe when hook is used\n  useEffect(() => {\n    if (enableRealtime && user?.id) {\n      const unsubscribe = subscribe();\n      return unsubscribe;\n    }\n  }, [subscribe, enableRealtime, user?.id]);\n\n  // Action wrappers\n  const markAsRead = useCallback(async (notificationId: string) => {\n    await markAsReadMutation.mutateAsync(notificationId);\n  }, [markAsReadMutation]);\n\n  const markAllAsRead = useCallback(async () => {\n    await markAllAsReadMutation.mutateAsync();\n  }, [markAllAsReadMutation]);\n\n  // Derived state\n  const isLoading = notificationsLoading || countLoading || preferencesLoading;\n  const isError = !!(notificationsError || realtimeError);\n  const error = notificationsError || realtimeError;\n  const notifications = notificationsData?.notifications || [];\n\n  return {\n    // Data\n    notifications,\n    unreadCount: unreadCount || 0,\n    preferences,\n    isLoading,\n    isError,\n    error,\n    \n    // Actions\n    markAsRead,\n    markAllAsRead,\n    refetch: refetchNotifications,\n    \n    // Real-time\n    subscribe,\n    isSubscribed,\n    \n    // Legacy compatibility\n    data: notifications\n  };\n};\n\n// Specialized hooks for different notification types\nexport const useTourNotifications = () => {\n  return useNotifications({\n    types: ['tour_created', 'tour_updated', 'tour_cancelled', 'collaboration_invite', 'collaboration_accepted', 'collaboration_declined'],\n    enableRealtime: true\n  });\n};\n\nexport const useTaskNotifications = () => {\n  return useNotifications({\n    types: ['task_assigned', 'task_due_soon', 'task_overdue', 'task_completed'],\n    enableRealtime: true\n  });\n};\n\nexport const useFlightNotifications = () => {\n  return useNotifications({\n    types: ['flight_delayed', 'flight_cancelled', 'flight_boarding'],\n    enableRealtime: true,\n    autoMarkAsRead: false // Flight notifications should require manual acknowledgment\n  });\n};\n\nexport const useEventNotifications = () => {\n  return useNotifications({\n    types: ['event_booking', 'event_cancelled'],\n    enableRealtime: true\n  });\n};\n\nexport const usePaymentNotifications = () => {\n  return useNotifications({\n    types: ['payment_received', 'payment_due'],\n    enableRealtime: true\n  });\n};\n\n// Hook for unread notifications only\nexport const useUnreadNotifications = () => {\n  return useNotifications({\n    unreadOnly: true,\n    enableRealtime: true,\n    limit: 20\n  });\n};\n\n// Hook for notification preferences\nexport const useNotificationPreferences = () => {\n  const { user } = useAuth();\n  const queryClient = useQueryClient();\n  const [uiPreferences, setUiPreferences] = useState<UIPreferences>(cloneDefaultPreferences());\n  const uiPreferencesRef = useRef(uiPreferences);\n\n  useEffect(() => {\n    uiPreferencesRef.current = uiPreferences;\n  }, [uiPreferences]);\n\n  // Get notification preferences\n  const {\n    data: serverPreferences,\n    isLoading: isLoadingPreferences\n  } = useQuery({\n    queryKey: ['notification-preferences', user?.id],\n    queryFn: async () => {\n      if (!user?.id) return null;\n      \n      if (typeof notificationService !== 'undefined' && notificationService.getNotificationPreferences) {\n        return notificationService.getNotificationPreferences(user.id);\n      }\n\n      const { data, error } = await supabase\n        .from('notification_preferences')\n        .select('*')\n        .eq('user_id', user.id)\n        .single();\n\n      if (error && error.code !== 'PGRST116') {\n        throw error;\n      }\n\n      return data as ServerNotificationPreferences | null;\n    },\n    enabled: !!user?.id\n  });\n\n  useEffect(() => {\n    if (user?.id !== undefined) {\n      setUiPreferences(prev => mapServerToUIPreferences(serverPreferences, prev));\n    }\n  }, [serverPreferences, user?.id]);\n\n  // Update notification preferences\n  const updatePreferencesMutation = useMutation({\n    mutationFn: async (nextPreferences: UIPreferences) => {\n      if (!user?.id) throw new Error('User not authenticated');\n\n      const existingServer = queryClient.getQueryData<ServerNotificationPreferences | null>([\n        'notification-preferences',\n        user.id\n      ]) ?? serverPreferences;\n\n      if (typeof notificationService !== 'undefined' && notificationService.updateNotificationPreferences) {\n        const updatedServer = await notificationService.updateNotificationPreferences(\n          user.id,\n          mapUIToServerPreferences(nextPreferences, existingServer)\n        );\n        return { ui: nextPreferences, server: updatedServer };\n      }\n\n      const { data, error } = await supabase\n        .from('notification_preferences')\n        .upsert({\n          user_id: user.id,\n          ...mapUIToServerPreferences(nextPreferences, existingServer),\n          updated_at: new Date().toISOString()\n        })\n        .select()\n        .single();\n\n      if (error) throw error;\n      return { ui: nextPreferences, server: data as ServerNotificationPreferences };\n    },\n    onMutate: async (nextPreferences) => {\n      await queryClient.cancelQueries({ queryKey: ['notification-preferences', user?.id] });\n      const previous = uiPreferencesRef.current;\n      setUiPreferences(nextPreferences);\n      return { previous };\n    },\n    onError: (_error, _nextPreferences, context) => {\n      if (context?.previous) {\n        setUiPreferences(context.previous);\n      }\n    },\n    onSuccess: ({ ui, server }) => {\n      setUiPreferences(mapServerToUIPreferences(server, ui));\n      queryClient.setQueryData([\n        'notification-preferences',\n        user?.id\n      ], server);\n    },\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: ['notification-preferences', user?.id] });\n    }\n  });\n\n  const savePreferences = useCallback(async (\n    next: UIPreferences | ((current: UIPreferences) => UIPreferences)\n  ) => {\n    const resolved = typeof next === 'function' ? next(uiPreferencesRef.current) : next;\n    await updatePreferencesMutation.mutateAsync(resolved);\n  }, [updatePreferencesMutation]);\n\n  const updatePreferences = useCallback(async (updates: Partial<UIPreferences>) => {\n    await savePreferences(current => mergeUIPreferences(current, updates));\n  }, [savePreferences]);\n\n  return {\n    preferences: uiPreferences,\n    updatePreferences,\n    savePreferences,\n    isLoading: isLoadingPreferences,\n    isUpdating: updatePreferencesMutation.isPending\n  };\n};\n"}, {"path": "src/hooks/usePaymentGateway.ts", "content": "import { useState, useEffect, useCallback } from 'react';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { stripePaymentService } from '@/services/stripeService';\nimport { flexPayService, PaymentGatewayConfig } from '@/services/paymentService';\nimport { Invoice } from '@/types/invoice';\nimport { toast } from 'sonner';\n\nexport interface PaymentLink {\n  id: string;\n  invoiceId: string;\n  paymentLinkId: string;\n  url: string;\n  status: 'active' | 'used' | 'expired' | 'cancelled';\n  expiresAt: string;\n  createdAt: string;\n}\n\nexport interface PaymentStatus {\n  status: 'pending' | 'processing' | 'completed' | 'failed' | 'cancelled' | 'refunded';\n  amount: number;\n  paymentDate?: string;\n  paymentMethod?: string;\n  gatewayTransactionId?: string;\n}\n\nexport interface PaymentHistoryEntry {\n  id: string;\n  amount: number;\n  status: string;\n  paymentDate: string;\n  paymentMethod: string;\n  gatewayTransactionId?: string;\n}\n\nexport const usePaymentGateway = () => {\n  const { user } = useAuth();\n  const [gateways, setGateways] = useState<PaymentGatewayConfig[]>([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  // Load gateway configurations\n  const loadGateways = useCallback(async () => {\n    if (!user) return;\n\n    try {\n      setLoading(true);\n      setError(null);\n\n      const gatewayConfigs = await flexPayService.getGatewaySettings(user.id);\n      setGateways(gatewayConfigs);\n\n      // Initialize FlexPay with user's settings\n      await flexPayService.initializeGateways(user.id);\n    } catch (err) {\n      console.error('Failed to load gateways:', err);\n      setError('Failed to load payment gateways');\n    } finally {\n      setLoading(false);\n    }\n  }, [user]);\n\n  useEffect(() => {\n    if (user) {\n      loadGateways();\n    }\n  }, [loadGateways, user]);\n\n  const createPaymentLink = async (invoice: Invoice): Promise<string | null> => {\n    if (!user) {\n      toast.error('Please log in to create payment links');\n      return null;\n    }\n\n    try {\n      setLoading(true);\n      \n      // Initialize Stripe if not already done\n      if (!stripePaymentService.isInitialized()) {\n        await stripePaymentService.initializeFromEnv();\n      }\n\n      const response = await stripePaymentService.createPaymentLink(invoice);\n      \n      toast.success('Payment link created successfully!');\n      return response.url;\n    } catch (err) {\n      console.error('Failed to create payment link:', err);\n      toast.error('Failed to create payment link');\n      return null;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const getPaymentLink = async (invoiceId: string): Promise<PaymentLink | null> => {\n    try {\n      const link = await stripePaymentService.getPaymentLink(invoiceId);\n      return link ? {\n        id: '',\n        invoiceId,\n        paymentLinkId: '',\n        url: link.url,\n        status: link.status as any,\n        expiresAt: '',\n        createdAt: ''\n      } : null;\n    } catch (err) {\n      console.error('Failed to get payment link:', err);\n      return null;\n    }\n  };\n\n  const getPaymentStatus = async (invoiceId: string): Promise<PaymentStatus | null> => {\n    try {\n      const status = await stripePaymentService.getPaymentStatus(invoiceId);\n      return status ? {\n        status: status.status as any,\n        amount: status.amount,\n        paymentDate: status.paymentDate,\n        paymentMethod: status.paymentMethod\n      } : null;\n    } catch (err) {\n      console.error('Failed to get payment status:', err);\n      return null;\n    }\n  };\n\n  const getPaymentHistory = async (invoiceId: string): Promise<PaymentHistoryEntry[]> => {\n    try {\n      const history = await stripePaymentService.getPaymentHistory(invoiceId);\n      return history;\n    } catch (err) {\n      console.error('Failed to get payment history:', err);\n      return [];\n    }\n  };\n\n  const cancelPaymentLink = async (invoiceId: string): Promise<boolean> => {\n    try {\n      await stripePaymentService.cancelPaymentLink(invoiceId);\n      toast.success('Payment link cancelled successfully');\n      return true;\n    } catch (err) {\n      console.error('Failed to cancel payment link:', err);\n      toast.error('Failed to cancel payment link');\n      return false;\n    }\n  };\n\n  const updateGatewaySettings = async (\n    gatewayName: string,\n    config: Partial<PaymentGatewayConfig>\n  ): Promise<boolean> => {\n    if (!user) {\n      toast.error('Please log in to update gateway settings');\n      return false;\n    }\n\n    try {\n      setLoading(true);\n      \n      await flexPayService.updateGatewaySettings(user.id, gatewayName as any, config);\n      \n      // Reload gateways to reflect changes\n      await loadGateways();\n      \n      toast.success(`${gatewayName} settings updated successfully`);\n      return true;\n    } catch (err) {\n      console.error('Failed to update gateway settings:', err);\n      toast.error('Failed to update gateway settings');\n      return false;\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const getDefaultGateway = (): PaymentGatewayConfig | null => {\n    const defaultGateway = gateways.find(g => g.isDefault && g.isEnabled);\n    return defaultGateway || null;\n  };\n\n  const getEnabledGateways = (): PaymentGatewayConfig[] => {\n    return gateways.filter(g => g.isEnabled);\n  };\n\n  const isGatewayConfigured = (gatewayName: string): boolean => {\n    const gateway = gateways.find(g => g.gatewayName === gatewayName);\n    if (!gateway || !gateway.isEnabled) return false;\n    \n    // Check if required credentials are present\n    const hasCredentials = Object.keys(gateway.credentials || {}).length > 0;\n    return hasCredentials;\n  };\n\n  return {\n    gateways,\n    loading,\n    error,\n    createPaymentLink,\n    getPaymentLink,\n    getPaymentStatus,\n    getPaymentHistory,\n    cancelPaymentLink,\n    updateGatewaySettings,\n    getDefaultGateway,\n    getEnabledGateways,\n    isGatewayConfigured,\n    refreshGateways: loadGateways\n  };\n};\n"}, {"path": "src/hooks/useVouches.ts", "content": "import { useCallback, useEffect, useRef, useState } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { Vouch, VouchWithProfiles, VouchFormData, VouchStats, UserSearchResult } from '@/types/vouch';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { useToast } from '@/hooks/use-toast';\n\nexport const useVouches = () => {\n  const { user } = useAuth();\n  const { toast } = useToast();\n  const toastRef = useRef(toast);\n  useEffect(() => {\n    toastRef.current = toast;\n  }, [toast]);\n  const [loading, setLoading] = useState(false);\n  const [vouches, setVouches] = useState<VouchWithProfiles[]>([]);\n  const [stats, setStats] = useState<VouchStats | null>(null);\n\n  // Fetch vouches for current user\n  const fetchVouches = useCallback(async () => {\n    if (!user?.id) return;\n\n    setLoading(true);\n    try {\n      const { data, error } = await supabase\n        .from('vouches')\n        .select(`\n          *,\n          voucher_profile:voucher_id(id, name, stage_name, avatar_url),\n          vouchee_profile:vouchee_id(id, name, stage_name, avatar_url)\n        `)\n        .or(`voucher_id.eq.${user.id},vouchee_id.eq.${user.id}`)\n        .order('created_at', { ascending: false });\n\n      if (error) throw error;\n      setVouches(data || []);\n    } catch (error) {\n      console.error('Error fetching vouches:', error);\n      toastRef.current({\n        title: \"Error\",\n        description: \"Failed to load vouches\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setLoading(false);\n    }\n  }, [user?.id]);\n\n  // Fetch vouch statistics\n  const fetchStats = useCallback(async () => {\n    if (!user?.id) return;\n\n    try {\n      const { data, error } = await supabase\n        .rpc('get_vouch_stats', { user_id_param: user.id });\n\n      if (error) throw error;\n      setStats(data?.[0] || null);\n    } catch (error) {\n      console.error('Error fetching vouch stats:', error);\n    }\n  }, [user?.id]);\n\n  // Search for users to vouch for\n  const searchUsers = async (query: string): Promise<UserSearchResult[]> => {\n    if (!query.trim() || !user?.id) return [];\n\n    try {\n      const { data, error } = await supabase\n        .from('profiles')\n        .select(`\n          id,\n          name,\n          stage_name,\n          avatar_url,\n          user_roles!inner(role)\n        `)\n        .neq('id', user.id) // Exclude current user\n        .or(`name.ilike.%${query}%,stage_name.ilike.%${query}%`)\n        .limit(10);\n\n      if (error) throw error;\n\n      return (data || []).map(profile => ({\n        id: profile.id,\n        name: profile.name || '',\n        stage_name: profile.stage_name,\n        avatar_url: profile.avatar_url,\n        roles: profile.user_roles.map((r: any) => r.role)\n      }));\n    } catch (error) {\n      console.error('Error searching users:', error);\n      return [];\n    }\n  };\n\n  // Check if vouch already exists between two users\n  const checkExistingVouch = async (voucheeId: string): Promise<Vouch | null> => {\n    if (!user?.id) return null;\n\n    try {\n      const { data, error } = await supabase\n        .rpc('get_existing_vouch', { \n          giver_id: user.id, \n          receiver_id: voucheeId \n        });\n\n      if (error) throw error;\n      return data?.[0] || null;\n    } catch (error) {\n      console.error('Error checking existing vouch:', error);\n      return null;\n    }\n  };\n\n  // Create a new vouch\n  const createVouch = async (formData: VouchFormData) => {\n    if (!user?.id) throw new Error('User not authenticated');\n\n    try {\n      // Check if vouch already exists\n      const existing = await checkExistingVouch(formData.vouchee_id);\n      if (existing) {\n        throw new Error('You have already vouched for this person. You can edit your existing vouch instead.');\n      }\n\n      const { data, error } = await supabase\n        .from('vouches')\n        .insert({\n          voucher_id: user.id,\n          vouchee_id: formData.vouchee_id,\n          message: formData.message,\n          rating: formData.rating\n        })\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      toastRef.current({\n        title: \"Vouch Created\",\n        description: \"Your vouch has been successfully submitted.\",\n      });\n\n      await fetchVouches(); // Refresh the list\n      return data;\n    } catch (error: any) {\n      console.error('Error creating vouch:', error);\n      \n      // Handle specific database constraint errors\n      if (error.code === '23505') {\n        throw new Error('You have already vouched for this person. Check your vouch history to edit your existing vouch.');\n      }\n      \n      throw error;\n    }\n  };\n\n  // Update an existing vouch\n  const updateVouch = async (vouchId: string, formData: Partial<VouchFormData>) => {\n    if (!user?.id) throw new Error('User not authenticated');\n\n    try {\n      const { data, error } = await supabase\n        .from('vouches')\n        .update({\n          message: formData.message,\n          rating: formData.rating\n        })\n        .eq('id', vouchId)\n        .eq('voucher_id', user.id) // Ensure user owns this vouch\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      toastRef.current({\n        title: \"Vouch Updated\",\n        description: \"Your vouch has been successfully updated.\",\n      });\n\n      await fetchVouches(); // Refresh the list\n      return data;\n    } catch (error) {\n      console.error('Error updating vouch:', error);\n      throw error;\n    }\n  };\n\n  // Delete a vouch\n  const deleteVouch = async (vouchId: string) => {\n    if (!user?.id) throw new Error('User not authenticated');\n\n    try {\n      const { error } = await supabase\n        .from('vouches')\n        .delete()\n        .eq('id', vouchId)\n        .eq('voucher_id', user.id); // Ensure user owns this vouch\n\n      if (error) throw error;\n\n      toastRef.current({\n        title: \"Vouch Deleted\",\n        description: \"Your vouch has been successfully deleted.\",\n      });\n\n      await fetchVouches(); // Refresh the list\n    } catch (error) {\n      console.error('Error deleting vouch:', error);\n      throw error;\n    }\n  };\n\n  // Get vouches received by current user\n  const getReceivedVouches = () => {\n    return vouches.filter(vouch => vouch.vouchee_id === user?.id);\n  };\n\n  // Get vouches given by current user\n  const getGivenVouches = () => {\n    return vouches.filter(vouch => vouch.voucher_id === user?.id);\n  };\n\n  useEffect(() => {\n    if (user?.id) {\n      fetchVouches();\n      fetchStats();\n    }\n  }, [fetchStats, fetchVouches, user?.id]);\n\n  return {\n    loading,\n    vouches,\n    stats,\n    searchUsers,\n    checkExistingVouch,\n    createVouch,\n    updateVouch,\n    deleteVouch,\n    fetchVouches,\n    getReceivedVouches,\n    getGivenVouches\n  };\n};\n"}, {"path": "src/hooks/useWaitlist.ts", "content": "\nimport { useState, useEffect, useCallback } from 'react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { WaitlistEntry } from '@/types/waitlist';\nimport { useToast } from '@/hooks/use-toast';\n\nexport const useWaitlist = (eventId: string) => {\n  const { toast } = useToast();\n  const [waitlistEntries, setWaitlistEntries] = useState<WaitlistEntry[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [waitlistCount, setWaitlistCount] = useState(0);\n\n  const fetchWaitlist = useCallback(async () => {\n    try {\n      const { data, error } = await supabase\n        .from('event_waitlists')\n        .select('*')\n        .eq('event_id', eventId)\n        .order('position', { ascending: true });\n\n      if (error) throw error;\n\n      setWaitlistEntries(data || []);\n      setWaitlistCount(data?.length || 0);\n    } catch (error: any) {\n      toast({\n        title: \"Error\",\n        description: \"Failed to load waitlist data\",\n        variant: \"destructive\",\n      });\n    } finally {\n      setLoading(false);\n    }\n  }, [eventId, toast]);\n\n  useEffect(() => {\n    if (eventId) {\n      fetchWaitlist();\n    }\n  }, [eventId, fetchWaitlist]);\n\n  return {\n    waitlistEntries,\n    waitlistCount,\n    loading,\n    refetchWaitlist: fetchWaitlist\n  };\n};\n"}, {"path": "src/pages/Applications.tsx", "content": "\nimport React, { useState, useMemo } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { useToast } from '@/hooks/use-toast';\nimport { useTheme } from '@/contexts/ThemeContext';\nimport { useApplications } from '@/hooks/useApplications';\nimport { useEvents } from '@/hooks/data/useEvents';\nimport { useSpotAssignment } from '@/hooks/useSpotAssignment';\nimport ApplicationStats from '@/components/admin/ApplicationStats';\nimport ApplicationList from '@/components/admin/ApplicationList';\nimport ApplicationFilters from '@/components/admin/ApplicationFilters';\nimport BulkApplicationActions from '@/components/admin/BulkApplicationActions';\nimport SpotAssignmentManager from '@/components/events/SpotAssignmentManager';\nimport LoadingSpinner from '@/components/LoadingSpinner';\nimport { cn } from '@/lib/utils';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';\n\nconst Applications = () => {\n  const { toast } = useToast();\n  const { theme } = useTheme();\n  const navigate = useNavigate();\n  \n  // Fetch real data\n  const { applications, isLoading, error, updateApplication, bulkUpdateApplications } = useApplications();\n  const { userEvents } = useEvents();\n  \n  // Debug logging\n  console.log('Applications page - isLoading:', isLoading);\n  console.log('Applications page - error:', error);\n  console.log('Applications page - applications:', applications?.length || 0);\n  \n  const [selectedApplications, setSelectedApplications] = useState<string[]>([]);\n  \n  // Filter states\n  const [searchTerm, setSearchTerm] = useState('');\n  const [eventFilter, setEventFilter] = useState('all');\n  const [sortBy, setSortBy] = useState('applied_at_desc');\n  const [statusFilter, setStatusFilter] = useState('all');\n  const [spotTypeFilter, setSpotTypeFilter] = useState('all');\n  const [confirmationFilter, setConfirmationFilter] = useState('all');\n  const [dateRange, setDateRange] = useState<{ from: Date | undefined; to: Date | undefined }>({\n    from: undefined,\n    to: undefined,\n  });\n  \n  // Spot assignment dialog\n  const [selectedApplicationForSpot, setSelectedApplicationForSpot] = useState<string | null>(null);\n  const { assignSpotById } = useSpotAssignment();\n\n  // Transform applications to match the expected format\n  const transformedApplications = useMemo(() => {\n    return applications.map(app => {\n      // Check if comedian has an assigned spot for this event\n      const assignedSpot = app.event?.event_spots?.find(\n        spot => spot.comedian_id === app.comedian_id\n      );\n      \n      return {\n        id: app.id,\n        comedian_id: app.comedian_id,\n        comedian_name: app.comedian?.name || 'Unknown',\n        comedian_avatar: app.comedian?.avatar_url,\n        comedian_experience: app.comedian?.years_experience ? `${app.comedian.years_experience} years` : undefined,\n        comedian_rating: undefined, // Not available in current schema\n        event_id: app.event_id,\n        event_title: app.event?.title || 'Unknown Event',\n        event_venue: app.event?.venue || 'Unknown Venue',\n        event_date: app.event?.event_date || '',\n        applied_at: app.applied_at,\n        status: app.status,\n        message: app.message,\n        spot_type: app.spot_type || 'Guest',\n        availability_confirmed: app.availability_confirmed,\n        requirements_acknowledged: app.requirements_acknowledged,\n        // Spot assignment info\n        spot_assigned: !!assignedSpot,\n        spot_name: assignedSpot?.spot_name,\n        confirmation_status: assignedSpot?.confirmation_status,\n        confirmation_deadline: assignedSpot?.confirmation_deadline,\n        confirmed_at: assignedSpot?.confirmed_at,\n        declined_at: assignedSpot?.declined_at,\n      };\n    });\n  }, [applications]);\n\n  // Filter and sort applications\n  const filteredApplications = useMemo(() => {\n    return transformedApplications\n      .filter(app => {\n        const matchesSearch = app.comedian_name.toLowerCase().includes(searchTerm.toLowerCase()) ||\n                             app.event_title.toLowerCase().includes(searchTerm.toLowerCase());\n        const matchesEvent = eventFilter === 'all' || app.event_id === eventFilter;\n        const matchesStatus = statusFilter === 'all' || app.status === statusFilter;\n        const matchesSpotType = spotTypeFilter === 'all' || app.spot_type === spotTypeFilter;\n        \n        // Confirmation status filter\n        let matchesConfirmation = true;\n        if (confirmationFilter !== 'all') {\n          if (confirmationFilter === 'assigned') matchesConfirmation = app.spot_assigned;\n          else if (confirmationFilter === 'unassigned') matchesConfirmation = !app.spot_assigned;\n          else if (confirmationFilter === 'confirmed') matchesConfirmation = app.confirmation_status === 'confirmed';\n          else if (confirmationFilter === 'pending') matchesConfirmation = app.spot_assigned && app.confirmation_status === 'pending';\n          else if (confirmationFilter === 'declined') matchesConfirmation = app.confirmation_status === 'declined';\n          else if (confirmationFilter === 'overdue') {\n            matchesConfirmation = app.spot_assigned && \n              app.confirmation_status === 'pending' && \n              app.confirmation_deadline && \n              new Date(app.confirmation_deadline) < new Date();\n          }\n        }\n        \n        // Date range filter\n        let matchesDateRange = true;\n        if (dateRange.from || dateRange.to) {\n          const appliedDate = new Date(app.applied_at);\n          if (dateRange.from && appliedDate < dateRange.from) matchesDateRange = false;\n          if (dateRange.to && appliedDate > dateRange.to) matchesDateRange = false;\n        }\n        \n        return matchesSearch && matchesEvent && matchesStatus && matchesSpotType && matchesConfirmation && matchesDateRange;\n      })\n      .sort((a, b) => {\n        switch (sortBy) {\n          case 'applied_at_desc':\n            return new Date(b.applied_at).getTime() - new Date(a.applied_at).getTime();\n          case 'applied_at_asc':\n            return new Date(a.applied_at).getTime() - new Date(b.applied_at).getTime();\n          case 'comedian_name':\n            return a.comedian_name.localeCompare(b.comedian_name);\n          case 'event_date':\n            return new Date(a.event_date).getTime() - new Date(b.event_date).getTime();\n          default:\n            return 0;\n        }\n      });\n  }, [confirmationFilter, dateRange, eventFilter, searchTerm, sortBy, spotTypeFilter, statusFilter, transformedApplications]);\n\n  // Calculate stats\n  const stats = useMemo(() => ({\n    mc: transformedApplications.filter(app => app.spot_type === 'MC').length,\n    feature: transformedApplications.filter(app => app.spot_type === 'Feature').length,\n    headliner: transformedApplications.filter(app => app.spot_type === 'Headliner').length,\n    guest: transformedApplications.filter(app => app.spot_type === 'Guest').length,\n    pending: transformedApplications.filter(app => app.status === 'pending').length,\n    accepted: transformedApplications.filter(app => app.status === 'accepted').length,\n    rejected: transformedApplications.filter(app => app.status === 'rejected').length,\n    withdrawn: transformedApplications.filter(app => app.status === 'withdrawn').length,\n    assigned: transformedApplications.filter(app => app.spot_assigned).length,\n    confirmed: transformedApplications.filter(app => app.confirmation_status === 'confirmed').length,\n    overdue: transformedApplications.filter(app => \n      app.spot_assigned && \n      app.confirmation_status === 'pending' && \n      app.confirmation_deadline && \n      new Date(app.confirmation_deadline) < new Date()\n    ).length,\n  }), [transformedApplications]);\n\n  const handleSelectApplication = (applicationId: string, selected: boolean) => {\n    setSelectedApplications(prev => \n      selected \n        ? [...prev, applicationId]\n        : prev.filter(id => id !== applicationId)\n    );\n  };\n\n  const handleBulkApprove = async (applicationIds: string[]) => {\n    bulkUpdateApplications({ applicationIds, status: 'accepted' });\n    setSelectedApplications([]);\n  };\n\n  const handleBulkHide = async (applicationIds: string[]) => {\n    bulkUpdateApplications({ applicationIds, status: 'rejected' });\n    setSelectedApplications([]);\n  };\n\n  const handleApprove = (applicationId: string) => {\n    updateApplication({ applicationId, status: 'accepted' });\n    toast({\n      title: \"Application Accepted\",\n      description: \"The comedian has been notified of their acceptance.\"\n    });\n  };\n\n  const handleHide = (applicationId: string) => {\n    updateApplication({ applicationId, status: 'rejected' });\n    toast({\n      title: \"Application Rejected\",\n      description: \"The application has been rejected.\"\n    });\n  };\n  \n  const handleAssignSpot = (applicationId: string) => {\n    setSelectedApplicationForSpot(applicationId);\n  };\n  \n  const handleSpotAssigned = async (spotId: string) => {\n    if (selectedApplicationForSpot) {\n      const application = transformedApplications.find(app => app.id === selectedApplicationForSpot);\n      if (application) {\n        try {\n          await assignSpotById(spotId, application.comedian_id);\n          toast({\n            title: \"Spot Assigned\",\n            description: `${application.comedian_name} has been assigned to the spot and notified.`\n          });\n        } catch (error) {\n          toast({\n            title: \"Error\",\n            description: \"Failed to assign spot. Please try again.\",\n            variant: \"destructive\"\n          });\n        }\n      }\n      setSelectedApplicationForSpot(null);\n    }\n  };\n\n  const handleViewProfile = (comedianId: string) => {\n    // Find the application and use the comedian's profile_slug\n    const application = applications.find(app => app.comedian_id === comedianId);\n    if (application?.comedian?.profile_slug) {\n      navigate(`/comedian/${application.comedian.profile_slug}`);\n    } else {\n      // Fallback: create slug from comedian name\n      const transformedApp = transformedApplications.find(app => app.comedian_id === comedianId);\n      if (transformedApp) {\n        const fallbackSlug = transformedApp.comedian_name.toLowerCase().replace(/\\s+/g, '-');\n        navigate(`/comedian/${fallbackSlug}`);\n      }\n    }\n  };\n\n  const handleClearFilters = () => {\n    setSearchTerm('');\n    setEventFilter('all');\n    setSortBy('applied_at_desc');\n    setStatusFilter('all');\n    setSpotTypeFilter('all');\n    setConfirmationFilter('all');\n    setDateRange({ from: undefined, to: undefined });\n  };\n\n  const getBackgroundStyles = () => {\n    if (theme === 'pleasure') {\n      return 'bg-gradient-to-br from-purple-700 via-purple-800 to-purple-900';\n    }\n    return 'bg-gradient-to-br from-gray-800 via-gray-900 to-red-900';\n  };\n\n  // Transform events for the filter\n  const eventOptions = useMemo(() => {\n    return userEvents.map(event => ({\n      id: event.id,\n      title: event.title\n    }));\n  }, [userEvents]);\n\n  if (isLoading) {\n    return (\n      <div className={cn(\"min-h-screen flex items-center justify-center\", getBackgroundStyles())}>\n        <LoadingSpinner size=\"lg\" />\n      </div>\n    );\n  }\n  \n  if (error) {\n    return (\n      <div className={cn(\"min-h-screen flex items-center justify-center\", getBackgroundStyles())}>\n        <div className=\"text-center text-white\">\n          <h2 className=\"text-xl font-bold mb-2\">Error Loading Applications</h2>\n          <p className=\"text-sm opacity-80\">{error.message || 'Failed to load applications'}</p>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={cn(\"min-h-screen\", getBackgroundStyles())}>\n      <div className=\"container mx-auto px-3 sm:px-4 py-4 sm:py-8\">\n        <div className=\"mb-6 sm:mb-8\">\n          <h1 className=\"text-2xl sm:text-3xl font-bold text-white mb-2\">Applications Management</h1>\n          <p className={cn(\n            theme === 'pleasure' ? 'text-purple-100' : 'text-gray-300'\n          )}>\n            Review and manage comedian applications for your events\n          </p>\n        </div>\n\n        <ApplicationStats stats={stats} />\n        \n        <ApplicationFilters\n          searchTerm={searchTerm}\n          setSearchTerm={setSearchTerm}\n          eventFilter={eventFilter}\n          setEventFilter={setEventFilter}\n          sortBy={sortBy}\n          setSortBy={setSortBy}\n          statusFilter={statusFilter}\n          setStatusFilter={setStatusFilter}\n          spotTypeFilter={spotTypeFilter}\n          setSpotTypeFilter={setSpotTypeFilter}\n          confirmationFilter={confirmationFilter}\n          setConfirmationFilter={setConfirmationFilter}\n          dateRange={dateRange}\n          setDateRange={setDateRange}\n          events={eventOptions}\n          onClearFilters={handleClearFilters}\n        />\n\n        <BulkApplicationActions\n          selectedApplications={selectedApplications}\n          onBulkApprove={handleBulkApprove}\n          onBulkHide={handleBulkHide}\n          onClearSelection={() => setSelectedApplications([])}\n        />\n\n        <ApplicationList\n          applications={filteredApplications}\n          selectedApplications={selectedApplications}\n          onSelectApplication={handleSelectApplication}\n          onApprove={handleApprove}\n          onHide={handleHide}\n          onViewProfile={handleViewProfile}\n          onAssignSpot={handleAssignSpot}\n        />\n        \n        {/* Spot Assignment Dialog */}\n        {selectedApplicationForSpot && (\n          <Dialog open={!!selectedApplicationForSpot} onOpenChange={() => setSelectedApplicationForSpot(null)}>\n            <DialogContent className=\"max-w-4xl max-h-[90vh] overflow-y-auto\">\n              <DialogHeader>\n                <DialogTitle>Assign Spot</DialogTitle>\n              </DialogHeader>\n              {(() => {\n                const application = transformedApplications.find(app => app.id === selectedApplicationForSpot);\n                if (!application) return null;\n                \n                return (\n                  <SpotAssignmentManager\n                    eventId={application.event_id}\n                    onSpotAssigned={handleSpotAssigned}\n                    preselectedComedianId={application.comedian_id}\n                  />\n                );\n              })()}\n            </DialogContent>\n          </Dialog>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default Applications;\n"}, {"path": "src/pages/AuthCallback.tsx", "content": "import React, { useCallback, useEffect, useState } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { supabase } from '@/integrations/supabase/client';\nimport { useToast } from '@/hooks/use-toast';\n\nconst AuthCallback = () => {\n  const [isLoading, setIsLoading] = useState(true);\n  const [status, setStatus] = useState('Processing authentication...');\n  const navigate = useNavigate();\n  const { toast } = useToast();\n\n  // Helper function to generate profile slug\n  const generateProfileSlug = (name: string): string => {\n    return name\n      .toLowerCase()\n      .replace(/[^a-z0-9\\s-]/g, '')\n      .replace(/\\s+/g, '-')\n      .replace(/-+/g, '-')\n      .trim();\n  };\n\n  // Helper function to ensure unique profile slug\n  const ensureUniqueProfileSlug = useCallback(async (baseSlug: string, userId: string): Promise<string> => {\n    let slug = baseSlug;\n    let counter = 1;\n    \n    while (true) {\n      const { data, error } = await supabase\n        .from('profiles')\n        .select('id')\n        .eq('profile_slug', slug)\n        .neq('id', userId)\n        .single();\n      \n      if (error && error.code === 'PGRST116') {\n        // No existing profile with this slug, we can use it\n        return slug;\n      }\n      \n      if (error) {\n        console.error('Error checking profile slug:', error);\n        return slug; // Return the slug anyway\n      }\n      \n      // Slug exists, try with counter\n      slug = `${baseSlug}-${counter}`;\n      counter++;\n    }\n  }, []);\n\n  // Retry mechanism for profile creation\n  const retryOperation = useCallback(async (operation: () => Promise<any>, maxRetries = 3, delay = 1000) => {\n    for (let i = 0; i < maxRetries; i++) {\n      try {\n        const result = await operation();\n        return result;\n      } catch (error) {\n        if (i === maxRetries - 1) throw error;\n        await new Promise(resolve => setTimeout(resolve, delay * (i + 1)));\n      }\n    }\n  }, []);\n\n  // Enhanced profile creation with error handling\n  const createProfileWithRetry = useCallback(async (user: any) => {\n    const displayName = user.user_metadata?.full_name || \n                       user.user_metadata?.name || \n                       user.email?.split('@')[0] || \n                       'User';\n    \n    const baseSlug = generateProfileSlug(displayName);\n    const uniqueSlug = await ensureUniqueProfileSlug(baseSlug, user.id);\n    \n    const profileData = {\n      id: user.id,\n      email: user.email,\n      name: displayName,\n      avatar_url: user.user_metadata?.avatar_url || user.user_metadata?.picture || null,\n      profile_slug: uniqueSlug,\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString()\n    };\n\n    return await retryOperation(async () => {\n      const { data, error } = await supabase\n        .from('profiles')\n        .insert(profileData)\n        .select()\n        .single();\n      \n      if (error) {\n        throw error;\n      }\n      \n      return data;\n    });\n  }, [ensureUniqueProfileSlug, retryOperation]);\n\n  // Enhanced role creation with error handling\n  const createRoleWithRetry = useCallback(async (userId: string) => {\n    return await retryOperation(async () => {\n      const { data, error } = await supabase\n        .from('user_roles')\n        .insert({\n          user_id: userId,\n          role: 'member'\n        })\n        .select()\n        .single();\n      \n      if (error && !error.message.includes('duplicate key')) {\n        throw error;\n      }\n      \n      return data;\n    });\n  }, [retryOperation]);\n\n  useEffect(() => {\n    const handleAuthCallback = async () => {\n      try {\n        setStatus('Processing OAuth callback...');\n        \n        // Parse the hash fragment to handle the OAuth response\n        const hashParams = new URLSearchParams(window.location.hash.substring(1));\n        const error = hashParams.get('error');\n        const errorDescription = hashParams.get('error_description');\n        \n        if (error) {\n          console.error('OAuth error in URL:', error, errorDescription);\n          toast({\n            title: \"Authentication Failed\",\n            description: errorDescription || error,\n            variant: \"destructive\",\n          });\n          navigate('/auth');\n          return;\n        }\n        \n        setStatus('Retrieving session...');\n        \n        // Handle the auth callback\n        const { data, error: sessionError } = await supabase.auth.getSession();\n        \n        if (sessionError) {\n          console.error('Session error:', sessionError);\n          toast({\n            title: \"Authentication Error\",\n            description: sessionError.message,\n            variant: \"destructive\",\n          });\n          navigate('/auth');\n          return;\n        }\n\n        if (!data.session) {\n          console.error('No session found');\n          toast({\n            title: \"Authentication Failed\",\n            description: \"No session was created. Please try again.\",\n            variant: \"destructive\",\n          });\n          navigate('/auth');\n          return;\n        }\n\n        const user = data.session.user;\n        console.log('User authenticated:', user.id, user.email);\n        \n        // Wait for potential database triggers to fire\n        setStatus('Setting up your account...');\n        await new Promise(resolve => setTimeout(resolve, 2000));\n        \n        // Check if profile was created by trigger\n        setStatus('Checking profile status...');\n        const { data: profile, error: profileError } = await supabase\n          .from('profiles')\n          .select('*')\n          .eq('id', user.id)\n          .single();\n        \n        if (profileError && profileError.code !== 'PGRST116') {\n          console.error('Error checking profile:', profileError);\n          // Don't fail here, continue with manual creation\n        }\n        \n        if (!profile) {\n          setStatus('Creating your profile...');\n          console.log('Profile not found, creating manually');\n          \n          try {\n            const createdProfile = await createProfileWithRetry(user);\n            console.log('Profile created successfully:', createdProfile);\n          } catch (createError) {\n            console.error('Failed to create profile:', createError);\n            toast({\n              title: \"Profile Creation Failed\",\n              description: \"Unable to create your profile. Please try again or contact support.\",\n              variant: \"destructive\",\n            });\n            navigate('/auth');\n            return;\n          }\n        } else {\n          console.log('Profile exists:', profile);\n        }\n        \n        // Check if user has roles\n        setStatus('Setting up permissions...');\n        const { data: roles, error: rolesError } = await supabase\n          .from('user_roles')\n          .select('*')\n          .eq('user_id', user.id);\n        \n        if (rolesError) {\n          console.error('Error checking roles:', rolesError);\n          // Don't fail here, continue with role creation\n        }\n        \n        if (!roles || roles.length === 0) {\n          console.log('No roles found, creating default member role');\n          \n          try {\n            await createRoleWithRetry(user.id);\n            console.log('Default role created successfully');\n          } catch (roleError) {\n            console.error('Failed to create role:', roleError);\n            // Don't fail authentication for role creation failure\n          }\n        } else {\n          console.log('User has roles:', roles);\n        }\n        \n        setStatus('Completing setup...');\n        \n        toast({\n          title: \"Welcome!\",\n          description: \"Successfully signed in with Google.\",\n        });\n        \n        navigate('/dashboard');\n        \n      } catch (error: any) {\n        console.error('Auth callback exception:', error);\n        toast({\n          title: \"Authentication Error\",\n          description: error.message || \"An unexpected error occurred.\",\n          variant: \"destructive\",\n        });\n        navigate('/auth');\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    handleAuthCallback();\n  }, [createProfileWithRetry, createRoleWithRetry, navigate, toast]);\n\n  if (isLoading) {\n    return (\n      <div className=\"min-h-screen flex items-center justify-center bg-gradient-to-br from-indigo-900 via-purple-900 to-pink-900\">\n        <div className=\"text-center\">\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-white mx-auto mb-4\"></div>\n          <p className=\"text-white text-lg\">{status}</p>\n        </div>\n      </div>\n    );\n  }\n\n  return null;\n};\n\nexport default AuthCallback;\n"}, {"path": "src/pages/ComedianProfile.tsx", "content": "\nimport React from 'react';\nimport { useComedianProfile } from '@/hooks/useComedianProfile';\nimport { useQuery } from '@tanstack/react-query';\nimport { supabase } from '@/integrations/supabase/client';\nimport ComedianProfileLoader from '@/components/comedian-profile/ComedianProfileLoader';\nimport ComedianProfileError from '@/components/comedian-profile/ComedianProfileError';\nimport ComedianProfileLayout from '@/components/comedian-profile/ComedianProfileLayout';\nimport { SEOHead, generateComedianMetaTags, generatePersonSchema, generateBreadcrumbSchema } from '@/utils/seo';\n\nconst ComedianProfile = () => {\n  const { comedian, isLoading, error, slug } = useComedianProfile();\n  const comedianId = comedian?.id;\n\n  // Fetch upcoming shows for structured data\n  const { data: upcomingShows } = useQuery({\n    queryKey: ['comedian-upcoming-shows', comedianId],\n    queryFn: async () => {\n      const { data } = await supabase\n        .from('applications')\n        .select(`\n          event:events (\n            id,\n            title,\n            start_time,\n            end_time,\n            venue_name,\n            venue_address,\n            ticket_url\n        )\n      `)\n        .eq('profile_id', comedianId)\n        .eq('status', 'confirmed')\n        .gte('events.start_time', new Date().toISOString())\n        .order('events.start_time', { ascending: true })\n        .limit(10);\n      \n      return data?.map(app => app.event).filter(Boolean) || [];\n    },\n    enabled: !!comedianId\n  });\n\n  // Handle loading state\n  if (isLoading) {\n    return <ComedianProfileLoader />;\n  }\n\n  // Handle error state\n  if (error || !comedian) {\n    console.error('Error loading comedian:', error);\n    return <ComedianProfileError slug={slug} />;\n  }\n  \n  // Build social media object for structured data\n  const socialMedia: any = {};\n  if (comedian.twitter_url) socialMedia.twitter = comedian.twitter_url.replace('https://twitter.com/', '');\n  if (comedian.instagram_url) socialMedia.instagram = comedian.instagram_url.replace('https://instagram.com/', '');\n  if (comedian.facebook_url) socialMedia.facebook = comedian.facebook_url.replace('https://facebook.com/', '');\n  if (comedian.youtube_url) socialMedia.youtube = comedian.youtube_url.replace('https://youtube.com/', '');\n  if (comedian.tiktok_url) socialMedia.tiktok = comedian.tiktok_url.replace('https://tiktok.com/@', '');\n  \n  // Generate SEO meta tags\n  const metaTags = generateComedianMetaTags({\n    ...comedian,\n    profile_picture: comedian.avatar_url,\n    social_media: socialMedia\n  });\n  \n  // Generate structured data\n  const personSchema = generatePersonSchema({\n    ...comedian,\n    profile_picture: comedian.avatar_url,\n    social_media: socialMedia,\n    upcoming_shows: upcomingShows\n  });\n  const breadcrumbSchema = generateBreadcrumbSchema([\n    { name: 'Home', url: '/' },\n    { name: 'Comedians', url: '/comedians' },\n    { name: comedian.stage_name || comedian.name }\n  ]);\n  \n  return (\n    <>\n      <SEOHead\n        {...metaTags}\n        structuredData={[personSchema, breadcrumbSchema]}\n      />\n      <ComedianProfileLayout comedian={comedian} />\n    </>\n  );\n};\n\nexport default ComedianProfile;\n"}, {"path": "src/pages/ComedianProfileBySlug.tsx", "content": "\nimport React from 'react';\nimport { useParams } from 'react-router-dom';\nimport { useQuery } from '@tanstack/react-query';\nimport { supabase } from '@/integrations/supabase/client';\nimport ComedianProfileLoader from '@/components/comedian-profile/ComedianProfileLoader';\nimport ComedianProfileError from '@/components/comedian-profile/ComedianProfileError';\nimport ComedianProfileLayout from '@/components/comedian-profile/ComedianProfileLayout';\nimport { SEOHead, generateComedianMetaTags, generatePersonSchema, generateBreadcrumbSchema } from '@/utils/seo';\n\nconst ComedianProfileBySlug = () => {\n  const { slug } = useParams<{ slug: string }>();\n\n  const { data: comedian, isLoading, error } = useQuery({\n    queryKey: ['comedian-profile-by-slug', slug],\n    queryFn: async () => {\n      if (!slug) throw new Error('No comedian slug provided');\n      \n      // Query by profile_slug first\n      const { data: dbData, error: dbError } = await supabase\n        .from('profiles')\n        .select(`\n          id,\n          name,\n          stage_name,\n          bio,\n          location,\n          avatar_url,\n          is_verified,\n          email,\n          created_at,\n          phone,\n          website_url,\n          instagram_url,\n          twitter_url,\n          youtube_url,\n          facebook_url,\n          tiktok_url,\n          show_contact_in_epk,\n          custom_show_types,\n          profile_slug\n        `)\n        .eq('profile_slug', slug)\n        .single();\n      \n      if (dbData) {\n        return dbData;\n      }\n      \n      if (dbError && dbError.code !== 'PGRST116') {\n        throw dbError;\n      }\n      \n      // Fallback: try to find by name-based slug for backward compatibility\n      const name = slug.split('-').map(word => \n        word.charAt(0).toUpperCase() + word.slice(1)\n      ).join(' ');\n      \n      const { data: fallbackData, error: fallbackError } = await supabase\n        .from('profiles')\n        .select(`\n          id,\n          name,\n          stage_name,\n          bio,\n          location,\n          avatar_url,\n          is_verified,\n          email,\n          created_at,\n          phone,\n          website_url,\n          instagram_url,\n          twitter_url,\n          youtube_url,\n          facebook_url,\n          tiktok_url,\n          show_contact_in_epk,\n          custom_show_types,\n          profile_slug\n        `)\n        .or(`name.ilike.%${name}%,stage_name.ilike.%${name}%`)\n        .single();\n      \n      if (fallbackData) {\n        return fallbackData;\n      }\n      \n      // If no match found in database, return null to show error\n      \n      throw new Error(`Comedian not found: ${slug}`);\n    },\n    enabled: !!slug,\n  });\n\n  const comedianId = comedian?.id;\n\n  // Fetch upcoming shows for structured data\n  const { data: upcomingShows } = useQuery({\n    queryKey: ['comedian-upcoming-shows', comedianId],\n    queryFn: async () => {\n      const { data } = await supabase\n        .from('applications')\n        .select(`\n          event:events (\n            id,\n            title,\n            start_time,\n            end_time,\n            venue_name,\n            venue_address,\n            ticket_url\n          )\n        `)\n        .eq('profile_id', comedianId)\n        .eq('status', 'confirmed')\n        .gte('events.start_time', new Date().toISOString())\n        .order('events.start_time', { ascending: true })\n        .limit(10);\n      \n      return data?.map(app => app.event).filter(Boolean) || [];\n    },\n    enabled: !!comedianId\n  });\n\n  // Handle loading state\n  if (isLoading) {\n    return <ComedianProfileLoader />;\n  }\n\n  // Handle error state\n  if (error || !comedian) {\n    console.error('Error loading comedian:', error);\n    return <ComedianProfileError slug={slug} />;\n  }\n  \n  // Build social media object for structured data\n  const socialMedia: any = {};\n  if (comedian.twitter_url) socialMedia.twitter = comedian.twitter_url.replace('https://twitter.com/', '');\n  if (comedian.instagram_url) socialMedia.instagram = comedian.instagram_url.replace('https://instagram.com/', '');\n  if (comedian.facebook_url) socialMedia.facebook = comedian.facebook_url.replace('https://facebook.com/', '');\n  if (comedian.youtube_url) socialMedia.youtube = comedian.youtube_url.replace('https://youtube.com/', '');\n  if (comedian.tiktok_url) socialMedia.tiktok = comedian.tiktok_url.replace('https://tiktok.com/@', '');\n  \n  // Generate SEO meta tags\n  const metaTags = generateComedianMetaTags({\n    ...comedian,\n    profile_picture: comedian.avatar_url,\n    social_media: socialMedia,\n    slug: comedian.profile_slug || slug\n  });\n  \n  // Generate structured data\n  const personSchema = generatePersonSchema({\n    ...comedian,\n    profile_picture: comedian.avatar_url,\n    social_media: socialMedia,\n    upcoming_shows: upcomingShows,\n    slug: comedian.profile_slug || slug\n  });\n  const breadcrumbSchema = generateBreadcrumbSchema([\n    { name: 'Home', url: '/' },\n    { name: 'Comedians', url: '/comedians' },\n    { name: comedian.stage_name || comedian.name }\n  ]);\n  \n  return (\n    <>\n      <SEOHead\n        {...metaTags}\n        structuredData={[personSchema, breadcrumbSchema]}\n      />\n      <ComedianProfileLayout comedian={comedian} />\n    </>\n  );\n};\n\nexport default ComedianProfileBySlug;\n"}, {"path": "src/pages/InvoicePaymentCancelled.tsx", "content": "import React, { useCallback, useEffect, useState } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { XCircle, RefreshCw, Home } from 'lucide-react';\nimport { supabase } from '@/integrations/supabase/client';\n\nexport const InvoicePaymentCancelled: React.FC = () => {\n  const { invoiceId } = useParams();\n  const navigate = useNavigate();\n  const [invoice, setInvoice] = useState<any>(null);\n  const [loading, setLoading] = useState(true);\n\n  const loadInvoice = useCallback(async () => {\n    try {\n      const { data, error } = await supabase\n        .from('invoices')\n        .select('*, invoice_recipients(*)')\n        .eq('id', invoiceId)\n        .single();\n\n      if (error) throw error;\n      setInvoice(data);\n    } catch (error) {\n      console.error('Failed to load invoice:', error);\n    } finally {\n      setLoading(false);\n    }\n  }, [invoiceId]);\n\n  useEffect(() => {\n    if (invoiceId) {\n      void loadInvoice();\n    }\n  }, [invoiceId, loadInvoice]);\n\n  const handleRetryPayment = async () => {\n    if (!invoice) return;\n\n    try {\n      // Get the active payment link\n      const { data: paymentLink } = await supabase\n        .from('invoice_payment_links')\n        .select('url')\n        .eq('invoice_id', invoiceId)\n        .eq('status', 'active')\n        .single();\n\n      if (paymentLink?.url) {\n        window.location.href = paymentLink.url;\n      } else {\n        // If no active link, redirect to invoice page\n        navigate(`/invoices/${invoiceId}`);\n      }\n    } catch (error) {\n      console.error('Failed to get payment link:', error);\n      navigate(`/invoices/${invoiceId}`);\n    }\n  };\n\n  if (loading) {\n    return (\n      <div className=\"flex items-center justify-center min-h-screen\">\n        <div className=\"text-center\">Loading...</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex items-center justify-center min-h-screen p-4\">\n      <Card className=\"max-w-md w-full\">\n        <CardHeader className=\"text-center\">\n          <XCircle className=\"w-16 h-16 text-red-500 mx-auto mb-4\" />\n          <CardTitle className=\"text-2xl font-bold text-gray-800\">\n            Payment Cancelled\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-6\">\n          <div className=\"text-center text-gray-600\">\n            <p>Your payment was cancelled.</p>\n            <p className=\"mt-2\">No charges have been made to your account.</p>\n            \n            {invoice && (\n              <div className=\"mt-4 p-4 bg-gray-50 rounded-lg text-left\">\n                <h3 className=\"font-semibold mb-2\">Invoice Details</h3>\n                <div className=\"space-y-1 text-sm\">\n                  <p><span className=\"font-medium\">Invoice Number:</span> {invoice.invoice_number}</p>\n                  <p><span className=\"font-medium\">Amount:</span> {invoice.currency} {invoice.total_amount}</p>\n                  <p><span className=\"font-medium\">Status:</span> {invoice.status}</p>\n                </div>\n              </div>\n            )}\n          </div>\n\n          <div className=\"space-y-3\">\n            <Button \n              className=\"w-full\" \n              onClick={handleRetryPayment}\n            >\n              <RefreshCw className=\"w-4 h-4 mr-2\" />\n              Try Again\n            </Button>\n            <Button \n              variant=\"outline\" \n              className=\"w-full\"\n              onClick={() => navigate('/invoices')}\n            >\n              <Home className=\"w-4 h-4 mr-2\" />\n              Back to Invoices\n            </Button>\n          </div>\n\n          <div className=\"text-center text-sm text-gray-500\">\n            <p>If you continue to experience issues, please contact support.</p>\n          </div>\n        </CardContent>\n      </Card>\n    </div>\n  );\n};\n"}, {"path": "src/pages/InvoicePaymentSuccess.tsx", "content": "import React, { useCallback, useEffect, useState } from 'react';\nimport { useParams, useNavigate } from 'react-router-dom';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { CheckCircle, FileText, Home } from 'lucide-react';\nimport { supabase } from '@/integrations/supabase/client';\nimport { format } from 'date-fns';\n\nexport const InvoicePaymentSuccess: React.FC = () => {\n  const { invoiceId } = useParams();\n  const navigate = useNavigate();\n  const [invoice, setInvoice] = useState<any>(null);\n  const [loading, setLoading] = useState(true);\n\n  const loadInvoice = useCallback(async () => {\n    try {\n      const { data, error } = await supabase\n        .from('invoices')\n        .select('*, invoice_recipients(*)')\n        .eq('id', invoiceId)\n        .single();\n\n      if (error) throw error;\n      setInvoice(data);\n    } catch (error) {\n      console.error('Failed to load invoice:', error);\n    } finally {\n      setLoading(false);\n    }\n  }, [invoiceId]);\n\n  useEffect(() => {\n    if (invoiceId) {\n      void loadInvoice();\n    }\n  }, [invoiceId, loadInvoice]);\n\n  if (loading) {\n    return (\n      <div className=\"flex items-center justify-center min-h-screen\">\n        <div className=\"text-center\">Loading...</div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex items-center justify-center min-h-screen p-4\">\n      <Card className=\"max-w-md w-full\">\n        <CardHeader className=\"text-center\">\n          <CheckCircle className=\"w-16 h-16 text-green-500 mx-auto mb-4\" />\n          <CardTitle className=\"text-2xl font-bold text-green-700\">\n            Payment Successful!\n          </CardTitle>\n        </CardHeader>\n        <CardContent className=\"space-y-6\">\n          <div className=\"text-center text-gray-600\">\n            <p>Thank you for your payment.</p>\n            {invoice && (\n              <div className=\"mt-4 p-4 bg-gray-50 rounded-lg text-left\">\n                <h3 className=\"font-semibold mb-2\">Invoice Details</h3>\n                <div className=\"space-y-1 text-sm\">\n                  <p><span className=\"font-medium\">Invoice Number:</span> {invoice.invoice_number}</p>\n                  <p><span className=\"font-medium\">Amount:</span> {invoice.currency} {invoice.total_amount}</p>\n                  <p><span className=\"font-medium\">Date:</span> {format(new Date(), 'MMM dd, yyyy')}</p>\n                </div>\n              </div>\n            )}\n          </div>\n\n          <div className=\"space-y-3\">\n            <Button \n              className=\"w-full\" \n              onClick={() => navigate(`/invoices/${invoiceId}`)}\n            >\n              <FileText className=\"w-4 h-4 mr-2\" />\n              View Invoice\n            </Button>\n            <Button \n              variant=\"outline\" \n              className=\"w-full\"\n              onClick={() => navigate('/invoices')}\n            >\n              <Home className=\"w-4 h-4 mr-2\" />\n              Back to Invoices\n            </Button>\n          </div>\n\n          <div className=\"text-center text-sm text-gray-500\">\n            <p>A confirmation email has been sent to your registered email address.</p>\n          </div>\n        </CardContent>\n      </Card>\n    </div>\n  );\n};\n"}, {"path": "src/pages/Profile.tsx", "content": "\nimport React, { useState, useEffect } from 'react';\nimport { Button } from '@/components/ui/button';\nimport { ContactSettings } from '@/components/ContactSettings';\nimport { VouchSystemEnhanced } from '@/components/VouchSystemEnhanced';\nimport { ProfileCalendarView } from '@/components/ProfileCalendarView';\nimport { ContactRequests } from '@/components/ContactRequests';\nimport { ImageCrop } from '@/components/ImageCrop';\nimport { ProfileHeader } from '@/components/ProfileHeader';\nimport { ProfileTabs } from '@/components/profile/ProfileTabs';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { useTheme } from '@/contexts/ThemeContext';\nimport { useToast } from '@/hooks/use-toast';\nimport { useLocation } from 'react-router-dom';\nimport { useProfileData } from '@/hooks/useProfileData';\nimport { cn } from '@/lib/utils';\nimport { supabase } from '@/integrations/supabase/client';\nimport { cleanupOldProfileImages } from '@/utils/profileImageCleanup';\n\nconst Profile = () => {\n  const { user, profile, signOut, updateProfile, hasRole } = useAuth();\n  const { theme } = useTheme();\n  const { toast } = useToast();\n  const location = useLocation();\n  \n  // Get tab from URL parameter or default to 'profile'\n  const urlParams = new URLSearchParams(location.search);\n  const initialTab = urlParams.get('tab') || 'profile';\n  const [activeTab, setActiveTab] = useState(initialTab);\n  \n  const [showImageCrop, setShowImageCrop] = useState(false);\n  const [selectedImage, setSelectedImage] = useState<string>('');\n  const [avatarKey, setAvatarKey] = useState(Date.now()); // Force avatar refresh\n\n  // Check if user is industry user (comedian/promoter/admin)\n  const isIndustryUser = hasRole('comedian') || hasRole('promoter') || hasRole('admin');\n  \n  // For now, set isMemberView to false since we're removing the member view concept\n  const isMemberView = false;\n\n  // Get profile data using custom hook\n  const { userInterests, mockTickets } = useProfileData(user?.id, isMemberView);\n\n  // Tab configuration based on view mode\n  const memberTabs = ['profile', 'tickets', 'notifications', 'book-comedian', 'settings'];\n  const industryTabs = ['profile', 'calendar', isIndustryUser ? 'invoices' : 'tickets', 'vouches', 'settings'];\n  const availableTabs = isMemberView ? memberTabs : industryTabs;\n\n  // Only sync from URL on component mount, not on every URL change\n  useEffect(() => {\n    const urlParams = new URLSearchParams(location.search);\n    const tabParam = urlParams.get('tab') || 'profile';\n    \n    \n    // Set initial tab if it's valid, otherwise use 'profile'\n    if (availableTabs.includes(tabParam)) {\n      setActiveTab(tabParam);\n    } else {\n      setActiveTab('profile');\n    }\n  }, [availableTabs, location.search]);\n\n  const getBackgroundStyles = () => {\n    if (theme === 'pleasure') {\n      return 'bg-gradient-to-br from-purple-700 via-purple-800 to-purple-900';\n    }\n    return 'bg-gradient-to-br from-gray-800 via-gray-900 to-red-900';\n  };\n\n  if (!user) {\n    return (\n      <div className={cn(\"min-h-screen flex items-center justify-center p-4\", getBackgroundStyles())}>\n        <div className=\"text-center max-w-md w-full\">\n          <h1 className=\"text-xl sm:text-2xl font-bold text-white mb-4\">Please sign in to view your profile</h1>\n          <Button className=\"w-full\">Sign In</Button>\n        </div>\n      </div>\n    );\n  }\n\n  const handleSaveProfile = async (formData: any) => {\n    try {\n      if (!user?.id) {\n        throw new Error('User not authenticated');\n      }\n\n      // Map form data to profile update format\n      const profileUpdate = {\n        first_name: formData.firstName,\n        last_name: formData.lastName,\n        stage_name: formData.stageName || null,\n        name_display_preference: formData.nameDisplayPreference || 'real',\n        email: formData.email,\n        phone: formData.phone || null,\n        bio: formData.bio || null,\n        location: formData.location || null,\n        years_experience: formData.yearsExperience ? parseInt(formData.yearsExperience) : null,\n        custom_show_types: formData.customShowTypes || [],\n        instagram_url: formData.instagramUrl || null,\n        twitter_url: formData.twitterUrl || null,\n        website_url: formData.websiteUrl || null,\n        youtube_url: formData.youtubeUrl || null,\n        facebook_url: formData.facebookUrl || null,\n        tiktok_url: formData.tiktokUrl || null,\n      };\n\n      await updateProfile(profileUpdate);\n    } catch (error) {\n      console.error('Profile update failed:', error);\n      throw error; // Re-throw so the component can handle the error\n    }\n  };\n\n  const handleLogout = () => {\n    toast({\n      title: \"Signed Out\",\n      description: \"You have been successfully signed out.\",\n    });\n    signOut();\n  };\n\n  const handleImageSelect = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const file = event.target.files?.[0];\n    if (file) {\n      const reader = new FileReader();\n      reader.onload = (e) => {\n        setSelectedImage(e.target?.result as string);\n        setShowImageCrop(true);\n      };\n      reader.readAsDataURL(file);\n    }\n  };\n\n  const handleCroppedImage = async (croppedImage: string) => {\n    try {\n      // Convert base64 to blob\n      const base64Response = await fetch(croppedImage);\n      const blob = await base64Response.blob();\n      \n      // Create a unique filename\n      const fileExt = 'png';\n      const fileName = `${user?.id}-${Date.now()}.${fileExt}`;\n      const filePath = `${user?.id}/${fileName}`;\n      \n      console.log('Uploading profile image:', { filePath, blobSize: blob.size });\n      \n      // Upload to Supabase storage\n      const { data, error } = await supabase.storage\n        .from('profile-images')\n        .upload(filePath, blob, {\n          contentType: 'image/png',\n          upsert: true\n        });\n      \n      if (error) {\n        console.error('Storage upload error:', error);\n        throw error;\n      }\n      \n      // Get public URL\n      const { data: { publicUrl } } = supabase.storage\n        .from('profile-images')\n        .getPublicUrl(filePath);\n      \n      console.log('Public URL:', publicUrl);\n      \n      // Update profile with the public URL\n      console.log('Updating profile with new avatar URL:', publicUrl);\n      const updateResult = await updateProfile({ avatar_url: publicUrl });\n      \n      if (updateResult.error) {\n        console.error('Profile update error:', updateResult.error);\n        throw updateResult.error;\n      }\n      \n      console.log('Profile update successful');\n      \n      // Close the modal after successful update\n      setShowImageCrop(false);\n      \n      // Force avatar refresh by updating the key\n      const newKey = Date.now();\n      setAvatarKey(newKey);\n      console.log('Avatar key updated to:', newKey);\n      \n      // Double-check the profile was updated\n      setTimeout(() => {\n        console.log('Current profile avatar:', profile?.avatar_url);\n      }, 1000);\n      \n      // Clean up old profile images in the background\n      // We keep 2 images: the new one and the most recent previous one\n      // This helps with caching issues - users will still see their previous pic if needed\n      cleanupOldProfileImages(user.id, filePath).then(deletedCount => {\n        if (deletedCount > 0) {\n          console.log(`Cleaned up ${deletedCount} old profile images`);\n        }\n      }).catch(error => {\n        console.error('Failed to cleanup old images:', error);\n      });\n      \n      // Force a small delay to ensure image loads\n      setTimeout(() => {\n        toast({\n          title: \"Profile Picture Updated\",\n          description: \"Your profile picture has been successfully updated.\",\n        });\n        \n        // Force a page refresh to ensure avatar updates everywhere\n        // This is a temporary workaround for cache issues\n        setTimeout(() => {\n          window.location.reload();\n        }, 500);\n      }, 100);\n    } catch (error) {\n      console.error('Error uploading profile picture:', error);\n      toast({\n        title: \"Upload Failed\",\n        description: error.message || \"Failed to upload profile picture. Please try again.\",\n        variant: \"destructive\",\n      });\n    }\n  };\n\n  // Handle tab changes with validation and URL update\n  const handleTabChange = (newTab: string) => {\n    \n    // Validate the tab is available for current view\n    if (availableTabs.includes(newTab)) {\n      setActiveTab(newTab);\n      \n      // Update URL without triggering useEffect\n      const newUrl = new URL(window.location.href);\n      if (newTab === 'profile') {\n        newUrl.searchParams.delete('tab');\n      } else {\n        newUrl.searchParams.set('tab', newTab);\n      }\n      window.history.replaceState({}, '', newUrl.toString());\n    }\n  };\n\n  // Create a user object that matches the expected interface for ProfileHeader and ProfileTabs\n  const userForComponents = {\n    id: user.id,\n    email: user.email || '',\n    name: profile?.name || '',\n    first_name: profile?.first_name || '',\n    last_name: profile?.last_name || '',\n    stage_name: profile?.stage_name || '',\n    name_display_preference: profile?.name_display_preference || 'real',\n    bio: profile?.bio || '',\n    location: profile?.location || '',\n    phone: profile?.phone || '',\n    instagram_url: profile?.instagram_url || '',\n    twitter_url: profile?.twitter_url || '',\n    website_url: profile?.website_url || '',\n    youtube_url: profile?.youtube_url || '',\n    facebook_url: profile?.facebook_url || '',\n    tiktok_url: profile?.tiktok_url || '',\n    custom_show_types: profile?.custom_show_types || [],\n    avatar: profile?.avatar_url ? `${profile.avatar_url}?t=${avatarKey}` : '',\n    role: hasRole('admin') ? 'admin' : hasRole('promoter') ? 'promoter' : 'comedian',\n    isVerified: profile?.is_verified || false\n  };\n\n  return (\n    <div className={cn(\"min-h-screen\", getBackgroundStyles())}>\n      <div className=\"container mx-auto px-4 py-6 sm:py-8\">\n        {/* Profile Header */}\n        <ProfileHeader \n          user={userForComponents}\n          onImageSelect={handleImageSelect}\n          onLogout={handleLogout}\n        />\n\n        {/* Profile Tabs */}\n        <ProfileTabs\n          activeTab={activeTab}\n          setActiveTab={handleTabChange}\n          isMemberView={isMemberView}\n          isIndustryUser={isIndustryUser}\n          user={userForComponents}\n          userInterests={userInterests}\n          mockTickets={mockTickets}\n          onSave={handleSaveProfile}\n        />\n\n        {/* Image Crop Modal */}\n        <ImageCrop\n          isOpen={showImageCrop}\n          onClose={() => setShowImageCrop(false)}\n          onCrop={handleCroppedImage}\n          imageUrl={selectedImage}\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default Profile;\n"}, {"path": "src/pages/Shows.tsx", "content": "\nimport React, { useState, useEffect } from 'react';\nimport { useLocation } from 'react-router-dom';\nimport { useEventsForListing } from '@/hooks/data/useEvents';\nimport { useBrowseLogic } from '@/hooks/useBrowseLogic';\nimport { FeaturedEventsCarousel } from '@/components/FeaturedEventsCarousel';\nimport { EventFilters } from '@/components/events/EventFilters';\nimport { ShowCard } from '@/components/ShowCard';\nimport { MonthFilter } from '@/components/MonthFilter';\nimport LoadingSpinner from '@/components/LoadingSpinner';\nimport { ApplicationForm } from '@/components/ApplicationForm';\nimport { useTheme } from '@/contexts/ThemeContext';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { cn } from '@/lib/utils';\nimport { Calendar, MapPin, Users, AlertCircle, Clock, Filter, Eye } from 'lucide-react';\n\nconst Shows = () => {\n  const { theme } = useTheme();\n  const { user, hasRole } = useAuth();\n  const location = useLocation();\n  \n  // Get month from URL params\n  const searchParams = new URLSearchParams(location.search);\n  const monthParam = searchParams.get('month');\n  const initialDate = monthParam ? new Date(monthParam) : new Date();\n  \n  const [selectedMonth, setSelectedMonth] = useState<number>(initialDate.getMonth());\n  const [selectedYear, setSelectedYear] = useState<number>(initialDate.getFullYear());\n  \n  // Filter states\n  const [searchTerm, setSearchTerm] = useState('');\n  const [locationFilter, setLocationFilter] = useState('');\n  const [typeFilter, setTypeFilter] = useState('');\n  const [statusFilter, setStatusFilter] = useState('all');\n  const [sortBy, setSortBy] = useState('date');\n  const [dateRange, setDateRange] = useState<{ start: Date | null; end: Date | null }>({ start: null, end: null });\n  const [showDateRange, setShowDateRange] = useState(false);\n  const [useAdvancedFilters, setUseAdvancedFilters] = useState(false);\n  const [showPastEvents, setShowPastEvents] = useState(false);\n  const [showMyDrafts, setShowMyDrafts] = useState(false);\n  const [showOnlyMyEvents, setShowOnlyMyEvents] = useState(false);\n\n  // Check if user can see drafts (promoters and admins)\n  const canSeeDrafts = hasRole('promoter') || hasRole('admin');\n\n  const { events, isLoading, error } = useEventsForListing({\n    include_past: showPastEvents,\n    include_drafts: showMyDrafts && canSeeDrafts,\n    owner_id: showMyDrafts ? user?.id : undefined,\n    my_events: showOnlyMyEvents\n  });\n  \n  // Get browse logic handlers\n  const {\n    interestedEvents,\n    hasAppliedToEvent,\n    getApplicationStatus,\n    isApplying,\n    handleToggleInterested,\n    handleApply,\n    handleBuyTickets,\n    handleShowDetails,\n    handleGetDirections,\n    selectedEventForApplication,\n    showApplicationForm,\n    handleSubmitApplication,\n    setShowApplicationForm\n  } = useBrowseLogic();\n\n  // Filter events based on selected month/year, date range, and other filters\n  const filteredEvents = React.useMemo(() => {\n    if (!events) return [];\n    \n    return events.filter(event => {\n      const eventDate = new Date(event.event_date);\n      \n      const now = new Date();\n\n      // Date filtering logic - use date range if set, otherwise use month/year\n      let matchesDate = true;\n      if (useAdvancedFilters && (dateRange.start || dateRange.end)) {\n        // Custom date range filtering\n        if (dateRange.start && eventDate < dateRange.start) {\n          matchesDate = false;\n        }\n        if (dateRange.end && eventDate > dateRange.end) {\n          matchesDate = false;\n        }\n      } else if (!useAdvancedFilters) {\n        // Month/year filtering (default behavior)\n        matchesDate = eventDate.getMonth() === selectedMonth && eventDate.getFullYear() === selectedYear;\n      }\n\n      if (!showPastEvents && eventDate < now) {\n        matchesDate = false;\n      }\n      \n      const matchesSearch = searchTerm === '' || \n        event.title.toLowerCase().includes(searchTerm.toLowerCase()) ||\n        event.venue.toLowerCase().includes(searchTerm.toLowerCase());\n      const matchesLocation = locationFilter === '' || \n        event.city?.toLowerCase().includes(locationFilter.toLowerCase());\n      const matchesType = typeFilter === '' || event.type === typeFilter;\n      const matchesStatus = statusFilter === 'all' || event.status === statusFilter;\n      const matchesOwnership = !showOnlyMyEvents || event.promoter_id === user?.id || event.co_promoter_ids?.includes(user?.id || '');\n      \n      // Filter drafts for non-owners\n      const canViewEvent = event.status !== 'draft' || \n        (showMyDrafts && (event.promoter_id === user?.id || event.co_promoter_ids?.includes(user?.id || '')));\n      \n      return matchesDate && matchesSearch && matchesLocation && matchesType && matchesStatus && matchesOwnership && canViewEvent;\n  }).sort((a, b) => {\n      const dateA = new Date(a.event_date).getTime();\n      const dateB = new Date(b.event_date).getTime();\n      \n      switch (sortBy) {\n        case 'date':\n          return dateA - dateB;\n        case 'date-desc':\n          return dateB - dateA;\n        case 'title':\n          return a.title.localeCompare(b.title);\n        case 'title-desc':\n          return b.title.localeCompare(a.title);\n        case 'popularity':\n          // Sort by tickets sold or applications count\n          const popularityA = (a.tickets_sold || 0) + (a.applications?.length || 0);\n          const popularityB = (b.tickets_sold || 0) + (b.applications?.length || 0);\n          return popularityB - popularityA;\n        case 'applications':\n          return (b.applications?.length || 0) - (a.applications?.length || 0);\n        default:\n          return dateA - dateB;\n      }\n    });\n  }, [dateRange, events, locationFilter, selectedMonth, selectedYear, showMyDrafts, showOnlyMyEvents, showPastEvents, sortBy, statusFilter, typeFilter, useAdvancedFilters, user?.id, searchTerm]);\n\n  const clearFilters = () => {\n    setSearchTerm('');\n    setLocationFilter('');\n    setTypeFilter('');\n    setStatusFilter('all');\n    setSortBy('date');\n    setDateRange({ start: null, end: null });\n    setShowDateRange(false);\n    setUseAdvancedFilters(false);\n    setShowPastEvents(false);\n    setShowMyDrafts(false);\n    setShowOnlyMyEvents(false);\n  };\n\n  // Calculate active filters count\n  const activeFiltersCount = React.useMemo(() => {\n    let count = 0;\n    if (searchTerm) count++;\n    if (locationFilter) count++;\n    if (typeFilter) count++;\n    if (statusFilter !== 'all') count++;\n    if (sortBy !== 'date') count++;\n    if (dateRange.start || dateRange.end) count++;\n    return count;\n  }, [searchTerm, locationFilter, typeFilter, statusFilter, sortBy, dateRange]);\n\n  const handleDateRangeChange = (range: { start: Date | null; end: Date | null }) => {\n    setDateRange(range);\n    // Clear month/year selection when using custom date range\n    if (range.start || range.end) {\n      // Don't update month/year when using custom range\n    } else {\n      // Reset to current month when clearing date range\n      const now = new Date();\n      setSelectedMonth(now.getMonth());\n      setSelectedYear(now.getFullYear());\n    }\n  };\n\n  const toggleDateRangeMode = () => {\n    setShowDateRange(!showDateRange);\n    if (!showDateRange) {\n      // Clear existing date range when switching to date range mode\n      setDateRange({ start: null, end: null });\n    }\n  };\n\n  const handleMonthChange = (month: number, year: number) => {\n    setSelectedMonth(month);\n    setSelectedYear(year);\n    \n    // Update URL\n    const url = new URL(window.location.href);\n    const dateStr = new Date(year, month).toISOString().slice(0, 7);\n    url.searchParams.set('month', dateStr);\n    window.history.replaceState({}, '', url.toString());\n  };\n\n  if (isLoading) {\n    return (\n      <div className={cn(\"min-h-screen flex items-center justify-center\", \n        theme === 'pleasure' \n          ? 'bg-gradient-to-br from-purple-700 via-purple-800 to-purple-900'\n          : 'bg-gradient-to-br from-gray-800 via-gray-900 to-red-900'\n      )}>\n        <LoadingSpinner size=\"lg\" />\n      </div>\n    );\n  }\n\n  if (error) {\n    return (\n      <div className={cn(\"min-h-screen flex items-center justify-center p-4\",\n        theme === 'pleasure' \n          ? 'bg-gradient-to-br from-purple-700 via-purple-800 to-purple-900'\n          : 'bg-gradient-to-br from-gray-800 via-gray-900 to-red-900'\n      )}>\n        <div className=\"text-center text-white\">\n          <h2 className=\"text-2xl font-bold mb-2\">Oops! Something went wrong</h2>\n          <p className=\"text-gray-300\">We couldn't load the events. Please try again later.</p>\n        </div>\n      </div>\n    );\n  }\n\n  const getBackgroundStyles = () => {\n    if (theme === 'pleasure') {\n      return 'bg-gradient-to-br from-purple-700 via-purple-800 to-purple-900';\n    }\n    return 'bg-gradient-to-br from-gray-800 via-gray-900 to-red-900';\n  };\n\n  return (\n    <div className={cn(\"min-h-screen\", getBackgroundStyles())}>\n      <div className=\"container mx-auto px-4 py-6 sm:py-8\">\n\n        {/* Featured Events Carousel */}\n        <div className=\"mb-6 sm:mb-8\">\n          <FeaturedEventsCarousel />\n        </div>\n\n        {/* Filter Mode Toggle */}\n        <div className=\"mb-6\">\n          <div className=\"flex items-center justify-between mb-4\">\n            <h2 className=\"text-2xl font-bold text-white\">Discover Events</h2>\n            <div className=\"flex gap-2\">\n              {/* Additional filter buttons */}\n              <button\n                onClick={() => setShowPastEvents(!showPastEvents)}\n                className={cn(\n                  \"px-3 py-2 rounded-lg transition-colors text-sm font-medium flex items-center gap-2\",\n                  showPastEvents\n                    ? theme === 'pleasure' \n                      ? 'bg-purple-500/30 hover:bg-purple-500/40 text-white border border-purple-400/30'\n                      : 'bg-red-600/30 hover:bg-red-600/40 text-white border border-red-600/30'\n                    : theme === 'pleasure' \n                      ? 'bg-white/10 hover:bg-white/20 text-white border border-white/20'\n                      : 'bg-gray-700 hover:bg-gray-600 text-white border border-gray-600'\n                )}\n              >\n                <Clock size={14} />\n                {showPastEvents ? 'Hide Past' : 'Show Past'}\n              </button>\n              \n              {canSeeDrafts && (\n                <button\n                  onClick={() => setShowMyDrafts(!showMyDrafts)}\n                  className={cn(\n                    \"px-3 py-2 rounded-lg transition-colors text-sm font-medium flex items-center gap-2\",\n                    showMyDrafts\n                      ? theme === 'pleasure' \n                        ? 'bg-purple-500/30 hover:bg-purple-500/40 text-white border border-purple-400/30'\n                        : 'bg-red-600/30 hover:bg-red-600/40 text-white border border-red-600/30'\n                      : theme === 'pleasure' \n                        ? 'bg-white/10 hover:bg-white/20 text-white border border-white/20'\n                        : 'bg-gray-700 hover:bg-gray-600 text-white border border-gray-600'\n                  )}\n                >\n                  <Eye size={14} />\n                  {showMyDrafts ? 'Hide Drafts' : 'My Drafts'}\n                </button>\n              )}\n              \n              {user && (\n                <button\n                  onClick={() => setShowOnlyMyEvents(!showOnlyMyEvents)}\n                  className={cn(\n                    \"px-3 py-2 rounded-lg transition-colors text-sm font-medium flex items-center gap-2\",\n                    showOnlyMyEvents\n                      ? theme === 'pleasure' \n                        ? 'bg-purple-500/30 hover:bg-purple-500/40 text-white border border-purple-400/30'\n                        : 'bg-red-600/30 hover:bg-red-600/40 text-white border border-red-600/30'\n                      : theme === 'pleasure' \n                        ? 'bg-white/10 hover:bg-white/20 text-white border border-white/20'\n                        : 'bg-gray-700 hover:bg-gray-600 text-white border border-gray-600'\n                  )}\n                >\n                  <Filter size={14} />\n                  {showOnlyMyEvents ? 'All Events' : 'My Events'}\n                </button>\n              )}\n              \n              <button\n                onClick={() => {\n                  setUseAdvancedFilters(!useAdvancedFilters);\n                  if (!useAdvancedFilters) {\n                    // Reset date range when switching to advanced filters\n                    setDateRange({ start: null, end: null });\n                  }\n                }}\n                className={cn(\n                  \"px-4 py-2 rounded-lg transition-colors text-sm font-medium\",\n                  theme === 'pleasure' \n                    ? 'bg-white/10 hover:bg-white/20 text-white border border-white/20'\n                    : 'bg-gray-700 hover:bg-gray-600 text-white border border-gray-600'\n                )}\n              >\n                {useAdvancedFilters ? 'Use Month View' : 'Advanced Filters'}\n              </button>\n            </div>\n          </div>\n\n          {/* Show either Month Filter or Advanced Filters */}\n          {!useAdvancedFilters ? (\n            <MonthFilter \n              selectedMonth={selectedMonth}\n              selectedYear={selectedYear}\n              onMonthChange={handleMonthChange}\n              events={events || []}\n            />\n          ) : (\n            <EventFilters\n              searchTerm={searchTerm}\n              setSearchTerm={setSearchTerm}\n              statusFilter={statusFilter}\n              setStatusFilter={setStatusFilter}\n              locationFilter={locationFilter}\n              setLocationFilter={setLocationFilter}\n              typeFilter={typeFilter}\n              setTypeFilter={setTypeFilter}\n              sortBy={sortBy}\n              setSortBy={setSortBy}\n              dateRange={dateRange}\n              onDateRangeChange={handleDateRangeChange}\n              onClearFilters={clearFilters}\n              activeFiltersCount={activeFiltersCount}\n            />\n          )}\n        </div>\n\n        {/* Results Summary */}\n        {filteredEvents.length > 0 && (\n          <div className=\"mb-4 flex items-center justify-between\">\n            <p className=\"text-white/80\">\n              Found <span className=\"font-semibold\">{filteredEvents.length}</span> events\n              {activeFiltersCount > 0 && ` matching your filters`}\n              {showPastEvents && ' (including past events)'}\n              {showMyDrafts && ' (including your drafts)'}\n              {showOnlyMyEvents && ' (your events only)'}\n            </p>\n            {filteredEvents.length > 10 && (\n              <p className=\"text-white/60 text-sm\">\n                Showing all results\n              </p>\n            )}\n          </div>\n        )}\n\n        {/* Events Grid */}\n        {filteredEvents.length > 0 ? (\n          <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 sm:gap-6\">\n            {filteredEvents.map((event) => {\n              const isPast = event.is_past;\n              const isDraft = event.status === 'draft';\n              const isCancelled = event.status === 'cancelled';\n              \n              return (\n                <div key={event.id} className=\"relative\">\n                  {/* Status badges */}\n                  {(isPast || isDraft || isCancelled) && (\n                    <div className=\"absolute top-2 left-2 z-10 flex gap-2\">\n                      {isPast && (\n                        <span className=\"px-2 py-1 text-xs font-medium bg-gray-800/80 text-gray-300 rounded-full backdrop-blur-sm\">\n                          Past Event\n                        </span>\n                      )}\n                      {isDraft && (\n                        <span className=\"px-2 py-1 text-xs font-medium bg-yellow-600/80 text-yellow-100 rounded-full backdrop-blur-sm\">\n                          Draft\n                        </span>\n                      )}\n                      {isCancelled && (\n                        <span className=\"px-2 py-1 text-xs font-medium bg-red-600/80 text-white rounded-full backdrop-blur-sm\">\n                          Cancelled\n                        </span>\n                      )}\n                    </div>\n                  )}\n                  <ShowCard \n                    show={event}\n                    interestedEvents={interestedEvents}\n                    onToggleInterested={handleToggleInterested}\n                    onApply={handleApply}\n                    onBuyTickets={handleBuyTickets}\n                    onShowDetails={handleShowDetails}\n                    onGetDirections={handleGetDirections}\n                    hasAppliedToEvent={hasAppliedToEvent}\n                    getApplicationStatus={getApplicationStatus}\n                    isApplying={isApplying}\n                  />\n                </div>\n              );\n            })}\n          </div>\n        ) : (\n          <div className=\"text-center py-16\">\n            <div className={cn(\n              \"rounded-2xl p-12 max-w-2xl mx-auto\",\n              theme === 'pleasure' \n                ? 'bg-white/[0.08] backdrop-blur-md border border-white/[0.20]'\n                : 'bg-gray-800/60 backdrop-blur-md border border-gray-600'\n            )}>\n              <AlertCircle className=\"w-16 h-16 mx-auto mb-4 text-white/40\" />\n              <h3 className={cn(\"text-2xl font-bold mb-3\",\n                theme === 'pleasure' ? 'text-purple-100' : 'text-gray-200'\n              )}>\n                No Events Found\n              </h3>\n              <p className={cn(\"text-base mb-6 max-w-md mx-auto\",\n                theme === 'pleasure' ? 'text-purple-200' : 'text-gray-400'\n              )}>\n                {activeFiltersCount > 0 \n                  ? \"No events match your current filters. Try adjusting your search criteria.\"\n                  : showPastEvents\n                    ? \"No past or upcoming events found. Check back later for new shows!\"\n                    : showOnlyMyEvents\n                      ? \"You don't have any events yet. Create your first event to get started!\"\n                      : showMyDrafts\n                        ? \"You don't have any draft events. Start creating an event to see it here!\"\n                        : \"No upcoming events found for this period. Try showing past events or selecting a different date range.\"}\n              </p>\n              \n              <div className=\"flex flex-col sm:flex-row gap-3 justify-center\">\n                {activeFiltersCount > 0 && (\n                  <button\n                    onClick={clearFilters}\n                    className={cn(\"px-6 py-3 rounded-lg transition-colors font-medium\",\n                      theme === 'pleasure' \n                        ? 'bg-purple-600 hover:bg-purple-700 text-white'\n                        : 'bg-red-600 hover:bg-red-700 text-white'\n                    )}\n                  >\n                    Clear All Filters\n                  </button>\n                )}\n                <button\n                  onClick={() => window.location.reload()}\n                  className={cn(\"px-6 py-3 rounded-lg transition-colors font-medium\",\n                    theme === 'pleasure' \n                      ? 'bg-white/10 hover:bg-white/20 text-white border border-white/20'\n                      : 'bg-gray-700 hover:bg-gray-600 text-white border border-gray-600'\n                  )}\n                >\n                  Refresh Page\n                </button>\n              </div>\n              \n              {activeFiltersCount === 0 && (\n                <div className=\"mt-8 pt-8 border-t border-white/10\">\n                  <p className=\"text-sm text-white/60 mb-3\">Quick tips:</p>\n                  <ul className=\"text-left max-w-md mx-auto space-y-2 text-sm text-white/60\">\n                    <li className=\"flex items-start gap-2\">\n                      <Calendar className=\"w-4 h-4 mt-0.5 flex-shrink-0\" />\n                      <span>Try browsing different months using the month selector above</span>\n                    </li>\n                    <li className=\"flex items-start gap-2\">\n                      <MapPin className=\"w-4 h-4 mt-0.5 flex-shrink-0\" />\n                      <span>Events are added regularly across all major cities</span>\n                    </li>\n                    <li className=\"flex items-start gap-2\">\n                      <Users className=\"w-4 h-4 mt-0.5 flex-shrink-0\" />\n                      <span>Follow us for updates on new shows and events</span>\n                    </li>\n                  </ul>\n                </div>\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* Application Form Dialog */}\n      {selectedEventForApplication && (\n        <ApplicationForm\n          open={showApplicationForm}\n          onOpenChange={setShowApplicationForm}\n          eventId={selectedEventForApplication.id}\n          eventTitle={selectedEventForApplication.title}\n          onSubmit={handleSubmitApplication}\n          isSubmitting={isApplying}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default Shows;\n"}, {"path": "src/pages/TourDashboard.tsx", "content": "// Tour Dashboard - Comprehensive tour management dashboard\nimport React, { useState, useEffect } from 'react';\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Input } from '@/components/ui/input';\nimport { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';\nimport { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';\nimport { toast } from '@/hooks/use-toast';\nimport { \n  Plus, \n  Search, \n  Filter, \n  Calendar, \n  MapPin, \n  Users, \n  DollarSign,\n  TrendingUp,\n  TrendingDown,\n  Clock,\n  CheckCircle,\n  XCircle,\n  AlertCircle,\n  Music,\n  Plane,\n  Building,\n  Target,\n  BarChart3,\n  Settings,\n  Eye,\n  Edit,\n  Trash2,\n  Copy,\n  Share2,\n  Download,\n  Upload,\n  RefreshCw\n} from 'lucide-react';\nimport { useAuth } from '@/contexts/AuthContext';\nimport { useTheme } from '@/contexts/ThemeContext';\nimport { tourService } from '@/services/tourService';\nimport { taskService } from '@/services/task';\nimport { cn } from '@/lib/utils';\nimport type { \n  Tour, \n  TourStatus, \n  TourDashboardStats, \n  TourSearchParams, \n  TourCalendarEvent,\n  CreateTourRequest \n} from '@/types/tour';\n\nconst TourDashboard: React.FC = () => {\n  const { user, hasRole } = useAuth();\n  const { theme } = useTheme();\n  const queryClient = useQueryClient();\n  \n  // State management\n  const [searchQuery, setSearchQuery] = useState('');\n  const [selectedStatus, setSelectedStatus] = useState<TourStatus | 'all'>('all');\n  const [viewMode, setViewMode] = useState<'grid' | 'list' | 'calendar'>('grid');\n  const [showCreateModal, setShowCreateModal] = useState(false);\n  const [selectedTour, setSelectedTour] = useState<Tour | null>(null);\n\n  // Queries\n  const { data: dashboardStats, isLoading: statsLoading } = useQuery({\n    queryKey: ['tour-dashboard-stats', user?.id],\n    queryFn: () => tourService.getTourDashboardStats(user?.id),\n    refetchInterval: 30000, // Refresh every 30 seconds\n    staleTime: 15000\n  });\n\n  const { data: toursData, isLoading: toursLoading, refetch: refetchTours } = useQuery({\n    queryKey: ['tours', searchQuery, selectedStatus, user?.id],\n    queryFn: () => {\n      const params: TourSearchParams = {\n        query: searchQuery || undefined,\n        filters: {\n          status: selectedStatus !== 'all' ? [selectedStatus] : undefined,\n          manager_id: user?.id\n        },\n        sort_by: 'start_date',\n        sort_order: 'asc',\n        limit: 50\n      };\n      return tourService.getTours(params);\n    },\n    staleTime: 5000\n  });\n\n  const { data: calendarEvents } = useQuery({\n    queryKey: ['tour-calendar-events', user?.id],\n    queryFn: async () => {\n      const tours = toursData?.tours || [];\n      const allEvents: TourCalendarEvent[] = [];\n      \n      for (const tour of tours) {\n        const events = await tourService.getTourCalendarEvents(tour.id);\n        allEvents.push(...events);\n      }\n      \n      return allEvents;\n    },\n    enabled: !!toursData?.tours,\n    staleTime: 10000\n  });\n\n  // Mutations\n  const createTourMutation = useMutation({\n    mutationFn: tourService.createTour,\n    onSuccess: (newTour) => {\n      queryClient.invalidateQueries({ queryKey: ['tours'] });\n      queryClient.invalidateQueries({ queryKey: ['tour-dashboard-stats'] });\n      toast({\n        title: \"Tour Created\",\n        description: `${newTour.name} has been created successfully.`,\n      });\n      setShowCreateModal(false);\n    },\n    onError: (error) => {\n      toast({\n        title: \"Error\",\n        description: \"Failed to create tour. Please try again.\",\n        variant: \"destructive\",\n      });\n    }\n  });\n\n  const deleteTourMutation = useMutation({\n    mutationFn: tourService.deleteTour,\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['tours'] });\n      queryClient.invalidateQueries({ queryKey: ['tour-dashboard-stats'] });\n      toast({\n        title: \"Tour Deleted\",\n        description: \"Tour has been deleted successfully.\",\n      });\n    },\n    onError: (error) => {\n      toast({\n        title: \"Error\",\n        description: \"Failed to delete tour. Please try again.\",\n        variant: \"destructive\",\n      });\n    }\n  });\n\n  const duplicateTourMutation = useMutation({\n    mutationFn: ({ tourId, newName }: { tourId: string; newName: string }) => \n      tourService.duplicateTour(tourId, newName),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: ['tours'] });\n      toast({\n        title: \"Tour Duplicated\",\n        description: \"Tour has been duplicated successfully.\",\n      });\n    },\n    onError: (error) => {\n      toast({\n        title: \"Error\",\n        description: \"Failed to duplicate tour. Please try again.\",\n        variant: \"destructive\",\n      });\n    }\n  });\n\n  // Real-time updates\n  useEffect(() => {\n    const interval = window.setInterval(() => {\n      queryClient.invalidateQueries({ queryKey: ['tour-dashboard-stats'] });\n      queryClient.invalidateQueries({ queryKey: ['tour-calendar-events'] });\n    }, 60000); // Refresh every minute\n\n    return () => {\n      clearInterval(interval);\n    };\n  }, [queryClient]);\n\n  // Helper functions\n  const getStatusColor = (status: TourStatus): string => {\n    const colors = {\n      planning: 'bg-yellow-100 text-yellow-800 border-yellow-300',\n      confirmed: 'bg-blue-100 text-blue-800 border-blue-300',\n      in_progress: 'bg-green-100 text-green-800 border-green-300',\n      completed: 'bg-gray-100 text-gray-800 border-gray-300',\n      cancelled: 'bg-red-100 text-red-800 border-red-300',\n      postponed: 'bg-orange-100 text-orange-800 border-orange-300'\n    };\n    return colors[status] || colors.planning;\n  };\n\n  const getStatusIcon = (status: TourStatus) => {\n    const icons = {\n      planning: <Clock className=\"w-4 h-4\" />,\n      confirmed: <CheckCircle className=\"w-4 h-4\" />,\n      in_progress: <TrendingUp className=\"w-4 h-4\" />,\n      completed: <CheckCircle className=\"w-4 h-4\" />,\n      cancelled: <XCircle className=\"w-4 h-4\" />,\n      postponed: <AlertCircle className=\"w-4 h-4\" />\n    };\n    return icons[status] || icons.planning;\n  };\n\n  const formatCurrency = (amount: number, currency: string = 'AUD'): string => {\n    return new Intl.NumberFormat('en-AU', {\n      style: 'currency',\n      currency: currency,\n      minimumFractionDigits: 0,\n      maximumFractionDigits: 0\n    }).format(amount);\n  };\n\n  const handleCreateTour = (formData: CreateTourRequest) => {\n    createTourMutation.mutate(formData);\n  };\n\n  const handleDeleteTour = (tourId: string) => {\n    if (window.confirm('Are you sure you want to delete this tour? This action cannot be undone.')) {\n      deleteTourMutation.mutate(tourId);\n    }\n  };\n\n  const handleDuplicateTour = (tour: Tour) => {\n    const newName = prompt('Enter name for the duplicated tour:', `${tour.name} (Copy)`);\n    if (newName) {\n      duplicateTourMutation.mutate({ tourId: tour.id, newName });\n    }\n  };\n\n  const getBackgroundStyles = () => {\n    if (theme === 'pleasure') {\n      return 'bg-gradient-to-br from-purple-900 via-blue-900 to-purple-900';\n    }\n    return 'bg-gradient-to-br from-gray-900 via-blue-900 to-gray-900';\n  };\n\n  const tours = toursData?.tours || [];\n  const isLoading = statsLoading || toursLoading;\n\n  return (\n    <div className={cn(\"min-h-screen\", getBackgroundStyles())}>\n      <div className=\"container mx-auto px-4 py-8\">\n        <div className=\"max-w-7xl mx-auto space-y-8\">\n          {/* Header */}\n          <div className=\"flex flex-col lg:flex-row justify-between items-start lg:items-center gap-4\">\n            <div>\n              <h1 className=\"text-4xl font-bold text-white mb-2\">Tour Management</h1>\n              <p className=\"text-blue-200\">Manage your comedy tours, shows, and collaborations</p>\n            </div>\n            \n            <div className=\"flex gap-3\">\n              <Button \n                variant=\"outline\" \n                className=\"border-blue-400/30 text-blue-200 hover:bg-blue-500/20\"\n                onClick={() => refetchTours()}\n              >\n                <RefreshCw className=\"w-4 h-4 mr-2\" />\n                Refresh\n              </Button>\n              \n              <Button \n                onClick={() => setShowCreateModal(true)}\n                className=\"bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-700 hover:to-purple-700\"\n              >\n                <Plus className=\"w-4 h-4 mr-2\" />\n                New Tour\n              </Button>\n            </div>\n          </div>\n\n          {/* Dashboard Stats */}\n          {dashboardStats && (\n            <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6\">\n              <Card className=\"bg-gradient-to-br from-blue-600 to-blue-700 border-blue-500/20\">\n                <CardContent className=\"p-6\">\n                  <div className=\"flex items-center justify-between\">\n                    <div>\n                      <p className=\"text-blue-100 text-sm font-medium\">Total Tours</p>\n                      <p className=\"text-3xl font-bold text-white\">{dashboardStats.total_tours}</p>\n                    </div>\n                    <Music className=\"w-8 h-8 text-blue-200\" />\n                  </div>\n                </CardContent>\n              </Card>\n\n              <Card className=\"bg-gradient-to-br from-green-600 to-green-700 border-green-500/20\">\n                <CardContent className=\"p-6\">\n                  <div className=\"flex items-center justify-between\">\n                    <div>\n                      <p className=\"text-green-100 text-sm font-medium\">Active Tours</p>\n                      <p className=\"text-3xl font-bold text-white\">{dashboardStats.active_tours}</p>\n                    </div>\n                    <TrendingUp className=\"w-8 h-8 text-green-200\" />\n                  </div>\n                </CardContent>\n              </Card>\n\n              <Card className=\"bg-gradient-to-br from-purple-600 to-purple-700 border-purple-500/20\">\n                <CardContent className=\"p-6\">\n                  <div className=\"flex items-center justify-between\">\n                    <div>\n                      <p className=\"text-purple-100 text-sm font-medium\">Total Revenue</p>\n                      <p className=\"text-3xl font-bold text-white\">\n                        {formatCurrency(dashboardStats.total_revenue)}\n                      </p>\n                    </div>\n                    <DollarSign className=\"w-8 h-8 text-purple-200\" />\n                  </div>\n                </CardContent>\n              </Card>\n\n              <Card className=\"bg-gradient-to-br from-orange-600 to-orange-700 border-orange-500/20\">\n                <CardContent className=\"p-6\">\n                  <div className=\"flex items-center justify-between\">\n                    <div>\n                      <p className=\"text-orange-100 text-sm font-medium\">Upcoming Shows</p>\n                      <p className=\"text-3xl font-bold text-white\">{dashboardStats.upcoming_shows}</p>\n                    </div>\n                    <Calendar className=\"w-8 h-8 text-orange-200\" />\n                  </div>\n                </CardContent>\n              </Card>\n            </div>\n          )}\n\n          {/* Filters and Search */}\n          <Card className=\"bg-slate-800/50 border-slate-700/50\">\n            <CardContent className=\"p-6\">\n              <div className=\"flex flex-col lg:flex-row gap-4\">\n                <div className=\"flex-1\">\n                  <div className=\"relative\">\n                    <Search className=\"absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400 w-4 h-4\" />\n                    <Input\n                      placeholder=\"Search tours...\"\n                      value={searchQuery}\n                      onChange={(e) => setSearchQuery(e.target.value)}\n                      className=\"pl-10 bg-slate-900/50 border-slate-600/50 text-white placeholder-gray-400\"\n                    />\n                  </div>\n                </div>\n                \n                <div className=\"flex gap-3\">\n                  <Select value={selectedStatus} onValueChange={setSelectedStatus}>\n                    <SelectTrigger className=\"w-48 bg-slate-900/50 border-slate-600/50 text-white\">\n                      <SelectValue placeholder=\"Filter by status\" />\n                    </SelectTrigger>\n                    <SelectContent className=\"bg-slate-800 border-slate-700\">\n                      <SelectItem value=\"all\">All Statuses</SelectItem>\n                      <SelectItem value=\"planning\">Planning</SelectItem>\n                      <SelectItem value=\"confirmed\">Confirmed</SelectItem>\n                      <SelectItem value=\"in_progress\">In Progress</SelectItem>\n                      <SelectItem value=\"completed\">Completed</SelectItem>\n                      <SelectItem value=\"cancelled\">Cancelled</SelectItem>\n                      <SelectItem value=\"postponed\">Postponed</SelectItem>\n                    </SelectContent>\n                  </Select>\n\n                  <div className=\"flex border rounded-lg bg-slate-900/50 border-slate-600/50\">\n                    <Button\n                      variant={viewMode === 'grid' ? 'secondary' : 'ghost'}\n                      size=\"sm\"\n                      onClick={() => setViewMode('grid')}\n                      className=\"rounded-r-none\"\n                    >\n                      <BarChart3 className=\"w-4 h-4\" />\n                    </Button>\n                    <Button\n                      variant={viewMode === 'list' ? 'secondary' : 'ghost'}\n                      size=\"sm\"\n                      onClick={() => setViewMode('list')}\n                      className=\"rounded-none\"\n                    >\n                      <Target className=\"w-4 h-4\" />\n                    </Button>\n                    <Button\n                      variant={viewMode === 'calendar' ? 'secondary' : 'ghost'}\n                      size=\"sm\"\n                      onClick={() => setViewMode('calendar')}\n                      className=\"rounded-l-none\"\n                    >\n                      <Calendar className=\"w-4 h-4\" />\n                    </Button>\n                  </div>\n                </div>\n              </div>\n            </CardContent>\n          </Card>\n\n          {/* Tours List/Grid */}\n          {viewMode === 'grid' && (\n            <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6\">\n              {tours.map((tour) => (\n                <Card key={tour.id} className=\"bg-slate-800/50 border-slate-700/50 hover:bg-slate-800/70 transition-colors\">\n                  <CardHeader className=\"pb-3\">\n                    <div className=\"flex items-start justify-between\">\n                      <div className=\"flex-1\">\n                        <CardTitle className=\"text-white text-lg mb-2\">{tour.name}</CardTitle>\n                        <Badge className={cn(\"mb-2\", getStatusColor(tour.status))}>\n                          {getStatusIcon(tour.status)}\n                          <span className=\"ml-1 capitalize\">{tour.status}</span>\n                        </Badge>\n                      </div>\n                      \n                      <div className=\"flex gap-1\">\n                        <Button\n                          variant=\"ghost\"\n                          size=\"sm\"\n                          onClick={() => {/* Navigate to tour details */}}\n                          className=\"text-blue-400 hover:text-blue-300\"\n                        >\n                          <Eye className=\"w-4 h-4\" />\n                        </Button>\n                        <Button\n                          variant=\"ghost\"\n                          size=\"sm\"\n                          onClick={() => handleDuplicateTour(tour)}\n                          className=\"text-green-400 hover:text-green-300\"\n                        >\n                          <Copy className=\"w-4 h-4\" />\n                        </Button>\n                        <Button\n                          variant=\"ghost\"\n                          size=\"sm\"\n                          onClick={() => handleDeleteTour(tour.id)}\n                          className=\"text-red-400 hover:text-red-300\"\n                        >\n                          <Trash2 className=\"w-4 h-4\" />\n                        </Button>\n                      </div>\n                    </div>\n                  </CardHeader>\n                  \n                  <CardContent className=\"pt-0\">\n                    <div className=\"space-y-3\">\n                      {tour.description && (\n                        <p className=\"text-gray-300 text-sm line-clamp-2\">{tour.description}</p>\n                      )}\n                      \n                      <div className=\"flex items-center text-sm text-gray-400\">\n                        <Calendar className=\"w-4 h-4 mr-2\" />\n                        {tour.start_date ? (\n                          <span>\n                            {new Date(tour.start_date).toLocaleDateString()} - {' '}\n                            {tour.end_date ? new Date(tour.end_date).toLocaleDateString() : 'TBD'}\n                          </span>\n                        ) : (\n                          <span>Dates TBD</span>\n                        )}\n                      </div>\n                      \n                      <div className=\"flex items-center text-sm text-gray-400\">\n                        <DollarSign className=\"w-4 h-4 mr-2\" />\n                        <span>Revenue: {formatCurrency(tour.actual_revenue)}</span>\n                      </div>\n                      \n                      <div className=\"flex items-center text-sm text-gray-400\">\n                        <Users className=\"w-4 h-4 mr-2\" />\n                        <span>Sold: {tour.tickets_sold.toLocaleString()}</span>\n                      </div>\n                    </div>\n                  </CardContent>\n                </Card>\n              ))}\n            </div>\n          )}\n\n          {/* Empty State */}\n          {tours.length === 0 && !isLoading && (\n            <Card className=\"bg-slate-800/50 border-slate-700/50\">\n              <CardContent className=\"py-16 text-center\">\n                <Music className=\"w-16 h-16 text-gray-400 mx-auto mb-6\" />\n                <h3 className=\"text-xl font-semibold text-white mb-2\">No tours found</h3>\n                <p className=\"text-gray-400 mb-6\">\n                  {searchQuery || selectedStatus !== 'all' \n                    ? \"Try adjusting your search or filters\"\n                    : \"Get started by creating your first tour\"\n                  }\n                </p>\n                <Button \n                  onClick={() => setShowCreateModal(true)}\n                  className=\"bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-700 hover:to-purple-700\"\n                >\n                  <Plus className=\"w-4 h-4 mr-2\" />\n                  Create Your First Tour\n                </Button>\n              </CardContent>\n            </Card>\n          )}\n\n          {/* Loading State */}\n          {isLoading && (\n            <div className=\"flex justify-center py-16\">\n              <div className=\"text-center\">\n                <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-blue-400 mx-auto mb-4\"></div>\n                <p className=\"text-gray-400\">Loading tours...</p>\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n\n      {/* Create Tour Modal */}\n      <CreateTourModal\n        isOpen={showCreateModal}\n        onClose={() => setShowCreateModal(false)}\n        onSubmit={handleCreateTour}\n        isLoading={createTourMutation.isPending}\n      />\n    </div>\n  );\n};\n\n// Create Tour Modal Component\ninterface CreateTourModalProps {\n  isOpen: boolean;\n  onClose: () => void;\n  onSubmit: (data: CreateTourRequest) => void;\n  isLoading: boolean;\n}\n\nconst CreateTourModal: React.FC<CreateTourModalProps> = ({ \n  isOpen, \n  onClose, \n  onSubmit, \n  isLoading \n}) => {\n  const [formData, setFormData] = useState<CreateTourRequest>({\n    name: '',\n    description: '',\n    tour_type: 'comedy',\n    currency: 'AUD',\n    is_public: false\n  });\n\n  const handleSubmit = (e: React.FormEvent) => {\n    e.preventDefault();\n    onSubmit(formData);\n    setFormData({\n      name: '',\n      description: '',\n      tour_type: 'comedy',\n      currency: 'AUD',\n      is_public: false\n    });\n  };\n\n  return (\n    <Dialog open={isOpen} onOpenChange={onClose}>\n      <DialogContent className=\"bg-slate-800 border-slate-700 text-white max-w-2xl\">\n        <DialogHeader>\n          <DialogTitle className=\"text-xl\">Create New Tour</DialogTitle>\n        </DialogHeader>\n        \n        <form onSubmit={handleSubmit} className=\"space-y-6\">\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\n            <div>\n              <label className=\"block text-sm font-medium mb-2\">Tour Name *</label>\n              <Input\n                required\n                placeholder=\"e.g., Comedy Gold Tour 2024\"\n                value={formData.name}\n                onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}\n                className=\"bg-slate-900/50 border-slate-600/50 text-white\"\n              />\n            </div>\n            \n            <div>\n              <label className=\"block text-sm font-medium mb-2\">Tour Type</label>\n              <Select \n                value={formData.tour_type} \n                onValueChange={(value) => setFormData(prev => ({ ...prev, tour_type: value }))}\n              >\n                <SelectTrigger className=\"bg-slate-900/50 border-slate-600/50 text-white\">\n                  <SelectValue />\n                </SelectTrigger>\n                <SelectContent className=\"bg-slate-800 border-slate-700\">\n                  <SelectItem value=\"comedy\">Comedy</SelectItem>\n                  <SelectItem value=\"mixed\">Mixed</SelectItem>\n                  <SelectItem value=\"festival\">Festival</SelectItem>\n                  <SelectItem value=\"corporate\">Corporate</SelectItem>\n                </SelectContent>\n              </Select>\n            </div>\n          </div>\n\n          <div>\n            <label className=\"block text-sm font-medium mb-2\">Description</label>\n            <textarea\n              placeholder=\"Brief description of the tour...\"\n              value={formData.description}\n              onChange={(e) => setFormData(prev => ({ ...prev, description: e.target.value }))}\n              className=\"w-full p-3 bg-slate-900/50 border border-slate-600/50 rounded-lg text-white placeholder-gray-400 h-24 resize-none\"\n            />\n          </div>\n\n          <div className=\"grid grid-cols-1 md:grid-cols-3 gap-4\">\n            <div>\n              <label className=\"block text-sm font-medium mb-2\">Start Date</label>\n              <Input\n                type=\"date\"\n                value={formData.start_date || ''}\n                onChange={(e) => setFormData(prev => ({ ...prev, start_date: e.target.value }))}\n                className=\"bg-slate-900/50 border-slate-600/50 text-white\"\n              />\n            </div>\n            \n            <div>\n              <label className=\"block text-sm font-medium mb-2\">End Date</label>\n              <Input\n                type=\"date\"\n                value={formData.end_date || ''}\n                onChange={(e) => setFormData(prev => ({ ...prev, end_date: e.target.value }))}\n                className=\"bg-slate-900/50 border-slate-600/50 text-white\"\n              />\n            </div>\n            \n            <div>\n              <label className=\"block text-sm font-medium mb-2\">Budget</label>\n              <Input\n                type=\"number\"\n                placeholder=\"0\"\n                value={formData.budget || ''}\n                onChange={(e) => setFormData(prev => ({ ...prev, budget: parseFloat(e.target.value) || undefined }))}\n                className=\"bg-slate-900/50 border-slate-600/50 text-white\"\n              />\n            </div>\n          </div>\n\n          <div className=\"flex items-center gap-2\">\n            <input\n              type=\"checkbox\"\n              id=\"is_public\"\n              checked={formData.is_public}\n              onChange={(e) => setFormData(prev => ({ ...prev, is_public: e.target.checked }))}\n              className=\"rounded border-slate-600 bg-slate-900\"\n            />\n            <label htmlFor=\"is_public\" className=\"text-sm\">\n              Make this tour publicly visible\n            </label>\n          </div>\n\n          <div className=\"flex gap-3 pt-6\">\n            <Button\n              type=\"button\"\n              variant=\"outline\"\n              onClick={onClose}\n              className=\"flex-1 border-slate-600 text-slate-300 hover:bg-slate-700\"\n            >\n              Cancel\n            </Button>\n            <Button\n              type=\"submit\"\n              disabled={isLoading}\n              className=\"flex-1 bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-700 hover:to-purple-700\"\n            >\n              {isLoading ? 'Creating...' : 'Create Tour'}\n            </Button>\n          </div>\n        </form>\n      </DialogContent>\n    </Dialog>\n  );\n};\n\nexport default TourDashboard;\n"}, {"path": "src/services/multiPlatformAnalyticsService.ts", "content": "/**\n * Multi-Platform Analytics Service\n * Provides unified reporting across Humanitix and Eventbrite platforms\n */\n\nimport { supabase } from '@/integrations/supabase/client';\n\nexport interface PlatformMetrics {\n  source: 'humanitix' | 'eventbrite';\n  event_count: number;\n  total_orders: number;\n  total_tickets: number;\n  total_revenue_cents: number;\n  total_fees_cents: number;\n  net_revenue_cents: number;\n}\n\nexport interface EventMetrics {\n  event_source_id: string;\n  event_name: string;\n  source: string;\n  start_date: string;\n  status: string;\n  total_orders: number;\n  total_tickets: number;\n  total_revenue_cents: number;\n  net_revenue_cents: number;\n  fees_cents: number;\n  venue_name: string;\n  venue_city: string;\n}\n\nexport interface CombinedEventMetrics {\n  event_name: string;\n  start_date: string;\n  venue_name: string;\n  venue_city: string;\n  platforms: {\n    source: string;\n    orders: number;\n    tickets: number;\n    revenue_cents: number;\n    net_revenue_cents: number;\n  }[];\n  totals: {\n    orders: number;\n    tickets: number;\n    revenue_cents: number;\n    net_revenue_cents: number;\n  };\n}\n\nclass MultiPlatformAnalyticsService {\n\n  /**\n   * Get overall platform performance metrics\n   */\n  async getPlatformMetrics(startDate?: string, endDate?: string): Promise<PlatformMetrics[]> {\n    let query = supabase\n      .from('orders_htx')\n      .select(`\n        source,\n        event_source_id,\n        total_cents,\n        fees_cents,\n        net_sales_cents\n      `)\n      .not('source', 'is', null);\n\n    if (startDate) {\n      query = query.gte('ordered_at', startDate);\n    }\n    if (endDate) {\n      query = query.lte('ordered_at', endDate);\n    }\n\n    const { data: orders, error } = await query;\n\n    if (error) {\n      throw error;\n    }\n\n    // Get ticket counts per platform\n    const ticketQuery = supabase\n      .from('tickets_htx')\n      .select('source, order_source_id')\n      .not('source', 'is', null);\n\n    const { data: tickets, error: ticketError } = await ticketQuery;\n\n    if (ticketError) {\n      throw ticketError;\n    }\n\n    // Get event counts per platform\n    const { data: events, error: eventError } = await supabase\n      .from('events_htx')\n      .select('source')\n      .not('source', 'is', null);\n\n    if (eventError) {\n      throw eventError;\n    }\n\n    // Calculate metrics by platform\n    const platformMetrics: { [key: string]: PlatformMetrics } = {};\n\n    // Initialize platforms\n    ['humanitix', 'eventbrite'].forEach(source => {\n      platformMetrics[source] = {\n        source: source as 'humanitix' | 'eventbrite',\n        event_count: 0,\n        total_orders: 0,\n        total_tickets: 0,\n        total_revenue_cents: 0,\n        total_fees_cents: 0,\n        net_revenue_cents: 0,\n      };\n    });\n\n    // Count events by platform\n    events?.forEach(event => {\n      if (platformMetrics[event.source]) {\n        platformMetrics[event.source].event_count++;\n      }\n    });\n\n    // Sum order metrics by platform\n    orders?.forEach(order => {\n      if (platformMetrics[order.source]) {\n        platformMetrics[order.source].total_orders++;\n        platformMetrics[order.source].total_revenue_cents += order.total_cents || 0;\n        platformMetrics[order.source].total_fees_cents += order.fees_cents || 0;\n        platformMetrics[order.source].net_revenue_cents += order.net_sales_cents || 0;\n      }\n    });\n\n    // Count tickets by platform\n    tickets?.forEach(ticket => {\n      if (platformMetrics[ticket.source]) {\n        platformMetrics[ticket.source].total_tickets++;\n      }\n    });\n\n    return Object.values(platformMetrics);\n  }\n\n  /**\n   * Get detailed metrics for all events across platforms\n   */\n  async getEventMetrics(startDate?: string, endDate?: string): Promise<EventMetrics[]> {\n    const query = `\n      SELECT\n        e.source_id as event_source_id,\n        e.name as event_name,\n        e.source,\n        e.start_date,\n        e.status,\n        e.venue_name,\n        e.venue_city,\n        COALESCE(order_stats.total_orders, 0) as total_orders,\n        COALESCE(ticket_stats.total_tickets, 0) as total_tickets,\n        COALESCE(order_stats.total_revenue_cents, 0) as total_revenue_cents,\n        COALESCE(order_stats.net_revenue_cents, 0) as net_revenue_cents,\n        COALESCE(order_stats.fees_cents, 0) as fees_cents\n      FROM events_htx e\n      LEFT JOIN (\n        SELECT\n          event_source_id,\n          COUNT(*) as total_orders,\n          SUM(total_cents) as total_revenue_cents,\n          SUM(net_sales_cents) as net_revenue_cents,\n          SUM(fees_cents) as fees_cents\n        FROM orders_htx\n        WHERE source IS NOT NULL\n        ${startDate ? `AND ordered_at >= '${startDate}'` : ''}\n        ${endDate ? `AND ordered_at <= '${endDate}'` : ''}\n        GROUP BY event_source_id\n      ) order_stats ON e.source_id = order_stats.event_source_id\n      LEFT JOIN (\n        SELECT\n          session_source_id,\n          COUNT(*) as total_tickets\n        FROM tickets_htx\n        WHERE source IS NOT NULL\n        GROUP BY session_source_id\n      ) ticket_stats ON e.source_id = ticket_stats.session_source_id\n      WHERE e.source IS NOT NULL\n      ORDER BY e.start_date DESC;\n    `;\n\n    const { data, error } = await supabase.rpc('execute_raw_sql', { query });\n\n    if (error) {\n      throw error;\n    }\n\n    return data;\n  }\n\n  /**\n   * Get combined metrics for events that exist on multiple platforms\n   */\n  async getCombinedEventMetrics(startDate?: string, endDate?: string): Promise<CombinedEventMetrics[]> {\n    // First, get all event metrics\n    const eventMetrics = await this.getEventMetrics(startDate, endDate);\n\n    // Group by event name and date to find events on multiple platforms\n    const eventGroups: { [key: string]: EventMetrics[] } = {};\n\n    eventMetrics.forEach(event => {\n      // Create a key based on event name and date for matching\n      const key = `${event.event_name?.toLowerCase().trim()}_${event.start_date?.split('T')[0]}`;\n\n      if (!eventGroups[key]) {\n        eventGroups[key] = [];\n      }\n      eventGroups[key].push(event);\n    });\n\n    // Convert to combined metrics format\n    const combinedMetrics: CombinedEventMetrics[] = [];\n\n    Object.values(eventGroups).forEach(events => {\n      if (events.length === 0) return;\n\n      // Use the first event as the base info\n      const baseEvent = events[0];\n\n      // Calculate platform-specific and total metrics\n      const platforms = events.map(event => ({\n        source: event.source,\n        orders: event.total_orders,\n        tickets: event.total_tickets,\n        revenue_cents: event.total_revenue_cents,\n        net_revenue_cents: event.net_revenue_cents,\n      }));\n\n      const totals = {\n        orders: events.reduce((sum, e) => sum + e.total_orders, 0),\n        tickets: events.reduce((sum, e) => sum + e.total_tickets, 0),\n        revenue_cents: events.reduce((sum, e) => sum + e.total_revenue_cents, 0),\n        net_revenue_cents: events.reduce((sum, e) => sum + e.net_revenue_cents, 0),\n      };\n\n      combinedMetrics.push({\n        event_name: baseEvent.event_name,\n        start_date: baseEvent.start_date,\n        venue_name: baseEvent.venue_name,\n        venue_city: baseEvent.venue_city,\n        platforms,\n        totals,\n      });\n    });\n\n    // Sort by total revenue descending\n    return combinedMetrics.sort((a, b) => b.totals.revenue_cents - a.totals.revenue_cents);\n  }\n\n  /**\n   * Get revenue comparison between platforms\n   */\n  async getRevenueComparison(startDate?: string, endDate?: string) {\n    const platformMetrics = await this.getPlatformMetrics(startDate, endDate);\n\n    const total = platformMetrics.reduce((sum, platform) => ({\n      orders: sum.orders + platform.total_orders,\n      tickets: sum.tickets + platform.total_tickets,\n      revenue: sum.revenue + platform.total_revenue_cents,\n      net_revenue: sum.net_revenue + platform.net_revenue_cents,\n    }), { orders: 0, tickets: 0, revenue: 0, net_revenue: 0 });\n\n    return {\n      platforms: platformMetrics.map(platform => ({\n        source: platform.source,\n        orders: platform.total_orders,\n        tickets: platform.total_tickets,\n        revenue_cents: platform.total_revenue_cents,\n        net_revenue_cents: platform.net_revenue_cents,\n        fees_cents: platform.total_fees_cents,\n        revenue_percentage: total.revenue > 0 ? (platform.total_revenue_cents / total.revenue * 100) : 0,\n        orders_percentage: total.orders > 0 ? (platform.total_orders / total.orders * 100) : 0,\n      })),\n      totals: {\n        orders: total.orders,\n        tickets: total.tickets,\n        revenue_cents: total.revenue,\n        net_revenue_cents: total.net_revenue,\n      },\n    };\n  }\n\n  /**\n   * Get recent sales activity across both platforms\n   */\n  async getRecentSalesActivity(limit = 50) {\n    const { data: recentOrders, error } = await supabase\n      .from('orders_htx')\n      .select(`\n        source,\n        source_id,\n        event_source_id,\n        order_reference,\n        status,\n        total_cents,\n        net_sales_cents,\n        purchaser_name,\n        purchaser_email,\n        ordered_at,\n        events_htx!inner(name, start_date, venue_name)\n      `)\n      .not('source', 'is', null)\n      .order('ordered_at', { ascending: false })\n      .limit(limit);\n\n    if (error) {\n      throw error;\n    }\n\n    return recentOrders?.map(order => ({\n      platform: order.source,\n      order_id: order.source_id,\n      order_reference: order.order_reference,\n      event_name: order.events_htx.name,\n      event_date: order.events_htx.start_date,\n      venue_name: order.events_htx.venue_name,\n      purchaser_name: order.purchaser_name,\n      purchaser_email: order.purchaser_email,\n      total_amount: (order.total_cents / 100).toFixed(2),\n      net_amount: (order.net_sales_cents / 100).toFixed(2),\n      ordered_at: order.ordered_at,\n      status: order.status,\n    })) || [];\n  }\n\n  /**\n   * Get platform health check - recent sync status\n   */\n  async getPlatformHealthCheck() {\n    // Get recent orders by platform\n    const { data: recentActivity, error } = await supabase\n      .from('orders_htx')\n      .select('source, ordered_at, updated_at_api')\n      .not('source', 'is', null)\n      .order('updated_at_api', { ascending: false });\n\n    if (error) {\n      throw error;\n    }\n\n    const platformHealth = {\n      humanitix: {\n        last_order_at: null,\n        last_api_update: null,\n        status: 'unknown',\n      },\n      eventbrite: {\n        last_order_at: null,\n        last_api_update: null,\n        status: 'unknown',\n      },\n    };\n\n    recentActivity?.forEach(order => {\n      if (order.source && platformHealth[order.source]) {\n        if (!platformHealth[order.source].last_order_at || order.ordered_at > platformHealth[order.source].last_order_at) {\n          platformHealth[order.source].last_order_at = order.ordered_at;\n        }\n        if (!platformHealth[order.source].last_api_update || order.updated_at_api > platformHealth[order.source].last_api_update) {\n          platformHealth[order.source].last_api_update = order.updated_at_api;\n        }\n      }\n    });\n\n    // Determine status based on recent activity\n    const now = new Date();\n    const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);\n\n    Object.keys(platformHealth).forEach(platform => {\n      const health = platformHealth[platform];\n      if (health.last_api_update && new Date(health.last_api_update) > oneDayAgo) {\n        health.status = 'healthy';\n      } else if (health.last_api_update) {\n        health.status = 'stale';\n      } else {\n        health.status = 'no_data';\n      }\n    });\n\n    return platformHealth;\n  }\n}\n\nexport const multiPlatformAnalyticsService = new MultiPlatformAnalyticsService();\n"}]