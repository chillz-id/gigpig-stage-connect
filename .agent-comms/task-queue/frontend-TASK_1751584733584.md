# TASK_1751584733584
AGENT: FRONTEND
TIMESTAMP: 2025-07-03T23:18:53.584Z
STATUS: PENDING

## DIRECTIVE
ðŸŽ­ Stand Up Sydney Platform - Comprehensive Development Specification Project: Complete Platform Overhaul & Enhancement Target: Overnight implementation by 3 AI agents Architecture: Supabase + Lovable + N8N + Claude MCP  ðŸŽ¯ PROJECT OVERVIEW This specification outlines the development of a comprehensive comedy booking platform with advanced payment systems, agency management, and competitive feature parity. The project is divided into three main sections for parallel development by specialized AI agents. Core Objectives  âœ… Comprehensive payment/invoicing system âœ… Complete UI/UX overhaul and theme consistency âœ… 360-degree agency/management system âœ… Competitive feature implementation âœ… Microservices architecture with real-time capabilities   ðŸ¦ AGENT 1: PAYMENT & FINANCIAL SYSTEMS 1.1 Invoice Management System Database Schema Extensions sql-- Invoices Table CREATE TABLE invoices (     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),     comedian_id UUID REFERENCES comedians(id),     client_name VARCHAR(255) NOT NULL,     client_email VARCHAR(255) NOT NULL,     client_address JSONB,     invoice_number VARCHAR(50) UNIQUE NOT NULL,     issue_date DATE NOT NULL,     due_date DATE NOT NULL,     line_items JSONB[] NOT NULL,     subtotal DECIMAL(10,2) NOT NULL,     tax_rate DECIMAL(5,4) DEFAULT 0,     tax_amount DECIMAL(10,2) DEFAULT 0,     total_amount DECIMAL(10,2) NOT NULL,     currency VARCHAR(3) DEFAULT 'AUD',     status invoice_status DEFAULT 'draft',     payment_terms TEXT,     notes TEXT,     created_at TIMESTAMP DEFAULT NOW(),     updated_at TIMESTAMP DEFAULT NOW() );  -- Payment Records Table CREATE TABLE payment_records (     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),     invoice_id UUID REFERENCES invoices(id),     amount DECIMAL(10,2) NOT NULL,     payment_method VARCHAR(50),     payment_date TIMESTAMP DEFAULT NOW(),     transaction_id VARCHAR(100),     gateway VARCHAR(50),     status payment_status DEFAULT 'pending',     metadata JSONB,     created_at TIMESTAMP DEFAULT NOW() );  -- Recurring Invoices Table CREATE TABLE recurring_invoices (     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),     comedian_id UUID REFERENCES comedians(id),     template_data JSONB NOT NULL,     frequency recurring_frequency NOT NULL,     next_invoice_date DATE NOT NULL,     is_active BOOLEAN DEFAULT true,     created_at TIMESTAMP DEFAULT NOW() );  -- Custom Types CREATE TYPE invoice_status AS ENUM ('draft', 'sent', 'paid', 'overdue', 'cancelled'); CREATE TYPE payment_status AS ENUM ('pending', 'completed', 'failed', 'refunded'); CREATE TYPE recurring_frequency AS ENUM ('weekly', 'monthly', 'quarterly', 'yearly'); 1.2 FlexPay Integration System javascript// FlexPay Configuration const flexPayConfig = {   gateways: {     stripe: {       publicKey: process.env.STRIPE_PUBLIC_KEY,       secretKey: process.env.STRIPE_SECRET_KEY,       webhookSecret: process.env.STRIPE_WEBHOOK_SECRET,       features: ['cards', 'bank_transfers', 'split_payments']     },     paypal: {       clientId: process.env.PAYPAL_CLIENT_ID,       clientSecret: process.env.PAYPAL_CLIENT_SECRET,       environment: process.env.PAYPAL_ENVIRONMENT,       features: ['paypal_checkout', 'paypal_credit']     },     bankTransfer: {       bsb: process.env.BANK_BSB,       accountNumber: process.env.BANK_ACCOUNT,       accountName: process.env.BANK_ACCOUNT_NAME,       features: ['direct_debit', 'bpay']     }   },      // Split Payment Logic   splitPayment: {     platformCommission: 0.05, // 5%     agencyCommission: 0.15,   // 15%     comedianPayout: 0.80      // 80%   },      // Currency Support   supportedCurrencies: ['AUD', 'USD', 'GBP', 'EUR'],   defaultCurrency: 'AUD' };  // Payment Processing API export class PaymentProcessor {   async createInvoice(invoiceData) {     const invoice = await supabase       .from('invoices')       .insert({         ...invoiceData,         invoice_number: await this.generateInvoiceNumber(),         status: 'draft'       })       .select()       .single();          return invoice;   }      async processPayment(invoiceId, paymentMethod, gatewayData) {     const invoice = await this.getInvoice(invoiceId);          switch (paymentMethod) {       case 'stripe':         return await this.processStripePayment(invoice, gatewayData);       case 'paypal':         return await this.processPayPalPayment(invoice, gatewayData);       case 'bank_transfer':         return await this.processBankTransfer(invoice, gatewayData);       default:         throw new Error('Unsupported payment method');     }   }      async splitPayment(totalAmount, bookingId) {     const booking = await this.getBookingDetails(bookingId);     const splits = this.calculateSplits(totalAmount, booking);          // Process splits to different accounts     for (const split of splits) {       await this.transferFunds(split);     }   } } 1.3 Financial Automation Features javascript// Automated Invoice Generation export class InvoiceAutomation {   async generateFromBooking(bookingId) {     const booking = await supabase       .from('bookings')       .select(`         *,         comedian:comedians(*),         venue:venues(*),         event:events(*)       `)       .eq('id', bookingId)       .single();          const invoiceData = {       comedian_id: booking.comedian_id,       client_name: booking.venue.name,       client_email: booking.venue.contact_email,       client_address: booking.venue.address,       line_items: [         {           description: `Comedy Performance - ${booking.event.title}`,           quantity: 1,           rate: booking.agreed_fee,           amount: booking.agreed_fee         }       ],       subtotal: booking.agreed_fee,       tax_rate: this.calculateTaxRate(booking.venue.address.state),       due_date: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000), // 14 days       payment_terms: '14 days net'     };          return await this.createInvoice(invoiceData);   }      // Automated Payment Reminders   async sendPaymentReminders() {     const overdueInvoices = await supabase       .from('invoices')       .select('*')       .eq('status', 'sent')       .lt('due_date', new Date().toISOString());          for (const invoice of overdueInvoices) {       await this.sendReminderEmail(invoice);       await this.updateInvoiceStatus(invoice.id, 'overdue');     }   }      // Recurring Invoice Generation   async processRecurringInvoices() {     const dueRecurring = await supabase       .from('recurring_invoices')       .select('*')       .eq('is_active', true)       .lte('next_invoice_date', new Date().toISOString());          for (const recurring of dueRecurring) {       await this.generateRecurringInvoice(recurring);       await this.updateNextInvoiceDate(recurring);     }   } } 1.4 Financial Reporting Dashboard javascript// Financial Analytics API export class FinancialAnalytics {   async getDashboardData(comedianId, dateRange) {     const [       totalRevenue,       outstandingInvoices,       paidInvoices,       monthlyTrend,       topClients     ] = await Promise.all([       this.getTotalRevenue(comedianId, dateRange),       this.getOutstandingInvoices(comedianId),       this.getPaidInvoices(comedianId, dateRange),       this.getMonthlyTrend(comedianId),       this.getTopClients(comedianId, dateRange)     ]);          return {       totalRevenue,       outstandingInvoices,       paidInvoices,       monthlyTrend,       topClients,       metrics: this.calculateKPIs(comedianId, dateRange)     };   }      async exportToAccounting(format, dateRange) {     const data = await this.getExportData(dateRange);          switch (format) {       case 'xero':         return this.formatForXero(data);       case 'quickbooks':         return this.formatForQuickBooks(data);       case 'csv':         return this.formatAsCSV(data);       default:         throw new Error('Unsupported export format');     }   } }  ðŸŽ¨ AGENT 2: PLATFORM FEATURES & UI/UX 2.1 Landing Page Redesign jsx// New Landing Page Component Structure export const NewLandingPage = () => {   return (     <div className="landing-page">       {/* Hero Section */}       <HeroSection>         <VideoBackground src="/comedy-highlights.mp4" />         <HeroContent>           <h1>Australia's Premier Comedy Booking Platform</h1>           <p>Connect with top comedians, streamline bookings, and grow your venue's entertainment offerings</p>           <CTAButtons>             <Button variant="primary" size="large">Find Comedians</Button>             <Button variant="secondary" size="large">List Your Venue</Button>           </CTAButtons>         </HeroContent>         <StatsOverlay>           <Stat number="500+" label="Active Comedians" />           <Stat number="1000+" label="Successful Bookings" />           <Stat number="50+" label="Partner Venues" />         </StatsOverlay>       </HeroSection>        {/* Social Proof Section */}       <SocialProofSection>         <TestimonialSlider>           <Testimonial              text="Stand Up Sydney transformed our booking process. We've increased our comedy nights by 300%."             author="Sarah Chen, Comedy Club Manager"             venue="The Laugh Track"           />         </TestimonialSlider>         <TrustIndicators>           <SecurityBadge />           <ReviewScore rating={4.9} reviews={247} />           <ComplianceBadges />         </TrustIndicators>       </SocialProofSection>        {/* Feature Showcase */}       <FeatureShowcase>         <InteractiveDemo feature="booking-flow" />         <FeatureGrid>           <FeatureCard              icon="calendar"             title="Smart Scheduling"             description="AI-powered availability matching"           />           <FeatureCard              icon="payment"             title="Secure Payments"             description="Automated invoicing and split payments"           />           <FeatureCard              icon="analytics"             title="Performance Analytics"             description="Track success and optimize bookings"           />         </FeatureGrid>       </FeatureShowcase>        {/* Comedian Spotlight */}       <ComedianSpotlight>         <h2>Featured Performers</h2>         <ComedianCarousel>           {featuredComedians.map(comedian => (             <ComedianCard                key={comedian.id}               comedian={comedian}               variant="spotlight"             />           ))}         </ComedianCarousel>       </ComedianSpotlight>        {/* Venue Partners */}       <VenuePartners>         <h2>Trusted by Australia's Best Venues</h2>         <LogoCarousel venues={partnerVenues} />       </VenuePartners>        {/* Final CTA */}       <FinalCTA>         <h2>Ready to Transform Your Comedy Bookings?</h2>         <Button variant="primary" size="xlarge">Get Started Today</Button>       </FinalCTA>     </div>   ); }; 2.2 Comedian Profile Cards Enhancement css/* Square Profile Picture Cards */ .comedian-card {   position: relative;   aspect-ratio: 1;   border-radius: 12px;   overflow: hidden;   cursor: pointer;   transition: all 0.3s ease;   box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1); }  .comedian-card:hover {   transform: translateY(-8px);   box-shadow: 0 12px 24px rgba(0, 0, 0, 0.2); }  .comedian-card-background {   position: absolute;   top: 0;   left: 0;   width: 100%;   height: 100%;   background-size: cover;   background-position: center;   background-repeat: no-repeat; }  .comedian-card-overlay {   position: absolute;   top: 0;   left: 0;   width: 100%;   height: 100%;   background: linear-gradient(     135deg,     rgba(0, 0, 0, 0.3) 0%,     rgba(0, 0, 0, 0.1) 50%,     rgba(0, 0, 0, 0.7) 100%   );   display: flex;   flex-direction: column;   justify-content: space-between;   padding: 16px;   color: white; }  .comedian-info {   display: flex;   flex-direction: column; }  .comedian-name {   font-size: 1.25rem;   font-weight: 700;   margin-bottom: 4px;   text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5); }  .comedian-style {   font-size: 0.875rem;   opacity: 0.9;   text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5); }  .comedian-stats {   display: flex;   justify-content: space-between;   align-items: center; }  .rating {   display: flex;   align-items: center;   gap: 4px; }  .booking-cta {   background: var(--primary-color);   color: white;   border: none;   padding: 8px 16px;   border-radius: 6px;   font-weight: 600;   opacity: 0;   transform: translateY(10px);   transition: all 0.3s ease; }  .comedian-card:hover .booking-cta {   opacity: 1;   transform: translateY(0); }  /* Responsive Grid */ .comedians-grid {   display: grid;   grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));   gap: 24px;   padding: 24px; }  @media (max-width: 768px) {   .comedians-grid {     grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));     gap: 16px;     padding: 16px;   } } 2.3 Theme Consistency Fix css/* Global Theme System */ :root {   /* Primary Colors */   --primary-color: #FF6B35;   --primary-light: #FF8A65;   --primary-dark: #E65100;      /* Secondary Colors */   --secondary-color: #2196F3;   --secondary-light: #64B5F6;   --secondary-dark: #1976D2;      /* Neutral Colors */   --background-primary: #FFFFFF;   --background-secondary: #F8F9FA;   --background-tertiary: #E9ECEF;      /* Text Colors */   --text-primary: #212529;   --text-secondary: #6C757D;   --text-muted: #ADB5BD;   --text-inverse: #FFFFFF;      /* Status Colors */   --success-color: #28A745;   --warning-color: #FFC107;   --error-color: #DC3545;   --info-color: #17A2B8;      /* Spacing */   --spacing-xs: 4px;   --spacing-sm: 8px;   --spacing-md: 16px;   --spacing-lg: 24px;   --spacing-xl: 32px;   --spacing-xxl: 48px;      /* Border Radius */   --radius-sm: 4px;   --radius-md: 8px;   --radius-lg: 12px;   --radius-xl: 16px;      /* Shadows */   --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.1);   --shadow-md: 0 4px 6px rgba(0, 0, 0, 0.1);   --shadow-lg: 0 10px 15px rgba(0, 0, 0, 0.1);   --shadow-xl: 0 20px 25px rgba(0, 0, 0, 0.1); }  /* Messages Page Theme Fix */ .messages-page {   background: var(--background-primary);   color: var(--text-primary);   min-height: 100vh; }  .message-thread {   background: var(--background-secondary);   border: 1px solid var(--background-tertiary);   border-radius: var(--radius-lg);   padding: var(--spacing-md);   margin-bottom: var(--spacing-md); }  .message-bubble {   padding: var(--spacing-sm) var(--spacing-md);   border-radius: var(--radius-md);   margin-bottom: var(--spacing-sm);   max-width: 70%; }  .message-bubble.sent {   background: var(--primary-color);   color: var(--text-inverse);   margin-left: auto; }  .message-bubble.received {   background: var(--background-tertiary);   color: var(--text-primary); }  /* Notifications Page Theme Fix */ .notifications-page {   background: var(--background-primary);   color: var(--text-primary);   min-height: 100vh; }  .notification-item {   background: var(--background-secondary);   border: 1px solid var(--background-tertiary);   border-radius: var(--radius-md);   padding: var(--spacing-md);   margin-bottom: var(--spacing-sm);   transition: all 0.2s ease; }  .notification-item:hover {   background: var(--background-tertiary);   border-color: var(--primary-light); }  .notification-item.unread {   border-left: 4px solid var(--primary-color);   background: var(--primary-light); } 2.4 Facebook Ads Integration javascript// Meta API Integration Service export class FacebookAdsService {   constructor() {     this.accessToken = process.env.FACEBOOK_ACCESS_TOKEN;     this.adAccountId = process.env.FACEBOOK_AD_ACCOUNT_ID;     this.apiVersion = 'v18.0';     this.baseUrl = `https://graph.facebook.com/${this.apiVersion}`;   }    async getAdCampaigns() {     const response = await fetch(       `${this.baseUrl}/act_${this.adAccountId}/campaigns?fields=id,name,status,objective,created_time,updated_time,daily_budget,lifetime_budget&access_token=${this.accessToken}`     );          return await response.json();   }    async getCampaignInsights(campaignId, dateRange) {     const { since, until } = dateRange;     const fields = [       'campaign_id',       'campaign_name',       'impressions',       'clicks',       'spend',       'cpm',       'cpc',       'ctr',       'reach',       'frequency',       'conversions'     ].join(',');      const response = await fetch(       `${this.baseUrl}/${campaignId}/insights?fields=${fields}&time_range={'since':'${since}','until':'${until}'}&access_token=${this.accessToken}`     );          return await response.json();   }    async getAudienceInsights(campaignId) {     const response = await fetch(       `${this.baseUrl}/${campaignId}/insights?fields=age,gender,country,region,placement&access_token=${this.accessToken}`     );          return await response.json();   }    // Admin Dashboard Integration   async syncAdDataToAdmin() {     const campaigns = await this.getAdCampaigns();          for (const campaign of campaigns.data) {       const insights = await this.getCampaignInsights(campaign.id, {         since: '2024-01-01',         until: 'today'       });              // Store in Supabase for admin dashboard       await supabase.from('ad_campaigns').upsert({         facebook_campaign_id: campaign.id,         name: campaign.name,         status: campaign.status,         objective: campaign.objective,         daily_budget: campaign.daily_budget,         lifetime_budget: campaign.lifetime_budget,         insights: insights.data[0] || {},         last_synced: new Date().toISOString()       });     }   } }  // Admin Dashboard Component export const AdminAdsSection = () => {   const [campaigns, setCampaigns] = useState([]);   const [loading, setLoading] = useState(false);   const facebookAds = new FacebookAdsService();    const syncFacebookAds = async () => {     setLoading(true);     try {       await facebookAds.syncAdDataToAdmin();       // Refresh campaigns data       const { data } = await supabase         .from('ad_campaigns')         .select('*')         .order('last_synced', { ascending: false });       setCampaigns(data);     } catch (error) {       console.error('Failed to sync Facebook ads:', error);     } finally {       setLoading(false);     }   };    return (     <div className="admin-ads-section">       <div className="ads-header">         <h2>Facebook Advertising</h2>         <Button            onClick={syncFacebookAds}            loading={loading}           icon="refresh"         >           Sync Facebook Ads         </Button>       </div>        <div className="ads-overview">         <MetricCard            title="Total Spend"            value={campaigns.reduce((sum, c) => sum + (c.insights?.spend || 0), 0)}           format="currency"         />         <MetricCard            title="Total Impressions"            value={campaigns.reduce((sum, c) => sum + (c.insights?.impressions || 0), 0)}           format="number"         />         <MetricCard            title="Average CTR"            value={campaigns.reduce((sum, c) => sum + (c.insights?.ctr || 0), 0) / campaigns.length}           format="percentage"         />         <MetricCard            title="Active Campaigns"            value={campaigns.filter(c => c.status === 'ACTIVE').length}           format="number"         />       </div>        <CampaignTable campaigns={campaigns} />     </div>   ); }; 2.5 Mobile Excellence & PWA javascript// Progressive Web App Configuration // public/sw.js const CACHE_NAME = 'standup-sydney-v1'; const urlsToCache = [   '/',   '/static/js/bundle.js',   '/static/css/main.css',   '/manifest.json' ];  self.addEventListener('install', (event) => {   event.waitUntil(     caches.open(CACHE_NAME)       .then((cache) => cache.addAll(urlsToCache))   ); });  self.addEventListener('fetch', (event) => {   event.respondWith(     caches.match(event.request)       .then((response) => {         if (response) {           return response;         }         return fetch(event.request);       })   ); });  // Push Notifications self.addEventListener('push', (event) => {   const options = {     body: event.data.text(),     icon: '/icon-192x192.png',     badge: '/badge-72x72.png',     vibrate: [100, 50, 100],     data: {       dateOfArrival: Date.now(),       primaryKey: 1     },     actions: [       {         action: 'explore',         title: 'View Booking',         icon: '/icons/checkmark.png'       },       {         action: 'close',         title: 'Close',         icon: '/icons/xmark.png'       }     ]   };    event.waitUntil(     self.registration.showNotification('Stand Up Sydney', options)   ); });  // Manifest.json {   "name": "Stand Up Sydney",   "short_name": "StandUpSyd",   "description": "Australia's Premier Comedy Booking Platform",   "start_url": "/",   "display": "standalone",   "background_color": "#ffffff",   "theme_color": "#FF6B35",   "icons": [     {       "src": "/icon-192x192.png",       "sizes": "192x192",       "type": "image/png"     },     {       "src": "/icon-512x512.png",       "sizes": "512x512",       "type": "image/png"     }   ],   "categories": ["entertainment", "business"],   "lang": "en-AU",   "orientation": "portrait-primary" }  ðŸŽ­ AGENT 3: AGENCY MANAGEMENT SYSTEM 3.1 Agency Database Schema sql-- Agencies Table CREATE TABLE agencies (     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),     name VARCHAR(255) NOT NULL,     description TEXT,     contact_email VARCHAR(255) NOT NULL,     contact_phone VARCHAR(20),     address JSONB,     commission_rate DECIMAL(5,4) DEFAULT 0.15,     logo_url TEXT,     website TEXT,     social_links JSONB,     verified BOOLEAN DEFAULT false,     subscription_tier agency_tier DEFAULT 'basic',     created_at TIMESTAMP DEFAULT NOW(),     updated_at TIMESTAMP DEFAULT NOW() );  -- Manager Profiles Table CREATE TABLE manager_profiles (     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),     user_id UUID REFERENCES auth.users(id),     agency_id UUID REFERENCES agencies(id),     role manager_role DEFAULT 'manager',     permissions JSONB DEFAULT '{}',     biography TEXT,     experience_years INTEGER,     specializations TEXT[],     contact_preferences JSONB,     is_active BOOLEAN DEFAULT true,     created_at TIMESTAMP DEFAULT NOW() );  -- Artist Management Contracts Table CREATE TABLE artist_management (     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),     manager_id UUID REFERENCES manager_profiles(id),     comedian_id UUID REFERENCES comedians(id),     contract_start DATE NOT NULL,     contract_end DATE,     commission_rate DECIMAL(5,4) NOT NULL,     exclusive BOOLEAN DEFAULT false,     territories TEXT[] DEFAULT '{"Australia"}',     services_included TEXT[],     status contract_status DEFAULT 'active',     contract_terms TEXT,     created_at TIMESTAMP DEFAULT NOW(),     updated_at TIMESTAMP DEFAULT NOW() );  -- Deal Negotiations Table CREATE TABLE deal_negotiations (     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),     manager_id UUID REFERENCES manager_profiles(id),     comedian_id UUID REFERENCES comedians(id),     venue_id UUID REFERENCES venues(id),     booking_id UUID REFERENCES bookings(id),     initial_offer DECIMAL(10,2),     current_offer DECIMAL(10,2),     target_fee DECIMAL(10,2),     status negotiation_status DEFAULT 'in_progress',     negotiation_notes TEXT[],     deadline DATE,     created_at TIMESTAMP DEFAULT NOW() );  -- Manager Communications Table CREATE TABLE manager_communications (     id UUID PRIMARY KEY DEFAULT gen_random_uuid(),     manager_id UUID REFERENCES manager_profiles(id),     comedian_id UUID REFERENCES comedians(id),     venue_id UUID REFERENCES venues(id),     subject VARCHAR(255),     message_type communication_type,     content TEXT,     attachments JSONB,     status message_status DEFAULT 'sent',     response_required BOOLEAN DEFAULT false,     priority communication_priority DEFAULT 'medium',     created_at TIMESTAMP DEFAULT NOW() );  -- Custom Types CREATE TYPE agency_tier AS ENUM ('basic', 'professional', 'enterprise'); CREATE TYPE manager_role AS ENUM ('owner', 'senior_manager', 'manager', 'assistant'); CREATE TYPE contract_status AS ENUM ('draft', 'active', 'expired', 'terminated'); CREATE TYPE negotiation_status AS ENUM ('pending', 'in_progress', 'accepted', 'rejected', 'expired'); CREATE TYPE communication_type AS ENUM ('booking_inquiry', 'contract_negotiation', 'general', 'urgent'); CREATE TYPE message_status AS ENUM ('draft', 'sent', 'delivered', 'read', 'responded'); CREATE TYPE communication_priority AS ENUM ('low', 'medium', 'high', 'urgent'); 3.2 Manager Dashboard API javascript// Manager Dashboard Service export class ManagerDashboardService {   async getDashboardData(managerId) {     const [       managedArtists,       activeNegotiations,       pendingCommunications,       revenueMetrics,       upcomingBookings     ] = await Promise.all([       this.getManagedArtists(managerId),       this.getActiveNegotiations(managerId),       this.getPendingCommunications(managerId),       this.getRevenueMetrics(managerId),       this.getUpcomingBookings(managerId)     ]);      return {       managedArtists,       activeNegotiations,       pendingCommunications,       revenueMetrics,       upcomingBookings,       notifications: await this.getManagerNotifications(managerId)     };   }    async getManagedArtists(managerId) {     const { data } = await supabase       .from('artist_management')       .select(`         *,         comedian:comedians(*),         manager:manager_profiles(*)       `)       .eq('manager_id', managerId)       .eq('status', 'active');      return data;   }    async getActiveNegotiations(managerId) {     const { data } = await supabase       .from('deal_negotiations')       .select(`         *,         comedian:comedians(name, profile_picture),         venue:venues(name, location),         booking:bookings(event_date, event_details)       `)       .eq('manager_id', managerId)       .in('status', ['pending', 'in_progress']);      return data;   }    async startNegotiation(negotiationData) {     const { data } = await supabase       .from('deal_negotiations')       .insert({         ...negotiationData,         status: 'in_progress',         negotiation_notes: [`Initial offer: $${negotiationData.initial_offer}`]       })       .select()       .single();      // Send notification to venue     await this.sendNegotiationNotification(data);          return data;   }    async updateNegotiation(negotiationId, updateData) {     const existingNegotiation = await supabase       .from('deal_negotiations')       .select('*')       .eq('id', negotiationId)       .single();      const updatedNotes = [       ...existingNegotiation.data.negotiation_notes,       `Updated offer: $${updateData.current_offer} - ${new Date().toISOString()}`     ];      const { data } = await supabase       .from('deal_negotiations')       .update({         ...updateData,         negotiation_notes: updatedNotes,         updated_at: new Date().toISOString()       })       .eq('id', negotiationId)       .select()       .single();      return data;   } }  // Artist Discovery Service export class ArtistDiscoveryService {   async searchAvailableArtists(searchCriteria) {     let query = supabase       .from('comedians')       .select(`         *,         performances:bookings(count),         ratings:reviews(rating)       `);      // Apply search filters     if (searchCriteria.location) {       query = query.ilike('location', `%${searchCriteria.location}%`);     }      if (searchCriteria.comedyStyle) {       query = query.contains('comedy_styles', [searchCriteria.comedyStyle]);     }      if (searchCriteria.experienceLevel) {       query = query.gte('experience_years', searchCriteria.experienceLevel);     }      if (searchCriteria.availabilityDate) {       // Check availability       query = query.not('id', 'in',          supabase           .from('bookings')           .select('comedian_id')           .eq('event_date', searchCriteria.availabilityDate)           .eq('status', 'confirmed')       );     }      const { data } = await query.limit(20);          // Calculate match scores     return data.map(comedian => ({       ...comedian,       matchScore: this.calculateMatchScore(comedian, searchCriteria)     })).sort((a, b) => b.matchScore - a.matchScore);   }    calculateMatchScore(comedian, criteria) {     let score = 0;          // Location proximity (40 points max)     if (criteria.location && comedian.location) {       const distance = this.calculateDistance(criteria.location, comedian.location);       score += Math.max(0, 40 - (distance * 2));     }          // Comedy style match (30 points max)     if (criteria.comedyStyle && comedian.comedy_styles?.includes(criteria.comedyStyle)) {       score += 30;     }          // Experience level (20 points max)     if (criteria.experienceLevel) {       const experienceDiff = Math.abs(comedian.experience_years - criteria.experienceLevel);       score += Math.max(0, 20 - experienceDiff);     }          // Rating bonus (10 points max)     const avgRating = comedian.ratings?.reduce((sum, r) => sum + r.rating, 0) / comedian.ratings?.length || 0;     score += avgRating * 2;          return Math.round(score);   } } 3.3 Communication Hub javascript// Manager Communication System export class ManagerCommunicationHub {   async sendMessage(communicationData) {     const { data } = await supabase       .from('manager_communications')       .insert({         ...communicationData,         status: 'sent',         created_at: new Date().toISOString()       })       .select()       .single();      // Send actual email/SMS based on preferences     await this.deliverMessage(data);          // Create notification for recipient     await this.createNotification(data);          return data;   }    async getConversationThread(managerId, contactId, contactType) {     const { data } = await supabase       .from('manager_communications')       .select('*')       .eq('manager_id', managerId)       .eq(contactType === 'comedian' ? 'comedian_id' : 'venue_id', contactId)       .order('created_at', { ascending: true });      return data;   }    async setupAutoResponder(managerId, settings) {     const { data } = await supabase       .from('manager_profiles')       .update({         contact_preferences: {           ...settings,           auto_responder: true,           auto_response_templates: settings.templates         }       })       .eq('id', managerId)       .select()       .single();      return data;   }    async handleIncomingMessage(messageData) {     // Check if manager has auto-responder enabled     const managerSettings = await this.getManagerSettings(messageData.manager_id);          if (managerSettings.contact_preferences?.auto_responder) {       await this.sendAutoResponse(messageData, managerSettings);     }      // Create notification for manager     await this.notifyManager(messageData);          // Log conversation     await this.logConversation(messageData);   }    async forwardToManager(comedianId, originalMessage) {     const management = await supabase       .from('artist_management')       .select(`         *,         manager:manager_profiles(*)       `)       .eq('comedian_id', comedianId)       .eq('status', 'active')       .single();      if (management.data) {       await this.sendMessage({         manager_id: management.data.manager_id,         comedian_id: comedianId,         subject: `Forwarded: ${originalMessage.subject}`,         content: `Original message forwarded from ${originalMessage.sender}:\n\n${originalMessage.content}`,         message_type: 'general',         priority: originalMessage.priority || 'medium'       });     }   } }  // Message Templates System export class MessageTemplateService {   async getTemplates(managerId, templateType) {     const { data } = await supabase       .from('message_templates')       .select('*')       .eq('manager_id', managerId)       .eq('template_type', templateType);      return data;   }    async createTemplate(templateData) {     const { data } = await supabase       .from('message_templates')       .insert(templateData)       .select()       .single();      return data;   }    getDefaultTemplates() {     return {       booking_inquiry: {         subject: "Comedy Booking Inquiry - {venue_name}",         content: `Hi {venue_contact},  I'm reaching out on behalf of {comedian_name}, one of Australia's premier comedy performers.  We're interested in discussing a potential booking for {event_date} at {venue_name}.  {comedian_name} brings: - {experience_years} years of professional experience - Proven track record with {performance_count} successful shows - Specialization in {comedy_styles} - Average audience rating of {rating}/5 stars  Would you be interested in scheduling a call to discuss this opportunity?  Best regards, {manager_name} {agency_name}`       },       contract_negotiation: {         subject: "Contract Terms Discussion - {comedian_name}",         content: `Hi {contact_name},  Thank you for your interest in booking {comedian_name}.  Based on our discussion, I'd like to propose the following terms:  Performance Fee: ${fee} Performance Duration: {duration} minutes Technical Requirements: {tech_requirements} Travel/Accommodation: {travel_terms}  I'm confident {comedian_name} will deliver an exceptional performance for your audience.  Let me know if you'd like to discuss any adjustments to these terms.  Best regards, {manager_name}`       },       follow_up: {         subject: "Following up on {comedian_name} booking",         content: `Hi {contact_name},  I wanted to follow up on our previous conversation about booking {comedian_name} for {event_date}.  Have you had a chance to review our proposal? I'm happy to answer any questions or discuss modifications to better suit your needs.  {comedian_name} has availability for the date we discussed, but I wanted to check in before their calendar fills up.  Looking forward to hearing from you.  Best regards, {manager_name}`       }     };   } } 3.4 Commission & Financial Management javascript// Commission Management System export class CommissionManagementService {   async calculateCommissions(bookingId) {     const booking = await supabase       .from('bookings')       .select(`         *,         comedian:comedians(*),         management:artist_management(*)       `)       .eq('id', bookingId)       .single();      const totalFee = booking.data.agreed_fee;     const managementContract = booking.data.management;          if (!managementContract) {       return {         comedianPayout: totalFee * 0.95, // Platform fee only         platformFee: totalFee * 0.05,         managementCommission: 0       };     }      const commissionRate = managementContract.commission_rate;     const managementCommission = totalFee * commissionRate;     const platformFee = totalFee * 0.05;     const comedianPayout = totalFee - managementCommission - platformFee;      return {       totalFee,       managementCommission,       platformFee,       comedianPayout,       commissionRate     };   }    async processCommissionPayments(bookingId) {     const commissions = await this.calculateCommissions(bookingId);     const booking = await this.getBookingDetails(bookingId);      // Create commission records     await supabase.from('commission_records').insert([       {         booking_id: bookingId,         manager_id: booking.management?.manager_id,         comedian_id: booking.comedian_id,         commission_amount: commissions.managementCommission,         commission_rate: commissions.commissionRate,         payment_status: 'pending',         due_date: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days       }     ]);      // Schedule automatic payments     await this.scheduleCommissionPayment(booking, commissions);   }    async getManagerFinancials(managerId, dateRange) {     const { data } = await supabase       .from('commission_records')       .select(`         *,         booking:bookings(*),         comedian:comedians(name)       `)       .eq('manager_id', managerId)       .gte('created_at', dateRange.start)       .lte('created_at', dateRange.end);      const totalCommissions = data.reduce((sum, record) => sum + record.commission_amount, 0);     const paidCommissions = data       .filter(record => record.payment_status === 'paid')       .reduce((sum, record) => sum + record.commission_amount, 0);     const pendingCommissions = totalCommissions - paidCommissions;      return {       totalCommissions,       paidCommissions,       pendingCommissions,       records: data,       monthlyBreakdown: this.calculateMonthlyBreakdown(data)     };   } }  // Contract Management export class ContractManagementService {   async createManagementContract(contractData) {     const contract = await supabase       .from('artist_management')       .insert({         ...contractData,         status: 'draft',         created_at: new Date().toISOString()       })       .select()       .single();      // Generate contract document     const contractDocument = await this.generateContractDocument(contract.data);          // Send for e-signature     await this.sendForSignature(contract.data, contractDocument);      return contract;   }    async generateContractDocument(contractData) {     const template = await this.getContractTemplate();          return template       .replace('{manager_name}', contractData.manager.name)       .replace('{comedian_name}', contractData.comedian.name)       .replace('{commission_rate}', (contractData.commission_rate * 100).toFixed(2))       .replace('{contract_start}', contractData.contract_start)       .replace('{contract_end}', contractData.contract_end || 'Ongoing')       .replace('{territories}', contractData.territories.join(', '))       .replace('{services}', contractData.services_included.join(', '));   }    async renewContract(contractId) {     const existingContract = await supabase       .from('artist_management')       .select('*')       .eq('id', contractId)       .single();      // Create new contract with extended dates     const newContract = await supabase       .from('artist_management')       .insert({         ...existingContract.data,         id: undefined,         contract_start: new Date(),         contract_end: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 year         status: 'active',         created_at: new Date().toISOString()       })       .select()       .single();      // Update old contract status     await supabase       .from('artist_management')       .update({ status: 'renewed' })       .eq('id', contractId);      return newContract;   } }  ðŸ—ï¸ SYSTEM ARCHITECTURE & INTEGRATION 4.1 Microservices Architecture javascript// Service Registry const serviceRegistry = {   user_service: {     baseUrl: process.env.USER_SERVICE_URL,     endpoints: {       authentication: '/auth',       profiles: '/profiles',       permissions: '/permissions'     },     healthCheck: '/health'   },      booking_service: {     baseUrl: process.env.BOOKING_SERVICE_URL,     endpoints: {       bookings: '/bookings',       availability: '/availability',       scheduling: '/schedule'     },     healthCheck: '/health'   },      payment_service: {     baseUrl: process.env.PAYMENT_SERVICE_URL,     endpoints: {       invoices: '/invoices',       payments: '/payments',       commissions: '/commissions'     },     healthCheck: '/health'   },      communication_service: {     baseUrl: process.env.COMMUNICATION_SERVICE_URL,     endpoints: {       messages: '/messages',       notifications: '/notifications',       emails: '/emails'     },     healthCheck: '/health'   },      analytics_service: {     baseUrl: process.env.ANALYTICS_SERVICE_URL,     endpoints: {       reports: '/reports',       metrics: '/metrics',       insights: '/insights'     },     healthCheck: '/health'   } };  // API Gateway Configuration export class APIGateway {   constructor() {     this.rateLimiter = new RateLimiter({       windowMs: 60 * 1000, // 1 minute       max: 1000, // requests per minute       message: 'Too many requests from this IP'     });          this.cache = new Redis({       host: process.env.REDIS_HOST,       port: process.env.REDIS_PORT,       password: process.env.REDIS_PASSWORD     });   }    async routeRequest(request) {     // Apply rate limiting     await this.rateLimiter.check(request.ip);          // Check cache     const cacheKey = this.generateCacheKey(request);     const cachedResponse = await this.cache.get(cacheKey);          if (cachedResponse) {       return JSON.parse(cachedResponse);     }          // Route to appropriate service     const service = this.determineService(request.path);     const response = await this.forwardRequest(service, request);          // Cache response if appropriate     if (this.shouldCache(request, response)) {       await this.cache.setex(cacheKey, 300, JSON.stringify(response)); // 5 minutes     }          return response;   }    determineService(path) {     if (path.startsWith('/api/auth')) return serviceRegistry.user_service;     if (path.startsWith('/api/bookings')) return serviceRegistry.booking_service;     if (path.startsWith('/api/payments')) return serviceRegistry.payment_service;     if (path.startsWith('/api/messages')) return serviceRegistry.communication_service;     if (path.startsWith('/api/analytics')) return serviceRegistry.analytics_service;          throw new Error('Service not found for path: ' + path);   } } 4.2 Real-Time Features Implementation javascript// WebSocket Connection Manager export class WebSocketManager {   constructor() {     this.connections = new Map();     this.rooms = new Map();   }    handleConnection(socket) {     const userId = socket.handshake.auth.userId;     this.connections.set(userId, socket);          // Join user-specific room     socket.join(`user:${userId}`);          // Handle room subscriptions     socket.on('join-room', (roomId) => {       socket.join(roomId);       this.addToRoom(roomId, userId);     });          socket.on('leave-room', (roomId) => {       socket.leave(roomId);       this.removeFromRoom(roomId, userId);     });          socket.on('disconnect', () => {       this.connections.delete(userId);       this.cleanupUserRooms(userId);     });   }    // Real-time booking notifications   async notifyBookingUpdate(bookingId, updateData) {     const booking = await this.getBookingDetails(bookingId);     const notificationData = {       type: 'booking_update',       bookingId,       data: updateData,       timestamp: new Date().toISOString()     };      // Notify comedian     this.sendToUser(booking.comedian_id, 'booking-notification', notificationData);          // Notify venue     this.sendToUser(booking.venue_contact_id, 'booking-notification', notificationData);          // Notify manager if applicable     if (booking.manager_id) {       this.sendToUser(booking.manager_id, 'booking-notification', notificationData);     }   }    // Live chat system   setupLiveChat() {     this.io.on('connection', (socket) => {       socket.on('send-message', async (messageData) => {         // Save message to database         const message = await this.saveMessage(messageData);                  // Send to recipient         this.sendToUser(messageData.recipient_id, 'new-message', message);                  // Send delivery confirmation to sender         socket.emit('message-delivered', { messageId: message.id });       });              socket.on('typing-start', (data) => {         this.sendToUser(data.recipient_id, 'typing-start', {           sender_id: data.sender_id         });       });              socket.on('typing-stop', (data) => {         this.sendToUser(data.recipient_id, 'typing-stop', {           sender_id: data.sender_id         });       });     });   }    sendToUser(userId, event, data) {     const socket = this.connections.get(userId);     if (socket) {       socket.emit(event, data);     }   } }  // Push Notification Service export class PushNotificationService {   async sendNotification(userId, notification) {     const userSettings = await this.getUserNotificationSettings(userId);          if (!userSettings.push_enabled) return;          const payload = {       title: notification.title,       body: notification.body,       icon: '/icon-192x192.png',       badge: '/badge-72x72.png',       data: notification.data,       actions: notification.actions || []     };          // Send to all user devices     const devices = await this.getUserDevices(userId);          for (const device of devices) {       await this.sendToDevice(device.token, payload);     }   }    async sendToDevice(deviceToken, payload) {     // Implementation depends on your push service (FCM, APNS, etc.)     await this.pushService.send(deviceToken, payload);   } } 4.3 AI-Powered Features javascript// Smart Matching Algorithm export class SmartMatchingService {   async findOptimalMatches(venueRequirements) {     const comedians = await this.getAvailableComedians(venueRequirements.date);     const matches = [];          for (const comedian of comedians) {       const score = await this.calculateCompatibilityScore(comedian, venueRequirements);              if (score >= 70) { // Minimum threshold         matches.push({           comedian,           score,           reasoning: this.generateMatchReasoning(comedian, venueRequirements, score)         });       }     }          return matches.sort((a, b) => b.score - a.score);   }    async calculateCompatibilityScore(comedian, requirements) {     let score = 0;          // Comedy style compatibility (25 points)     const styleMatch = this.calculateStyleMatch(comedian.comedy_styles, requirements.preferred_styles);     score += styleMatch * 25;          // Audience compatibility (20 points)     const audienceMatch = this.calculateAudienceMatch(comedian.target_audience, requirements.audience_demographics);     score += audienceMatch * 20;          // Experience level (15 points)     const experienceMatch = this.calculateExperienceMatch(comedian.experience_years, requirements.experience_preference);     score += experienceMatch * 15;          // Location proximity (15 points)     const locationScore = await this.calculateLocationScore(comedian.location, requirements.venue_location);     score += locationScore * 15;          // Performance history (15 points)     const historyScore = await this.calculatePerformanceHistory(comedian.id, requirements.venue_type);     score += historyScore * 15;          // Availability (10 points)     const availabilityScore = await this.calculateAvailabilityScore(comedian.id, requirements.date);     score += availabilityScore * 10;          return Math.round(score);   }    generateMatchReasoning(comedian, requirements, score) {     const reasons = [];          if (score >= 90) {       reasons.push(`Perfect match for ${requirements.venue_name}`);     } else if (score >= 80) {       reasons.push(`Excellent compatibility`);     } else if (score >= 70) {       reasons.push(`Good fit with potential`);     }          // Add specific strengths     if (comedian.comedy_styles.some(style => requirements.preferred_styles.includes(style))) {       reasons.push(`Specializes in ${comedian.comedy_styles.join(', ')}`);     }          if (comedian.average_rating >= 4.5) {       reasons.push(`Highly rated performer (${comedian.average_rating}/5)`);     }          return reasons;   } }  // Predictive Analytics export class PredictiveAnalyticsService {   async predictEventSuccess(eventData) {     const features = await this.extractFeatures(eventData);     const prediction = await this.runPredictionModel(features);          return {       successProbability: prediction.probability,       expectedAttendance: prediction.attendance,       revenueProjection: prediction.revenue,       riskFactors: prediction.risks,       recommendations: prediction.recommendations     };   }    async extractFeatures(eventData) {     return {       venue_capacity: eventData.venue.capacity,       comedian_rating: eventData.comedian.average_rating,       historical_attendance: await this.getHistoricalAttendance(eventData.venue.id),       day_of_week: new Date(eventData.date).getDay(),       season: this.getSeason(eventData.date),       local_events: await this.getCompetingEvents(eventData.date, eventData.location),       marketing_reach: eventData.marketing_budget,       ticket_price: eventData.ticket_price     };   }    async generateContentRecommendations(comedianId) {     const comedian = await this.getComedianProfile(comedianId);     const recentPerformances = await this.getRecentPerformances(comedianId);     const trends = await this.getCurrentTrends();          return {       videoContent: this.suggestVideoContent(comedian, trends),       socialMediaPosts: this.generateSocialMediaPosts(comedian, recentPerformances),       marketingCopy: this.generateMarketingCopy(comedian),       hashtagSuggestions: this.suggestHashtags(comedian, trends)     };   } }  // Automated Content Generation export class ContentGenerationService {   async generatePromotionalContent(eventData) {     const comedian = eventData.comedian;     const venue = eventData.venue;     const event = eventData.event;          return {       socialMediaPosts: {         instagram: this.generateInstagramPost(comedian, venue, event),         facebook: this.generateFacebookPost(comedian, venue, event),         twitter: this.generateTwitterPost(comedian, venue, event)       },       emailMarketing: this.generateEmailTemplate(comedian, venue, event),       pressRelease: this.generatePressRelease(comedian, venue, event),       websiteContent: this.generateWebsiteContent(comedian, venue, event)     };   }    generateInstagramPost(comedian, venue, event) {     return {       caption: `ðŸŽ­ Get ready to laugh until your sides hurt! ${comedian.name} is bringing their hilarious ${comedian.comedy_styles[0]} comedy to ${venue.name} on ${event.date}!   Don't miss this incredible night of entertainment. Tickets are flying out the door!   #StandUpComedy #${comedian.name.replace(' ', '')} #${venue.name.replace(' ', '')} #ComedyNight #LiveComedy #FunnySydney`,              hashtags: [         '#StandUpComedy',         `#${comedian.name.replace(' ', '')}`,         `#${venue.name.replace(' ', '')}`,         '#ComedyNight',         '#LiveEntertainment',         '#SydneyComedy'       ],              suggestedImage: 'comedian_action_shot_with_venue_branding',       postTime: 'optimal_engagement_time'     };   }    async processVideoClip(videoFile, outputFormats) {     const results = {};          for (const format of outputFormats) {       switch (format) {         case 'instagram_story':           results.instagram_story = await this.resizeForInstagramStory(videoFile);           break;         case 'instagram_feed':           results.instagram_feed = await this.resizeForInstagramFeed(videoFile);           break;         case 'facebook_post':           results.facebook_post = await this.resizeForFacebookPost(videoFile);           break;         case 'twitter_video':           results.twitter_video = await this.resizeForTwitter(videoFile);           break;         case 'tiktok':           results.tiktok = await this.resizeForTikTok(videoFile);           break;       }     }          return results;   } }  ðŸ“‹ IMPLEMENTATION CHECKLIST Agent 1 Tasks (Payment & Financial)   Implement invoice database schema  Build FlexPay integration system  Create automated invoice generation  Set up commission calculation logic  Build financial reporting dashboard  Implement payment reminder system  Create recurring invoice automation  Set up accounting software exports  Agent 2 Tasks (Platform & UI/UX)   Redesign landing page with video background  Fix comedian card layouts (square images)  Apply consistent theme to messages/notifications  Implement Facebook Ads integration  Build PWA capabilities  Add push notification system  Create mobile-optimized interfaces  Implement one-click contract generation  Agent 3 Tasks (Agency Management)   Build agency database schema  Create manager dashboard  Implement artist discovery system  Build communication hub  Create deal negotiation tools  Implement commission management  Build contract management system  Create message forwarding system   ðŸš€ DEPLOYMENT STRATEGY N8N Automation Workflows javascript// Workflow Templates for Each Agent Section  // Agent 1: Payment Automation const paymentWorkflows = [   'invoice-generation-from-booking',   'payment-reminder-automation',   'commission-calculation-and-distribution',   'recurring-invoice-processing',   'late-payment-handling' ];  // Agent 2: Platform Automation const platformWorkflows = [   'facebook-ads-data-sync',   'comedian-profile-optimization',   'mobile-push-notifications',   'content-generation-automation',   'seo-optimization-automation' ];  // Agent 3: Agency Automation const agencyWorkflows = [   'manager-onboarding-automation',   'artist-discovery-notifications',   'deal-negotiation-tracking',   'communication-routing',   'contract-renewal-reminders' ]; This comprehensive specification provides your AI agents with detailed implementation guides for building a world-class comedy booking platform that rivals industry leaders while maintaining the existing Supabase + Lovable + N8N architecture.

## EXECUTION_LOG
- Task created
- Awaiting agent processing...
